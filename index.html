<!DOCTYPE html>
<html>

    <head>
        <title>Syd test</title>
        <style>
            textarea,
            pre {
                font-family: "Fira Code", monospace;
            }

            canvas {
                image-rendering: pixelated;
                image-rendering: crisp-edges;
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-optimize-contrast;
            }

            .stderr {
                color: red;
            }
        </style>
    </head>

    <body>
        <h1>Syd test</h1>
        <p><a href="https://github.com/dragoncoder047/syd?tab=readme-ov-file">(What is this?)</a></p>
        <p><button id="play">Play</button></p>
        <p>Instrument: <textarea id="instrument" rows="10" cols="80">// In lieu of a sequencer...
s = (s+1) % 6; t += (s == 0);
// the "42" melody
t * (42 & t>>10)
|> (# & 255) / 1024
|> zzfxFilter(#, 1, 1)
|> zzfxFilter(#, -450, 10)
|> bitcrusher(#)
|> (prev = # + 0.5 * delay(prev, 1 + zzfxOscillator(1)))</textarea></p>
        <canvas id="oscilloscope" width="800" height="200"></canvas>
        <div id="log"></div>
        <script type="module">
            import * as syd from "./build/index.js";
            import { get, make, bind, waitFor } from "https://cdn.jsdelivr.net/gh/dragoncoder047/vanilla@main/vanilla.js";

            const canvas = get("#oscilloscope");
            const gfx = canvas.getContext("2d");

            const audio = new AudioContext;


            const logArea = get("#log");

            await syd.initWorklet(audio);
            waitFor("#play", "click").then(started);

            const synth = syd.newSynth(audio);

            const fftL = audio.createAnalyser();
            const fftR = audio.createAnalyser();
            const splitter = audio.createChannelSplitter(2);

            synth.audioNode.connect(audio.destination);
            synth.audioNode.connect(splitter);
            splitter.connect(fftL, 0);
            splitter.connect(fftR, 1);

            synth.audioNode.onprocessorerror = e => {
                showError("Synth died unexpectedly: " + e);
                console.log(e);
            };

            bind("#instrument", "input", debounce(300, async () => {
                const src = get("#instrument").value;
                const dummyName = "<textarea>";
                const fs = { ...syd.libSrc, [dummyName]: src };
                try {
                    clearLog();
                    await synth.clearAll();
                    const env = await makeEnv();
                    const ast = await syd.parse(src, dummyName);
                    const evaled = await ast.eval(env);
                    console.log("Evaled", evaled);
                    const compiled = syd.compileNode(evaled, syd.newCompileData(), new Map, syd.nodes());
                    console.log("Final program", compiled);
                    showLog(syd.disassemble(compiled));
                    await synth.setPostFX(compiled);
                } catch (e) {
                    showError(e instanceof syd.SydError ? e.displayOn(fs) : e.stack);
                    throw e;
                }
            }));

            async function makeEnv() {
                const env = await syd.newEnv();
                env.functions.push([
                    "log",
                    1,
                    async (args, env) => {
                        const value = await args[0].eval(env);
                        if (!(value instanceof syd.Value)) {
                            showLog(`(${value.constructor.name}) ${JSON.stringify(value, null, 4)}`);
                        }
                        else showLog(value.value);
                        return value;
                    }
                ]);
                return env;
            }

            function started() {
                audio.resume();
                showLog("Started audio");
                drawOscilloscope();
            }

            function showLog(logText) {
                logArea.prepend(make("div", {}, make("pre", {}, logText)));
            }
            function showError(logText) {
                logArea.prepend(make("div.stderr", {}, make("pre", {}, logText)));
            }
            function clearLog() {
                logArea.innerHTML = "";
            }

            const samplesL = new Float32Array(fftL.fftSize);
            const samplesR = new Float32Array(fftR.fftSize);
            const spectrumL = new Uint8Array(fftL.frequencyBinCount);
            const spectrumR = new Uint8Array(fftR.frequencyBinCount);
            function drawOscilloscope() {
                requestAnimationFrame(drawOscilloscope);
                fftL.getFloatTimeDomainData(samplesL);
                fftR.getFloatTimeDomainData(samplesR);
                fftL.getByteFrequencyData(spectrumL);
                fftR.getByteFrequencyData(spectrumR);

                const ratio = window.devicePixelRatio || 1;
                const width = canvas.width = (canvas.style.width = 500) * ratio;
                const height = canvas.height = (canvas.style.height = 100) * ratio;
                gfx.imageSmoothingEnabled = false;
                gfx.clearRect(0, 0, width, height);
                gfx.lineWidth = 1;
                gfx.strokeStyle = "rgba(127, 150, 255, 80%)";
                drawSamples(spectrumL, gfx, width, s => map(s, 0, 255, height, height / 2));
                gfx.strokeStyle = "rgba(255, 150, 127, 80%)";
                drawSamples(spectrumR, gfx, width, s => map(s, 0, 255, height, height / 2));
                gfx.lineWidth = 2;
                gfx.strokeStyle = "rgb(0, 0, 255, 80%)";
                drawSamples(samplesL, gfx, width, s => map(s, -1, 1, height / 2, 0));
                gfx.strokeStyle = "rgb(255, 0, 0, 80%)";
                drawSamples(samplesR, gfx, width, s => map(s, -1, 1, height / 2, 0));
            }

            function drawSamples(samples, gfx, width, transform) {
                gfx.beginPath();
                for (var i = 0; i < samples.length; i++) {
                    gfx[i > 0 ? "lineTo" : "moveTo"]((i / samples.length) * width, transform(samples[i]));
                }
                gfx.stroke();
            }

            function debounce(timeout, fun) {
                var tid = null;
                return () => {
                    clearTimeout(tid);
                    setTimeout(fun, timeout);
                }
            }

            function map(n, a, b, x, y) {
                return (n - a) * (y - x) / (b - a) + x;
            }
        </script>
    </body>

</html>