{
  "version": 3,
  "sources": ["../../src/esbuildPlugin/include.ts", "../../src/esbuildPlugin/tojs.ts", "../../src/esbuildPlugin/index.ts"],
  "sourcesContent": ["import { readFileSync } from \"node:fs\";\nimport { basename, dirname, resolve } from \"node:path\";\nimport { parse } from \"../compiler\";\nimport * as AST from \"../compiler/ast\";\nimport { ErrorNote, LocationTrace, ParseError } from \"../compiler/errors\";\nimport { isinstance, str } from \"../utils\";\n\nexport class IncludePlaceholder extends AST.Leaf {\n    exists = true;\n    constructor(loc: LocationTrace, public varname: string | null, public filename: string) { super(loc); }\n}\nexport async function include(entrypoint: string, outSourceFileMap: Record<string, string>): Promise<{\n    order: string[],\n    watchFiles: string[],\n    map: Record<string, AST.Node>\n}> {\n    // first recursively check all of the files and find their dependencies\n    const fileToDepsPlaceholderMap = new Map<string, [IncludePlaceholder, IncludePlaceholder[]]>();\n    const filenameToNodeMap: Record<string, AST.Node> = {};\n    const entryPlaceholder = new IncludePlaceholder(LocationTrace.nowhere, null, resolve(entrypoint));\n    const toCheck = [entryPlaceholder];\n    while (toCheck.length > 0) {\n        const cur = toCheck.shift()!;\n        if (fileToDepsPlaceholderMap.has(cur.filename)) continue;\n        const deps = await getFile(cur, outSourceFileMap, filenameToNodeMap);\n        fileToDepsPlaceholderMap.set(cur.filename, [cur, deps]);\n        for (var dep of deps) {\n            toCheck.push(dep);\n        }\n    }\n    // Dumb Toposort / checking for circular includes and stuff\n    const orderSet = new Set<string>();\n    const recurse = (curFile: string, stack: IncludePlaceholder[]) => {\n        const [curIP, deps] = fileToDepsPlaceholderMap.get(curFile)!;\n        const sm1 = stack.slice(1);\n        const errTrace = sm1.map(t => new ErrorNote(\"note: included from here:\", t.loc));\n        // check if file exists\n        if (!curIP.exists) {\n            throw new ParseError(\"no such file \" + str(curFile), stack[0]!.loc, errTrace.slice(0, -1));\n        }\n        // check if circular deps\n        if (sm1.some(t => t.filename === curFile)) {\n            throw new ParseError(errTrace.length > 1 ? \"circular #!include\" : \"file #!include's itself\", stack[0]!.loc, errTrace.slice(0, -1));\n        }\n        // move to front\n        const had = orderSet.delete(curFile);\n        orderSet.add(curFile);\n        if (had) return;\n        // recurse on dependencies\n        for (var dep of deps) {\n            recurse(dep.filename, [dep, ...stack]);\n        }\n    }\n    recurse(entrypoint, [entryPlaceholder]);\n    const orderFiles = [...orderSet].reverse();\n    const varnameToNodeMap: Record<string, AST.Node> = {};\n    const filenameToVarnameMap: Record<string, string> = {};\n    for (var i = 0; i < orderFiles.length; i++) {\n        const [p] = fileToDepsPlaceholderMap.get(orderFiles[i]!)!;\n        varnameToNodeMap[filenameToVarnameMap[p.filename] = p.varname = \"_\" + basename(p.filename).toLowerCase().replace(/\\.syd$/, \"\").replace(/\\W/g, \"\") + i] = filenameToNodeMap[p.filename]!;\n    }\n    // copy to others\n    for (var [_, [s, ds]] of fileToDepsPlaceholderMap.entries()) {\n        s.varname = filenameToVarnameMap[s.filename]!;\n        for (var d of ds) {\n            d.varname = filenameToVarnameMap[d.filename]!;\n        }\n    }\n    return {\n        order: orderFiles.map(f => filenameToVarnameMap[f]!), map: varnameToNodeMap,\n        watchFiles: [...fileToDepsPlaceholderMap.keys()],\n    };\n}\nasync function getFile(where: IncludePlaceholder, sourceMap: Record<string, string>, nodeMap: Record<string, AST.Node>): Promise<IncludePlaceholder[]> {\n    const deps: IncludePlaceholder[] = [];\n    const walk = async (ast: AST.Node): Promise<AST.Node> => {\n        if (\n            !isinstance(ast, AST.AnnotatedValue) ||\n            !isinstance(ast.value, AST.Value) ||\n            typeof ast.value.value !== \"string\" ||\n            ast.attributes.length !== 1 ||\n            !isinstance(ast.attributes[0], AST.Name) ||\n            ast.attributes[0]!.name !== \"include\"\n        ) return ast.pipe(walk);\n        const p = new IncludePlaceholder(ast.value.loc, null, resolve(dirname(where.filename), ast.value.value));\n        deps.push(p);\n        return p;\n    }\n    try {\n        nodeMap[where.filename] = await walk(await parseFile(where.filename, sourceMap));\n    } catch (e: any) {\n        if (e.code === \"ENOENT\") {\n            where.exists = false;\n        }\n        else {\n            throw e;\n        }\n    }\n    return deps;\n}\n\nasync function parseFile(filename: string, filemap: Record<string, string>): Promise<AST.Node> {\n    return await parse(filemap[basename(filename)] = readFileSync(filename, \"utf8\"), basename(filename));\n}\n", "import { readFileSync } from \"node:fs\";\nimport { basename } from \"node:path\";\nimport { parse } from \"../compiler\";\nimport * as AST from \"../compiler/ast\";\nimport { LocationTrace, ParseError } from \"../compiler/errors\";\nimport { isinstance, str } from \"../utils\";\nimport { IncludePlaceholder, include } from \"./include\";\n\nconst internedStrings = new Map<string, string>();\nvar internStringCounter = 0;\nexport function internString(s: string): string {\n    if (!internedStrings.has(s)) {\n        internedStrings.set(s, \"_str\" + (internStringCounter++) + s.toLowerCase().replaceAll(/\\W/g, \"\"));\n    }\n    return internedStrings.get(s)!;\n}\n\nfunction getInternedStrings(): string {\n    return `const ${indent([...internedStrings].map(([val, name]) => `\\n${name} = ${str(val)}`).join(\", \"))};`;\n}\n\nfunction indent(string: string): string {\n    return string ? string.split(\"\\n\").map(l => \"    \" + l).join(\"\\n\") : \"\";\n}\n\nconst neededNames = new Set<string>();\nfunction code(name: string, o: AST.Node, ...args: string[]): string {\n    neededNames.add(name);\n    return `new ${name}(${location(o.loc)}${args.length > 0 ? \",\\n\" : \"\"}${indent(args.join(\",\\n\"))})`;\n}\n\nfunction location(t: LocationTrace): string {\n    return `new LocationTrace(${t.line}, ${t.col}, ${internString(t.file)})`;\n}\n\nfunction liststr(args: string[]): string {\n    return `[${args.length > 0 ? \"\\n\" : \"\"}${indent(args.join(\",\\n\"))}]`;\n}\n\nfunction list(args: AST.Node[]): string {\n    return liststr(args.map(toJS));\n}\n\nfunction prim(arg: string | number | boolean): string {\n    if (typeof arg === \"string\") return internString(arg);\n    return str(arg);\n}\n\nfunction toJS(ast: AST.Node): string {\n    if (isinstance(ast, AST.AnnotatedValue))\n        return ast.value ? code(\"AnnotatedValue\", ast, list(ast.attributes), toJS(ast.value)) : code(\"AnnotatedValue\", ast, list(ast.attributes));\n    if (isinstance(ast, AST.Value))\n        return code(\"Value\", ast, prim(ast.value));\n    if (isinstance(ast, AST.Symbol))\n        return code(\"Symbol\", ast, prim(ast.value));\n    if (isinstance(ast, AST.Name))\n        return code(\"Name\", ast, prim(ast.name));\n    if (isinstance(ast, AST.Assignment))\n        return code(\"Assignment\", ast, toJS(ast.target), toJS(ast.value));\n    if (isinstance(ast, AST.Call))\n        return code(\"Call\", ast, prim(ast.name), list(ast.args));\n    if (isinstance(ast, AST.List))\n        return code(\"List\", ast, list(ast.values));\n    if (isinstance(ast, AST.Definition))\n        return code(\"Definition\", ast, prim(ast.name), prim(ast.outMacro), list(ast.parameters), toJS(ast.body));\n    if (isinstance(ast, AST.Template))\n        return code(\"Template\", ast, toJS(ast.result));\n    if (isinstance(ast, AST.InterpolatedValue))\n        return code(\"InterpolatedValue\", ast, toJS(ast.value));\n    if (isinstance(ast, AST.SplatValue))\n        return code(\"SplatValue\", ast, toJS(ast.value));\n    if (isinstance(ast, AST.PipePlaceholder))\n        return code(\"PipePlaceholder\", ast);\n    if (isinstance(ast, AST.BinaryOp))\n        return code(\"BinaryOp\", ast, prim(ast.op), toJS(ast.left), toJS(ast.right), ...(ast.assign ? [prim(ast.noLift), location(ast.assign)] : []));\n    if (isinstance(ast, AST.UnaryOp))\n        return code(\"UnaryOp\", ast, prim(ast.op), toJS(ast.value));\n    if (isinstance(ast, AST.Conditional))\n        return code(\"Conditional\", ast, toJS(ast.cond), toJS(ast.caseTrue), toJS(ast.caseFalse));\n    if (isinstance(ast, AST.DefaultPlaceholder))\n        return code(\"DefaultPlaceholder\", ast);\n    if (isinstance(ast, AST.KeywordArgument))\n        return code(\"KeywordArgument\", ast, prim(ast.name), toJS(ast.arg));\n    if (isinstance(ast, AST.Block))\n        return code(\"Block\", ast, list(ast.body));\n    if (isinstance(ast, AST.ParameterDescriptor))\n        return code(\"ParameterDescriptor\", ast, prim(ast.name), toJS(ast.enumOptions), toJS(ast.defaultValue), prim(ast.lazy));\n    if (isinstance(ast, AST.Mapping))\n        return code(\"Mapping\", ast, liststr(ast.mapping.map(({ key, val }) => `{ key: ${toJS(key)}, val: ${toJS(val)} }`)));\n    if (isinstance(ast, IncludePlaceholder))\n        return ast.varname!;\n    throw \"unreachable! \" + ast;\n}\n\nexport async function toJSFile(filename: string): Promise<{ src: string, watchFiles: string[] }> {\n    var order: string[], map: Record<string, AST.Node>, watchFiles: string[];\n    const files: Record<string, string> = {};\n    try {\n        const res = await include(filename, files);\n        order = res.order;\n        map = res.map;\n        watchFiles = res.watchFiles;\n    } catch (e) {\n        if (!isinstance(e, ParseError)) throw e;\n        console.error(e.displayOn(files));\n        throw e;\n    }\n    internStringCounter = 0;\n    internedStrings.clear();\n    neededNames.clear();\n    neededNames.add(\"LocationTrace\");\n    const js = order.map(m => `const ${m} = ${toJS(map[m]!)}`).join(\"\\n\\n\");\n    return {\n        src: `import { ${[...neededNames.values()].join(\", \")} } from \"syd\";\n\nexport const sources = /* @__PURE__ */ {\n    ${Object.entries(files).map(([name, source]) => `${str(name)}:\\n${indent(str(source.split(\"\\n\"), null, 4))}.join(\"\\\\n\")`).join(\",\\n    \")}\n};\n\n${getInternedStrings()}\n\n${js}\n\nexport const ast = ${order.at(-1)};\n\nexport default ast;\n`, watchFiles\n    };\n}\n", "import type { PluginBuild } from \"esbuild\";\nimport { toJSFile } from \"./tojs\";\n\nexport function sydPlugin() {\n    return {\n        name: \"syd\",\n        setup(build: PluginBuild) {\n            // Load \".syd\" files and return an AST as JS expression\n            build.onLoad({ filter: /\\.syd$/ }, async args => {\n                const { src, watchFiles } = await toJSFile(args.path);\n                return {\n                    contents: src,\n                    watchFiles,\n                    loader: \"js\",\n                }\n            });\n        },\n    }\n}\n"],
  "mappings": "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",
  "names": ["dep"]
}
