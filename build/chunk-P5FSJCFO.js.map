{
  "version": 3,
  "sources": ["../src/compiler/errors.ts", "../src/utils.ts", "../src/math.ts", "../src/compiler/operator.ts", "../src/compiler/prog.ts"],
  "sourcesContent": ["export class LocationTrace {\n    constructor(\n        public line: number,\n        public col: number,\n        public file: string,\n        public source: [string, LocationTrace] | null = null) { }\n\n    static nowhere = new LocationTrace(0, 0, \"unknown\");\n}\nfunction formatTrace(trace: LocationTrace, message: string, sources: Record<string, string>): string {\n    const src = sources[trace.file];\n    var lineInfo = \"\";\n    if (src) {\n        const lines = src.split(\"\\n\");\n        const relevantLine = lines[trace.line] || \"\";\n        const lineNumberString = trace.line + 1 + \"\";\n        lineInfo = `\\n${lineNumberString} | ${relevantLine}\\n${\" \".repeat(lineNumberString.length)} | ${\" \".repeat(trace.col)}^`;\n    }\n    return `${trace.file}:${trace.line + 1}:${trace.col + 1}: ${message}${lineInfo}${trace.source ? \"\\n\" + formatTrace(trace.source[1], trace.source[0], sources) : \"\"}`;\n}\n\nexport class ErrorNote {\n    constructor(public message: string, public location: LocationTrace) { }\n}\n\nexport class SydError extends Error {\n    constructor(message: string, public trace: LocationTrace = LocationTrace.nowhere, public notes: ErrorNote[] = []) {\n        super(message);\n    }\n    displayOn(sources: Record<string, string>): string {\n        return formatTrace(this.trace, \"error: \" + this.message, sources) + this.notes.map(note => \"\\n\" + formatTrace(note.location, note.message, sources)).join(\"\") + \"\\n\";\n    }\n}\n\nexport class ParseError extends SydError { }\n\nexport class RuntimeError extends SydError { }\n\nexport class CompileError extends SydError { }\n", "// export const mapObject = <T, U>(obj: Record<string, T>, func: (value: T, key: string) => U): Record<string, U> =>\n//     Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, func(value, key)]));\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\n// export const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\n// export const isString = is(\"string\") as (x: any) => x is string;\n// export const isNull = (x: any): x is null => x === null;\n// export const isEmpty = (x: any[]): x is [] => x.length === 0;\n// type Predicate<T, U extends T> = (x: T) => x is U;\n// type AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\n// type UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\n// export const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\n// export const isObject = is(\"object\") as (x: any) => x is Record<string, any>;\n\n// export const isConstant = (x: any): x is null | undefined | number | string => any(x, isNull, isUndefined, isNumber) || (isString(x) && !(isRef(x) || isNodeName(x) || isInputRef(x)));\n// export const isNode = (x: any): x is NodeTree =>\n//     any(x, isString, isNumber, isUndefined, isNull)\n//         ? false\n//         : isArray(x) && isString(x[0])\n//             ? (isNamedNode(x) ? isNode(getNodeContents(x)) : true)\n//             : (isArray(x[0]) && !isEmpty(x[0]) && isString(x[0][0]));\n\n// const isTypeString = <T extends string>(starter: T) => (x: any): x is `${T}${string}` =>\n//     isString(x) && x.startsWith(starter);\n// export const isRef = isTypeString(\"@\");\n// export const isNodeName = isTypeString(\"=\");\n// export const isInputRef = isTypeString(\">\");\n// export const isNamedNode = (x: any): x is [NodeName, ...any[]] => isArray(x) && isNodeName(x[0]);\n// export const getNodeName = (x: any): NodeName | undefined => isNamedNode(x) ? x[0] : undefined;\n// export const getNodeContents = (x: any): any[] => isNamedNode(x) ? x.slice(1) : x;\n\nexport const str = JSON.stringify;\n\n// const gensymCounters: Record<string, number> = {};\n// export function gensym<T extends string>(prefix: T): `${T}${number}` {\n//     gensymCounters[prefix] = (gensymCounters[prefix] || 0) + 1;\n//     return `${prefix}${gensymCounters[prefix]}` as const;\n// }\n\nexport function isinstance<C>(obj: any, cls: abstract new (...args: any[]) => C): obj is C {\n    return obj instanceof cls;\n}\n\nconst idMap = new WeakMap<Object, number>();\nvar idCounter = 0;\nexport const id = (obj: any): number => {\n    if (!idMap.has(obj)) idMap.set(obj, idCounter++);\n    return idMap.get(obj)!\n}\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const min = Math.min;\nexport const max = Math.max;\nexport const clamp = (x: number, y: number, z: number) => max(min(x, z), y);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n\n// From https://stackoverflow.com/a/27205341/23626926\nexport const matMul = (a: number[][], b: number[][]) => {\n    var aNumRows = a.length, aNumCols = a[0]!.length, bNumCols = b[0]!.length, m = [] as number[][];\n    for (var r = 0; r < aNumRows; r++) {\n        m[r] = [] as number[];\n        for (var c = 0; c < bNumCols; c++) {\n            m[r]![c] = 0;\n            for (var i = 0; i < aNumCols; i++) {\n                m[r]![c]! += a[r]![i]! * b[i]![c]!;\n            }\n        }\n    }\n    return m;\n};\n", "import { matMul } from \"../math\";\nimport { str } from \"../utils\";\nimport { ParseError } from \"./errors\";\nimport type { Token } from \"./tokenizer\";\n\n/** constant used to note that an operator is not valid in this context (unary or binary) */\nexport const INVALID = -1;\n\nclass Operator {\n    cb: ((this: unknown, a: any, b: any) => any) | null = null;\n    cu: ((this: unknown, a: any) => any) | null = null;\n    constructor(\n        public b: number,\n        public u: number = INVALID,\n        public r: boolean = false) { }\n    code(b: this[\"cb\"], u: this[\"cu\"] = null) {\n        this.cb = b;\n        this.cu = u;\n        return this;\n    }\n}\n\nconst op: (...args: ConstructorParameters<typeof Operator>) => Operator = (b, u, r) => new Operator(b, u, r);\n\nexport const OPERATORS: Record<string, Operator> = {\n    // attribute sigil\n    \"#!\": op(INVALID, -Infinity),\n    // symbol name\n    \".\": op(INVALID, -Infinity),\n    // interpolate and bitwise AND\n    \"&\": op(6, 0).code((a, b) => a & b),\n    // length or as 0-ary pipeline placeholder (that is handled specially)\n    \"#\": op(INVALID, 0).code(null, a => a.length),\n    // boolean NOT\n    \"!\": op(INVALID, 0).code(null, a => !a),\n    // power\n    \"**\": op(1, INVALID, true).code((a, b) => a ** b),\n    // multiply or splat operator\n    \"*\": op(3, -Infinity).code((a, b) => a * b),\n    // divide & modulo\n    \"/\": op(3).code((a, b) => a / b),\n    \"%\": op(3).code((a, b) => a % b),\n    // matrix multiply\n    // or decorator to mark param or declaration as lazy/macro\n    \"@\": op(3, -Infinity).code(matMul as any),\n    // add\n    \"+\": op(4).code((a, b) => a + b),\n    // subtract, negate\n    \"-\": op(4, 2).code((a, b) => a - b, a => -a),\n    // boolean OR / AND\n    \"||\": op(5).code((a, b) => a || b),\n    \"&&\": op(5).code((a, b) => a && b),\n    // bitwise OR / XOR\n    \"|\": op(6).code((a, b) => a | b),\n    \"^\": op(6).code((a, b) => a ^ b),\n    // comparison\n    \"==\": op(7).code((a, b) => a == b),\n    \">=\": op(7).code((a, b) => a >= b),\n    \">\": op(7).code((a, b) => a > b),\n    \"<=\": op(7).code((a, b) => a <= b),\n    \"<\": op(7).code((a, b) => a < b),\n    \"!=\": op(7).code((a, b) => a != b),\n    // pipe\n    \"|>\": op(8),\n    // conditional in 2 parts (treated as binary and postprocessed for simplicity)\n    // colon is also used for keyword arguments\n    \":\": op(9),\n    \"?\": op(10),\n    // assignment operator (no overloads and handles specially, just here so it can be parsed in the right spot)\n    \"=\": op(11),\n    // mapping operator (for inside lists)\n    \"=>\": op(12),\n    // define operator (handled specially)\n    \":-\": op(12),\n    // statement separator\n    \",\": op(13).code((_, b) => b),\n    \";\": op(13),\n};\n\nexport const OP_REGEX = new RegExp(`^(${Object.keys(OPERATORS).sort((a, b) => b.length - a.length).map(e => e.replaceAll(/([()[\\]{}*+?|^$\\\\.])/g, \"\\\\$1\")).join(\"|\")})`);\n\nexport function getPrecedence(token: string, unary: boolean): number {\n    return OPERATORS[token]![unary ? \"u\" : \"b\"] ?? INVALID;\n}\n\nexport function getPrecedenceAndCheckValidity(token: Token, isUnary: boolean): number {\n    const keyOperator = token.a ? \"=\" : token.t;\n    const realOperator = token.t + (token.a ? \"=\" : \"\")\n    const mePrecedence = getPrecedence(keyOperator, isUnary);\n    if (mePrecedence === INVALID) {\n        throw new ParseError(`${str(realOperator)} is not valid as a ${[\"binary\", \"unary\"][+isUnary]} operator`, token.s);\n    }\n    return mePrecedence;\n}\n\nexport function isRightAssociative(token: string): boolean {\n    return OPERATORS[token]!.r;\n}\n", "import { AutomatedValueMethod } from \"../runtime/automation\";\n\nexport enum Opcode {\n    /** next is the constant */\n    PUSH_CONSTANT,\n    PUSH_INPUT_SAMPLES,\n    PUSH_PITCH,\n    PUSH_EXPRESSION,\n    PUSH_GATE,\n    MARK_STILL_ALIVE,\n    DROP_TOP,\n    PUSH_FRESH_EMPTY_LIST,\n    APPEND_TO_LIST,\n    EXTEND_TO_LIST,\n    /** next is opcode */\n    DO_BINARY_OP,\n    /** next is opcode */\n    DO_UNARY_OP,\n    /** next is register no. */\n    GET_REGISTER,\n    /** next is register no. */\n    TAP_REGISTER,\n    CONDITIONAL_SELECT,\n    /** doubles the sample into a [sample, sample] left right pair */\n    STEREO_DOUBLE_WIDEN,\n    /** next 2 is node no, argc */\n    APPLY_NODE,\n    /** next 3 is node no A and B, argc */\n    APPLY_DOUBLE_NODE_STEREO,\n    /** next is input number, returns 0 if doesn't exist */\n    GET_MOD,\n}\n\nexport type Program = (Opcode | number | string)[];\n\nexport interface CompileState {\n    p: Program;\n    r: string[];\n    nn: string[];\n    tosStereo: boolean;\n    mods: [name: string, initial: number, mode: AutomatedValueMethod][]\n}\n\nexport function allocRegister(name: string, state: CompileState): number {\n    const i = state.r.indexOf(name);\n    if (i === -1) return state.r.push(name) - 1;\n    return i;\n}\nexport function allocNode(name: string, state: CompileState): number {\n    return state.nn.push(name) - 1;\n}\n\nexport function allocMod(name: string, state: CompileState, initial: number, mode: AutomatedValueMethod): number {\n    return state.mods.push([name, initial, mode]) - 1;\n}\n"],
  "mappings": "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",
  "names": ["LocationTrace", "_LocationTrace", "line", "col", "file", "source", "__name", "formatTrace", "trace", "message", "sources", "src", "lineInfo", "relevantLine", "lineNumberString", "ErrorNote", "location", "SydError", "notes", "note", "ParseError", "RuntimeError", "CompileError", "typeOf", "__name", "x", "is", "t", "func", "isNumber", "isArray", "str", "isinstance", "obj", "cls", "PI", "TAU", "min", "max", "clamp", "__name", "x", "y", "z", "sin", "cos", "sgn", "abs", "tan", "saw", "tri", "noise3", "noise5", "matMul", "a", "b", "aNumRows", "aNumCols", "bNumCols", "m", "r", "c", "i", "INVALID", "Operator", "b", "u", "r", "__name", "op", "OPERATORS", "a", "matMul", "_", "OP_REGEX", "e", "getPrecedence", "token", "unary", "getPrecedenceAndCheckValidity", "isUnary", "keyOperator", "realOperator", "mePrecedence", "ParseError", "str", "isRightAssociative", "allocRegister", "name", "state", "i", "__name", "allocNode"]
}
