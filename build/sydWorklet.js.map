{
  "version": 3,
  "sources": ["../src/runtime/automation.ts", "../src/runtime/tone.ts", "../src/runtime/instrument.ts", "../src/runtime/synthImpl.ts", "../src/worklet/index.ts", "../src/sydWorklet.ts"],
  "sourcesContent": ["import { max, min } from \"../math\";\n\nexport enum AutomatedValueMethod {\n    LINEAR,\n    EXPONENTIAL,\n    STEP\n}\n\nexport class AutomatedValue {\n    delta: number = 0;\n    value: number = 0;\n    target: number = 0;\n    timeLeft: number = 0;\n    constructor(\n        initial: number,\n        public mode: AutomatedValueMethod,\n    ) {\n        this.value = initial;\n    }\n    goto(newValue: number, dt: number, time: number) {\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: this.delta = dt * (newValue - this.value) / time; break;\n            case AutomatedValueMethod.EXPONENTIAL:\n                if ((this.value * newValue) <= 0) {\n                    throw new Error(\"cannot cross 0 when in exponential mode\");\n                }\n                this.delta = Math.pow(newValue / this.value, dt / time);\n        }\n        this.target = newValue;\n        this.timeLeft = time;\n    }\n    /** HOT CODE */\n    update(dt: number) {\n        this.timeLeft -= dt;\n        if (this.timeLeft < 0) {\n            this.timeLeft = 0;\n            return this.value = this.target;\n        }\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: return this.value += this.delta;\n            case AutomatedValueMethod.EXPONENTIAL: return this.value *= this.delta;\n        }\n    }\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { OPERATORS } from \"../compiler/operator\";\nimport { CompiledVoiceData, Opcode, Program } from \"../compiler/prog\";\nimport { isArray, isNumber } from \"../utils\";\nimport { AutomatedValue, AutomatedValueMethod } from \"./automation\";\nimport { WorkletSynth } from \"./synthImpl\";\n\nexport enum PassMode {\n    SET,\n    ADD,\n}\n\nexport class Tone {\n    p: Program;\n    r: any[];\n    n: ReturnType<NodeDef[4]>[];\n    sc: any[] = [];\n    ac: any[] = [];\n    acL: any[] = [];\n    acR: any[] = [];\n    pitch: AutomatedValue;\n    expression: AutomatedValue;\n    mods: AutomatedValue[];\n    modToIndexMap: Record<string, number>;\n    alive = true;\n    constructor(\n        state: CompiledVoiceData,\n        public dt: number,\n        public synth: WorkletSynth,\n        pitch: number,\n        expression: number) {\n        this.p = state.p;\n        this.r = state.r.map(_ => 0);\n        this.n = state.nn.map(nn => synth.nodes.find(nd => nd[0] === nn)![4]!(synth));\n        this.pitch = new AutomatedValue(pitch, AutomatedValueMethod.EXPONENTIAL);\n        this.expression = new AutomatedValue(expression, AutomatedValueMethod.EXPONENTIAL);\n        this.mods = state.mods.map(([_, initial, mode]) => new AutomatedValue(initial, mode));\n        this.modToIndexMap = Object.fromEntries(state.mods.map((m, i) => [m[0], i]));\n    }\n    /** SCREAMING HOT CODE */\n    processSample(\n        sampleNo: number,\n        l: Float32Array,\n        r: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const stack = this.sc;\n        const args = this.ac;\n        const argsL = this.acL\n        const argsR = this.acR;\n        const prog = this.p;\n        const registers = this.r;\n        const nodes = this.n;\n        const pitch = this.pitch.value;\n        const expression = this.expression.value;\n\n        const push = (x: any) => (stack[sp] = x, sp++);\n        const pop = () => (sp--, stack[sp]);\n        const peek = () => stack[sp - 1];\n        const stereo = (a: number, b: number) => {\n            return [a, b];\n        }\n\n        var sp: number, a, b, c, i;\n        stack.length = args.length = argsL.length = argsR.length = sp = 0;\n\n        for (var pc = 0; pc < prog.length; pc++) {\n            const code = prog[pc]!;\n            const op = code[0];\n            switch (op) {\n                case Opcode.PUSH_CONSTANT:\n                    push(code[1]);\n                    break;\n                case Opcode.PUSH_INPUT_SAMPLES:\n                    push(stereo(l[sampleNo]!, r[sampleNo]!));\n                    break;\n                case Opcode.PUSH_PITCH:\n                    push(pitch);\n                    break;\n                case Opcode.PUSH_EXPRESSION:\n                    push(expression);\n                    break;\n                case Opcode.PUSH_GATE:\n                    push(gate);\n                    break;\n                case Opcode.MARK_STILL_ALIVE:\n                    this.alive = true;\n                    break;\n                case Opcode.DROP_TOP:\n                    pop();\n                    break;\n                case Opcode.PUSH_FRESH_EMPTY_LIST:\n                    push([]);\n                    break;\n                case Opcode.APPEND_TO_LIST:\n                    a = pop();\n                    peek().push(a);\n                    break;\n                case Opcode.EXTEND_TO_LIST:\n                    a = pop();\n                    peek().push(...a);\n                    break;\n                case Opcode.DO_BINARY_OP:\n                case Opcode.DO_BINARY_OP_STEREO:\n                    b = pop();\n                    a = pop();\n                    c = OPERATORS[code[1] as string]!.cb!;\n                    push(op === Opcode.DO_BINARY_OP ? c(a, b) : stereo(c(a[0], b[0]), c(a[1], b[1])));\n                    break;\n                case Opcode.DO_UNARY_OP:\n                case Opcode.DO_UNARY_OP_STEREO:\n                    a = pop();\n                    c = OPERATORS[code[1] as string]!.cu!;\n                    push(op === Opcode.DO_UNARY_OP ? c(a) : stereo(c(a[0]), c(a[1])));\n                    break;\n                case Opcode.GET_REGISTER:\n                    push(registers[code[1] as number]);\n                    break;\n                case Opcode.TAP_REGISTER:\n                    registers[code[1] as number] = peek();\n                    break;\n                case Opcode.SHIFT_REGISTER:\n                    a = registers[code[1] as number];\n                    registers[code[1] as number] = pop();\n                    push(a);\n                    break;\n                case Opcode.CONDITIONAL_SELECT:\n                    c = pop();\n                    b = pop();\n                    a = pop();\n                    push(c ? b : a);\n                    break;\n                case Opcode.STEREO_DOUBLE_WIDEN:\n                    a = pop();\n                    push(stereo(a, a));\n                    break;\n                case Opcode.APPLY_NODE:\n                    a = code[1] as number;\n                    i = args.length = code[2] as number;\n                    while (i > 0) {\n                        i--;\n                        args[i] = pop();\n                    }\n                    push(nodes[a]!(this.dt, args));\n                    break;\n                case Opcode.GET_MOD:\n                    push(this.mods[code[1] as number]?.value ?? 0);\n                    break;\n                case Opcode.APPLY_DOUBLE_NODE_STEREO:\n                    a = code[1] as number;\n                    b = code[2] as number;\n                    i = args.length = argsL.length = argsR.length = c = code[3] as number;\n                    while (i > 0) {\n                        i--;\n                        args[i] = pop();\n                    }\n                    while (i < c) {\n                        if (isArray(args[i])) {\n                            argsL[i] = args[i][0];\n                            argsR[i] = args[i][1];\n                        } else {\n                            argsL[i] = argsR[i] = args[i];\n                        }\n                        i++;\n                    }\n                    push(stereo(nodes[a]!(this.dt, argsL), nodes[b]!(this.dt, argsR)));\n                    break;\n                default:\n                    op satisfies never;\n            }\n        }\n        a = pop();\n        if (!isArray(a)) a = stereo(a, a);\n        if (isNumber(a[0]) && isNaN(a[0])) a[0] = 0;\n        if (isNumber(a[0]) && isNaN(a[1])) a[1] = 0;\n        switch (mode) {\n            case PassMode.SET:\n                l[sampleNo] = a[0] * gain;\n                r[sampleNo] = a[1] * gain;\n                break;\n            case PassMode.ADD:\n                l[sampleNo]! += a[0] * gain;\n                r[sampleNo]! += a[1] * gain;\n                break;\n        }\n    }\n    /** HOT CODE */\n    processBlock(\n        leftBuffer: Float32Array,\n        rightBuffer: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const len = leftBuffer.length;\n        var sampleNo, modNo;\n        for (sampleNo = 0; sampleNo < len; sampleNo++) {\n            for (modNo = 0; modNo < this.mods.length; modNo++) {\n                this.mods[modNo]!.update(this.dt);\n            }\n            this.processSample(sampleNo, leftBuffer, rightBuffer, mode, gate, gain);\n        }\n    }\n    automate(name: string, value: number, atTime: number) {\n        this.mods[this.modToIndexMap[name]!]?.goto(value, this.dt, atTime);\n    }\n}\n", "import { CompiledVoiceData } from \"../compiler/prog\";\nimport { WorkletSynth } from \"./synthImpl\";\nimport { PassMode, Tone } from \"./tone\";\n\nexport class Instrument {\n    liveNotes: Record<number, Tone> = {};\n    liveNoteCount = 0;\n    deadNotes: Record<number, [Tone, number]> = {};\n    fx: Tone;\n    inputs: Record<string, any> = {};\n    prevInputs: Record<string, any> = null as any;\n    lb = new Float32Array();\n    rb = new Float32Array();\n    constructor(\n        public dt: number,\n        public synth: WorkletSynth,\n        public voiceTemplate: CompiledVoiceData,\n        fxDef: CompiledVoiceData\n    ) {\n        this.fx = new Tone(fxDef, dt, synth, 1, 1);\n    }\n    noteOn(id: number, pitch: number, expression: number) {\n        if (this.liveNotes[id]) this.noteOff(id);\n        this.liveNotes[id] = new Tone(this.voiceTemplate, this.dt, this.synth, pitch, expression);\n        this.liveNoteCount++;\n    }\n    noteOff(id: number) {\n        const note = this.liveNotes[id];\n        if (!note) return;\n        this.deadNotes[id] = [note, gainForChord(this.liveNoteCount)];\n        delete this.liveNotes[id];\n        this.liveNoteCount--;\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this.liveNotes[id]?.pitch.goto(pitch, this.dt, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this.liveNotes[id]?.expression.goto(expression, this.dt, time);\n    }\n    automate(param: string, value: any, time: number, note?: number) {\n        if (note !== undefined) this.liveNotes[note]!.automate(param, value, time);\n        else {\n            for (var k of Object.keys(this.liveNotes)) this.liveNotes[+k]!.automate(param, value, time);\n            this.fx.automate(value, this.dt, time);\n        }\n    }\n    /** HOT CODE */\n    process(left: Float32Array, right: Float32Array) {\n        var lb = this.lb, rb = this.rb, len = left.length;\n        if (lb.buffer.byteLength < left.buffer.byteLength) {\n            this.lb = lb = new Float32Array(len);\n            this.rb = rb = new Float32Array(len);\n        } else if (lb.length !== len) {\n            this.lb = lb = new Float32Array(lb.buffer, 0, len);\n            this.rb = rb = new Float32Array(rb.buffer, 0, len);\n        }\n        var i: any;\n        const liveNoteCount = this.liveNoteCount, liveNotes = this.liveNotes, deadNotes = this.deadNotes\n        for (i in liveNotes) {\n            liveNotes[i]!.processBlock(lb, rb, PassMode.ADD, true, gainForChord(liveNoteCount));\n        }\n        for (i in deadNotes) {\n            var tone = deadNotes[i]![0];\n            var gain = deadNotes[i]![1];\n            tone.alive = false;\n            tone.processBlock(lb, rb, PassMode.ADD, false, gain);\n            if (!tone.alive) {\n                delete deadNotes[i];\n            }\n        }\n        this.fx.processBlock(lb, rb, PassMode.SET, true, 1);\n        for (i = 0; i < len; i++) {\n            left[i]! += lb[i]!;\n            right[i]! += rb[i]!;\n        }\n    }\n}\n\nfunction gainForChord(chordSize: number) {\n    return 1 / ((chordSize - 1) / 4 + 1);\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { CompiledVoiceData } from \"../compiler/prog\";\nimport { nodes, passthroughFx } from \"../lib\";\nimport { Instrument } from \"./instrument\";\nimport { PassMode, Tone } from \"./tone\";\n\n\nexport class WorkletSynth {\n    instruments: Instrument[] = [];\n    postFX: Tone = null as any;\n    n2i: Record<number, number> = {};\n    waves: Record<string, Float32Array> = {};\n    nodes: NodeDef[] = nodes();\n    volume: number = 0.8;\n    constructor(public dt: number) {\n        this.clearAll();\n    }\n    clearAll() {\n        this.instruments = [];\n        this.postFX = new Tone(passthroughFx(), this.dt, this, 0, 1);\n    }\n    addWave(name: string, wave: Float32Array) {\n        this.waves[name] = wave;\n    }\n    addInstrument(voiceDef: CompiledVoiceData, fxDef: CompiledVoiceData): number {\n        return this.instruments.push(new Instrument(this.dt, this, voiceDef, fxDef)) - 1;\n    }\n    setPostFX(fxDef: CompiledVoiceData): void {\n        this.postFX = new Tone(fxDef, this.dt, this, 1, 1);\n    }\n    setVolume(volume: number) {\n        this.volume = volume;\n    }\n    getInstrumentCount() {\n        return this.instruments.length;\n    }\n    private _ifn(noteID: number) {\n        return this.instruments[this.n2i[noteID]!];\n    }\n    noteOn(id: number, instrument: number, pitch: number, expression: number) {\n        this._ifn(id)?.noteOff(id);\n        this.instruments[this.n2i[id] = instrument]?.noteOn(id, pitch, expression);\n    }\n    noteOff(id: number) {\n        this._ifn(id)?.noteOff(id);\n        delete this.n2i[id];\n    }\n    automate(instrument: number | undefined, param: string, value: any, time: number) {\n        (this.instruments[instrument as any] ?? this.postFX).automate(param, value, time);\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this._ifn(id)?.pitchBend(id, pitch, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this._ifn(id)?.expressionBend(id, expression, time);\n    }\n    /** HOT CODE */\n    private process(left: Float32Array, right: Float32Array) {\n        const instruments = this.instruments;\n        for (var i = 0; i < instruments.length; i++) {\n            instruments[i]!.process(left, right);\n        }\n        this.postFX?.processBlock(left, right, PassMode.SET, true, this.volume);\n    }\n}\n", "import { WorkletSynth } from \"../runtime/synthImpl\";\nimport { Message, MessageReply } from \"../runtime/synthProxy\";\n\nexport class SydWorklet extends AudioWorkletProcessor {\n    synth: WorkletSynth = new WorkletSynth(1 / sampleRate);\n    constructor() {\n        super();\n        this.port.onmessage = e => this.handleMessage(e.data as Message);\n        console.log(\"[audio worklet thread] setup message handler\");\n    }\n    async handleMessage(m: Message) {\n        try {\n            console.log(\"[audio worklet thread] received message\", m);\n            const result = await (this.synth as any)[m.method](...m.args);\n            this.port.postMessage({ id: m.id, result, failed: false } as MessageReply);\n        } catch (e) {\n            this.port.postMessage({ id: m.id, result: e as Error, failed: true } as MessageReply);\n        }\n    }\n    process(input: Float32Array[][], out: Float32Array[][]) {\n        if (out.length > 0)\n            (this.synth as any)?.process(out[0]![0]!, out[0]![1]!);\n        return true;\n    }\n}\n", "import { SydWorklet } from \"./worklet\";\nregisterProcessor(\"syd\", SydWorklet);\n"],
  "mappings": "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",
  "names": ["nodes", "a", "b"]
}
