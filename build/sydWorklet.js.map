{
  "version": 3,
  "sources": ["../src/runtime/automation.ts", "../src/runtime/tone.ts", "../src/runtime/instrument.ts", "../src/runtime/synth.ts", "../src/worklet/worklet.ts", "../src/sydWorklet.ts"],
  "sourcesContent": ["import { max, min } from \"../math\";\n\nexport enum AutomatedValueMethod {\n    LINEAR,\n    EXPONENTIAL,\n    STEP\n}\n\nexport class AutomatedValue {\n    delta: number = 0;\n    value: number = 0;\n    target: number = 0;\n    timeLeft: number = 0;\n    constructor(\n        initial: number,\n        public mode: AutomatedValueMethod,\n    ) {\n        this.value = initial;\n    }\n    goto(newValue: number, dt: number, time: number) {\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: this.delta = dt * (newValue - this.value) / time; break;\n            case AutomatedValueMethod.EXPONENTIAL:\n                if ((this.value * newValue) <= 0) {\n                    throw new Error(\"cannot cross 0 when in exponential mode\");\n                }\n                this.delta = Math.pow(newValue / this.value, dt / time);\n        }\n        this.target = newValue;\n        this.timeLeft = time;\n    }\n    /** HOT CODE */\n    update(dt: number) {\n        this.timeLeft -= dt;\n        if (this.timeLeft < 0) {\n            this.timeLeft = 0;\n            return this.value = this.target;\n        }\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: return this.value += this.delta;\n            case AutomatedValueMethod.EXPONENTIAL: return this.value *= this.delta;\n        }\n    }\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { OPERATORS } from \"../compiler/operator\";\nimport { CompileState, Opcode, Program } from \"../compiler/prog\";\nimport { isArray, isNumber } from \"../utils\";\nimport { AutomatedValue, AutomatedValueMethod } from \"./automation\";\nimport { Synth } from \"./synth\";\n\nexport enum PassMode {\n    SET,\n    ADD,\n}\n\nexport class Tone {\n    p: Program;\n    r: any[];\n    n: ReturnType<NodeDef[4]>[];\n    sc: any[] = [];\n    ac: any[] = [];\n    acL: any[] = [];\n    acR: any[] = [];\n    tmp: [number, number] = null as any;\n    pitch: AutomatedValue;\n    expression: AutomatedValue;\n    mods: AutomatedValue[];\n    modToIndexMap: Record<string, number>;\n    alive = true;\n    constructor(\n        state: CompileState,\n        public dt: number,\n        public synth: Synth,\n        pitch: number,\n        expression: number) {\n        this.p = state.p;\n        this.r = state.r.map(_ => 0);\n        this.n = state.nn.map(nn => synth.nodes.find(nd => nd[0] === nn)![4]!(synth));\n        this.pitch = new AutomatedValue(pitch, AutomatedValueMethod.EXPONENTIAL);\n        this.expression = new AutomatedValue(expression, AutomatedValueMethod.EXPONENTIAL);\n        this.mods = state.mods.map(([_, initial, mode]) => new AutomatedValue(initial, mode));\n        this.modToIndexMap = Object.fromEntries(state.mods.map((m, i) => [m[0], i]));\n        if (state.tosStereo) {\n            this.p.push(Opcode.STEREO_DOUBLE_WIDEN);\n        }\n    }\n    /** SCREAMING HOT CODE */\n    processSample(\n        sampleNo: number,\n        l: Float32Array,\n        r: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const stack = this.sc;\n        const args = this.sc;\n        const argsL = this.acL\n        const argsR = this.acR;\n        const prog = this.p;\n        const registers = this.r;\n        const nodes = this.n;\n        const tmp = this.tmp;\n        const pitch = this.pitch.value;\n        const expression = this.expression.value;\n\n        const push = (x: any) => stack[sp++] = x;\n        const pop = () => stack[sp--];\n        const peek = () => stack[sp];\n        const next = () => prog[pc++] as number;\n\n        var pc: number, sp: number, a, b, c, i;\n        stack.length = args.length = argsL.length = argsR.length = pc = sp = 0;\n\n        while (pc < prog.length) {\n            const code = next() as Opcode;\n            switch (code) {\n                case Opcode.PUSH_CONSTANT:\n                    push(next());\n                    break;\n                case Opcode.PUSH_INPUT_SAMPLES:\n                    tmp.length = 2;\n                    tmp[0] = l[sampleNo]!;\n                    tmp[1] = r[sampleNo]!;\n                    push(tmp);\n                    break;\n                case Opcode.PUSH_PITCH:\n                    push(pitch);\n                    break;\n                case Opcode.PUSH_EXPRESSION:\n                    push(expression);\n                    break;\n                case Opcode.PUSH_GATE:\n                    push(gate);\n                    break;\n                case Opcode.MARK_STILL_ALIVE:\n                    this.alive = true;\n                    break;\n                case Opcode.DROP_TOP:\n                    pop();\n                    break;\n                case Opcode.PUSH_FRESH_EMPTY_LIST:\n                    push([]);\n                    break;\n                case Opcode.APPEND_TO_LIST:\n                    a = pop();\n                    peek().push(a);\n                    break;\n                case Opcode.EXTEND_TO_LIST:\n                    a = pop();\n                    peek().push(...a);\n                    break;\n                case Opcode.DO_BINARY_OP:\n                    b = pop();\n                    a = pop();\n                    push(OPERATORS[next()]!.cb!(a, b));\n                    break;\n                case Opcode.DO_UNARY_OP:\n                    a = pop();\n                    push(OPERATORS[next()]!.cu!(a));\n                    break;\n                case Opcode.GET_REGISTER:\n                    push(registers[next()]);\n                    break;\n                case Opcode.TAP_REGISTER:\n                    registers[next()] = peek();\n                    break;\n                case Opcode.CONDITIONAL_SELECT:\n                    c = pop();\n                    b = pop();\n                    a = pop();\n                    push(c ? b : a);\n                    break;\n                case Opcode.STEREO_DOUBLE_WIDEN:\n                    a = pop();\n                    push([a, a]);\n                    break;\n                case Opcode.APPLY_NODE:\n                    a = pop();\n                    c = pop();\n                    args.length = c;\n                    i = 0;\n                    while (i < c) args[i++] = pop();\n                    push(nodes[a]!(this.dt, args));\n                    break;\n                case Opcode.GET_MOD:\n                    push(this.mods[next()]?.value ?? 0);\n                    break;\n                case Opcode.APPLY_DOUBLE_NODE_STEREO:\n                    a = pop();\n                    b = pop();\n                    c = pop();\n                    argsL.length = argsR.length = c;\n                    i = 0;\n                    while (i < c) args[i++] = pop();\n                    i = 0;\n                    while (i < c) {\n                        if (isArray(args[i])) {\n                            argsL[i] = args[i][0];\n                            argsR[i] = args[i][1];\n                        } else {\n                            argsL[i] = argsR[i] = args[i];\n                        }\n                        i++;\n                    }\n                    push([nodes[a]!(this.dt, argsL), nodes[b]!(this.dt, argsR)]);\n                    break;\n                default:\n                    code satisfies never;\n            }\n        }\n        a = pop();\n        if (isNumber(a[0]) && isNaN(a[0])) a[0] = 0;\n        if (isNumber(a[0]) && isNaN(a[1])) a[1] = 0;\n        switch (mode) {\n            case PassMode.SET:\n                l[sampleNo] = a[0] * gain;\n                r[sampleNo] = a[1] * gain;\n                break;\n            case PassMode.ADD:\n                l[sampleNo]! += a[0] * gain;\n                r[sampleNo]! += a[1] * gain;\n                break;\n        }\n    }\n    /** HOT CODE */\n    processBlock(\n        leftBuffer: Float32Array,\n        rightBuffer: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const len = leftBuffer.length;\n        var sampleNo, modNo;\n        for (sampleNo = 0; sampleNo < len; sampleNo++) {\n            for (modNo = 0; modNo < this.mods.length; modNo++) {\n                this.mods[modNo]!.update(this.dt);\n            }\n            this.processSample(sampleNo, leftBuffer, rightBuffer, mode, gate, gain);\n        }\n    }\n    automate(name: string, value: number, atTime: number) {\n        this.mods[this.modToIndexMap[name]!]?.goto(value, this.dt, atTime);\n    }\n}\n", "import { CompileState } from \"../compiler/prog\";\nimport { Synth } from \"./synth\";\nimport { PassMode, Tone } from \"./tone\";\n\nexport class Instrument {\n    liveNotes: Record<number, Tone> = {};\n    liveNoteCount = 0;\n    deadNotes: Record<number, [Tone, number]> = {};\n    fx: Tone;\n    inputs: Record<string, any> = {};\n    prevInputs: Record<string, any> = null as any;\n    lb = new Float32Array();\n    rb = new Float32Array();\n    constructor(\n        public dt: number,\n        public synth: Synth,\n        public voiceTemplate: CompileState,\n        fxDef: CompileState\n    ) {\n        this.fx = new Tone(fxDef, dt, synth, 1, 1);\n    }\n    noteOn(id: number, pitch: number, expression: number) {\n        if (this.liveNotes[id]) this.noteOff(id);\n        this.liveNotes[id] = new Tone(this.voiceTemplate, this.dt, this.synth, pitch, expression);\n        this.liveNoteCount++;\n    }\n    noteOff(id: number) {\n        const note = this.liveNotes[id];\n        if (!note) return;\n        this.deadNotes[id] = [note, gainForChord(this.liveNoteCount)];\n        delete this.liveNotes[id];\n        this.liveNoteCount--;\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this.liveNotes[id]?.pitch.goto(pitch, this.dt, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this.liveNotes[id]?.expression.goto(expression, this.dt, time);\n    }\n    automate(param: string, value: any, time: number, note?: number) {\n        if (note !== undefined) this.liveNotes[note]!.automate(param, value, time);\n        else {\n            for (var k of Object.keys(this.liveNotes)) this.liveNotes[+k]!.automate(param, value, time);\n            this.fx.automate(value, this.dt, time);\n        }\n    }\n    /** HOT CODE */\n    process(left: Float32Array, right: Float32Array) {\n        var lb = this.lb, rb = this.rb, len = left.length;\n        if (lb.buffer.byteLength < left.buffer.byteLength) {\n            this.lb = lb = new Float32Array(len);\n            this.rb = rb = new Float32Array(len);\n        } else if (lb.length !== len) {\n            this.lb = lb = new Float32Array(lb.buffer, 0, len);\n            this.rb = rb = new Float32Array(rb.buffer, 0, len);\n        }\n        var i: any;\n        const liveNoteCount = this.liveNoteCount, liveNotes = this.liveNotes, deadNotes = this.deadNotes\n        for (i in liveNotes) {\n            liveNotes[i]!.processBlock(lb, rb, PassMode.ADD, true, gainForChord(liveNoteCount));\n        }\n        for (i in deadNotes) {\n            var tone = deadNotes[i]![0];\n            var gain = deadNotes[i]![1];\n            tone.alive = false;\n            tone.processBlock(lb, rb, PassMode.ADD, false, gain);\n            if (!tone.alive) {\n                delete deadNotes[i];\n            }\n        }\n        this.fx.processBlock(lb, rb, PassMode.SET, true, 1);\n        for (i = 0; i < len; i++) {\n            left[i]! += lb[i]!;\n            right[i]! += rb[i]!;\n        }\n    }\n}\n\nfunction gainForChord(chordSize: number) {\n    return 1 / ((chordSize - 1) / 4 + 1);\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { CompileState } from \"../compiler/prog\";\nimport { Instrument } from \"./instrument\";\nimport { Tone } from \"./tone\";\n\nexport class Synth {\n    instruments: Instrument[] = [];\n    postFX: Tone;\n    n2i: Record<number, number> = {};\n    waves: Record<string, Float32Array> = {};\n    constructor(\n        public dt: number,\n        public nodes: NodeDef[],\n        instruments: [CompileState, CompileState][],\n        postFX: CompileState,\n    ) {\n        for (var [tt, fxt] of instruments) {\n            this.instruments.push(new Instrument(dt, this, tt, fxt));\n        }\n        this.postFX = new Tone(postFX, dt, this, 1, 0.3);\n    }\n    addWave(name: string, wave: Float32Array) {\n        this.waves[name] = wave;\n    }\n    private _ifn(noteID: number) {\n        return this.instruments[this.n2i[noteID]!];\n    }\n    noteOn(id: number, instrument: number, pitch: number, expression: number) {\n        this._ifn(id)?.noteOff(id);\n        this.instruments[this.n2i[id] = instrument]?.noteOn(id, pitch, expression);\n    }\n    noteOff(id: number) {\n        this._ifn(id)?.noteOff(id);\n        delete this.n2i[id];\n    }\n    automate(instrument: number | undefined, param: string, value: any, time: number) {\n        (this.instruments[instrument as any] ?? this.postFX).automate(param, value, time);\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this._ifn(id)?.pitchBend(id, pitch, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this._ifn(id)?.expressionBend(id, expression, time);\n    }\n    /** HOT CODE */\n    process(left: Float32Array, right: Float32Array) {\n        const instruments = this.instruments;\n        for (var i = 0; i < instruments.length; i++) {\n            instruments[i]!.process(left, right);\n        }\n    }\n}\n", "import { Message, MessageCode } from \".\";\nimport { nodes } from \"../lib\";\nimport { Synth } from \"../runtime/synth\";\n\nexport class SydWorklet extends AudioWorkletProcessor {\n    s: Synth | null = null;\n    dt: number;\n    constructor(sampleRate?: number) {\n        super();\n        this.dt = 1 / (sampleRate ?? globalThis.sampleRate);\n        this.port.addEventListener(\"message\", e => this.processMessage(e.data as Message));\n    }\n    processMessage(m: Message) {\n        switch (m[0]) {\n            case MessageCode.SETUP_SYNTH:\n                this.s = new Synth(this.dt, nodes(), m[1], m[2]);\n                return;\n        }\n        const s = this.s!;\n        switch (m[0]) {\n            case MessageCode.ADD_WAVETABLE:\n                s.addWave(m[1], m[2]);\n                break;\n            case MessageCode.NOTE_ON:\n                s.noteOn(m[1], m[2], m[3], m[4]);\n                break;\n            case MessageCode.NOTE_OFF:\n                s.noteOff(m[1]);\n                break;\n            case MessageCode.AUTOMATE:\n                s.automate(m[1], m[2], m[3], m[4]);\n                break;\n            case MessageCode.PITCH_BEND:\n                if (m[1]) s.pitchBend(m[2], m[3], m[4]);\n                else s.postFX.pitch.goto(m[2], m[3], m[4]);\n                break;\n            case MessageCode.EXPRESSION:\n                if (m[1]) s.expressionBend(m[2], m[3], m[4]);\n                else s.postFX.expression.goto(m[2], m[3], m[4]);\n                break;\n            default:\n                m[0] satisfies never;\n        }\n    }\n    process(input: Float32Array[][], out: Float32Array[][]) {\n        if (out.length > 0)\n            this.s!.process(out[0]![0]!, out[0]![1]!);\n        return true;\n    }\n}\n", "import { SydWorklet } from \"./worklet/worklet\";\nregisterProcessor(\"syd\", SydWorklet);\n"],
  "mappings": "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",
  "names": ["nodes", "nodes"]
}
