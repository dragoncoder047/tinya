{
  "version": 3,
  "sources": ["../src/runtime/automation.ts", "../src/runtime/tone.ts", "../src/runtime/instrument.ts", "../src/runtime/synth.ts", "../src/worklet/worklet.ts", "../src/sydWorklet.ts"],
  "sourcesContent": ["import { max, min } from \"../math\";\n\nexport enum AutomatedValueMethod {\n    LINEAR,\n    EXPONENTIAL,\n    STEP\n}\n\nexport class AutomatedValue {\n    delta: number = 0;\n    value: number = 0;\n    target: number = 0;\n    timeLeft: number = 0;\n    constructor(\n        initial: number,\n        public mode: AutomatedValueMethod,\n    ) {\n        this.value = initial;\n    }\n    goto(newValue: number, dt: number, time: number) {\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: this.delta = dt * (newValue - this.value) / time; break;\n            case AutomatedValueMethod.EXPONENTIAL:\n                if ((this.value * newValue) <= 0) {\n                    throw new Error(\"cannot cross 0 when in exponential mode\");\n                }\n                this.delta = Math.pow(newValue / this.value, dt / time);\n        }\n        this.target = newValue;\n        this.timeLeft = time;\n    }\n    /** HOT CODE */\n    update(dt: number) {\n        this.timeLeft -= dt;\n        if (this.timeLeft < 0) {\n            this.timeLeft = 0;\n            return this.value = this.target;\n        }\n        switch (this.mode) {\n            case AutomatedValueMethod.LINEAR: return this.value += this.delta;\n            case AutomatedValueMethod.EXPONENTIAL: return this.value *= this.delta;\n        }\n    }\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { OPERATORS } from \"../compiler/operator\";\nimport { CompileState, Opcode, Program } from \"../compiler/prog\";\nimport { isArray, isNumber } from \"../utils\";\nimport { AutomatedValue, AutomatedValueMethod } from \"./automation\";\nimport { Synth } from \"./synth\";\n\nexport enum PassMode {\n    SET,\n    ADD,\n}\n\nexport class Tone {\n    p: Program;\n    r: any[];\n    n: ReturnType<NodeDef[4]>[];\n    sc: any[] = [];\n    ac: any[] = [];\n    acL: any[] = [];\n    acR: any[] = [];\n    tmp: [number, number] = null as any;\n    pitch: AutomatedValue;\n    expression: AutomatedValue;\n    mods: AutomatedValue[];\n    modToIndexMap: Record<string, number>;\n    alive = true;\n    constructor(\n        state: CompileState,\n        public dt: number,\n        public synth: Synth,\n        pitch: number,\n        expression: number) {\n        this.p = state.p;\n        this.r = state.r.map(_ => 0);\n        this.n = state.nn.map(nn => synth.nodes.find(nd => nd[0] === nn)![4]!(synth));\n        this.pitch = new AutomatedValue(pitch, AutomatedValueMethod.EXPONENTIAL);\n        this.expression = new AutomatedValue(expression, AutomatedValueMethod.EXPONENTIAL);\n        this.mods = state.mods.map(([_, initial, mode]) => new AutomatedValue(initial, mode));\n        this.modToIndexMap = Object.fromEntries(state.mods.map((m, i) => [m[0], i]));\n        if (state.tosStereo) {\n            this.p.push(Opcode.STEREO_DOUBLE_WIDEN);\n        }\n    }\n    /** SCREAMING HOT CODE */\n    processSample(\n        sampleNo: number,\n        l: Float32Array,\n        r: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const stack = this.sc;\n        const args = this.sc;\n        const argsL = this.acL\n        const argsR = this.acR;\n        const prog = this.p;\n        const registers = this.r;\n        const nodes = this.n;\n        const tmp = this.tmp;\n        const pitch = this.pitch.value;\n        const expression = this.expression.value;\n\n        const push = (x: any) => stack[sp++] = x;\n        const pop = () => stack[sp--];\n        const peek = () => stack[sp];\n        const next = () => prog[pc++] as number;\n\n        var pc: number, sp: number, a, b, c, i;\n        stack.length = args.length = argsL.length = argsR.length = pc = sp = 0;\n\n        while (pc < prog.length) {\n            const code = next() as Opcode;\n            switch (code) {\n                case Opcode.PUSH_CONSTANT:\n                    push(next());\n                    break;\n                case Opcode.PUSH_INPUT_SAMPLES:\n                    tmp.length = 2;\n                    tmp[0] = l[sampleNo]!;\n                    tmp[1] = r[sampleNo]!;\n                    push(tmp);\n                    break;\n                case Opcode.PUSH_PITCH:\n                    push(pitch);\n                    break;\n                case Opcode.PUSH_EXPRESSION:\n                    push(expression);\n                    break;\n                case Opcode.PUSH_GATE:\n                    push(gate);\n                    break;\n                case Opcode.MARK_STILL_ALIVE:\n                    this.alive = true;\n                    break;\n                case Opcode.DROP_TOP:\n                    pop();\n                    break;\n                case Opcode.PUSH_FRESH_EMPTY_LIST:\n                    push([]);\n                    break;\n                case Opcode.APPEND_TO_LIST:\n                    a = pop();\n                    peek().push(a);\n                    break;\n                case Opcode.EXTEND_TO_LIST:\n                    a = pop();\n                    peek().push(...a);\n                    break;\n                case Opcode.DO_BINARY_OP:\n                    b = pop();\n                    a = pop();\n                    push(OPERATORS[next()]!.cb!(a, b));\n                    break;\n                case Opcode.DO_UNARY_OP:\n                    a = pop();\n                    push(OPERATORS[next()]!.cu!(a));\n                    break;\n                case Opcode.GET_REGISTER:\n                    push(registers[next()]);\n                    break;\n                case Opcode.TAP_REGISTER:\n                    registers[next()] = peek();\n                    break;\n                case Opcode.CONDITIONAL_SELECT:\n                    c = pop();\n                    b = pop();\n                    a = pop();\n                    push(c ? b : a);\n                    break;\n                case Opcode.STEREO_DOUBLE_WIDEN:\n                    a = pop();\n                    push([a, a]);\n                    break;\n                case Opcode.APPLY_NODE:\n                    a = pop();\n                    c = pop();\n                    args.length = c;\n                    i = 0;\n                    while (i < c) args[i++] = pop();\n                    push(nodes[a]!(this.dt, args));\n                    break;\n                case Opcode.GET_MOD:\n                    push(this.mods[next()]?.value ?? 0);\n                    break;\n                case Opcode.APPLY_DOUBLE_NODE_STEREO:\n                    a = pop();\n                    b = pop();\n                    c = pop();\n                    argsL.length = argsR.length = c;\n                    i = 0;\n                    while (i < c) args[i++] = pop();\n                    i = 0;\n                    while (i < c) {\n                        if (isArray(args[i])) {\n                            argsL[i] = args[i][0];\n                            argsR[i] = args[i][1];\n                        } else {\n                            argsL[i] = argsR[i] = args[i];\n                        }\n                        i++;\n                    }\n                    push([nodes[a]!(this.dt, argsL), nodes[b]!(this.dt, argsR)]);\n                    break;\n                default:\n                    code satisfies never;\n            }\n        }\n        a = pop();\n        if (isNumber(a[0]) && isNaN(a[0])) a[0] = 0;\n        if (isNumber(a[0]) && isNaN(a[1])) a[1] = 0;\n        switch (mode) {\n            case PassMode.SET:\n                l[sampleNo] = a[0] * gain;\n                r[sampleNo] = a[1] * gain;\n                break;\n            case PassMode.ADD:\n                l[sampleNo]! += a[0] * gain;\n                r[sampleNo]! += a[1] * gain;\n                break;\n        }\n    }\n    /** HOT CODE */\n    processBlock(\n        leftBuffer: Float32Array,\n        rightBuffer: Float32Array,\n        mode: PassMode,\n        gate: boolean,\n        gain: number) {\n        const len = leftBuffer.length;\n        var sampleNo, modNo;\n        for (sampleNo = 0; sampleNo < len; sampleNo++) {\n            for (modNo = 0; modNo < this.mods.length; modNo++) {\n                this.mods[modNo]!.update(this.dt);\n            }\n            this.processSample(sampleNo, leftBuffer, rightBuffer, mode, gate, gain);\n        }\n    }\n    automate(name: string, value: number, atTime: number) {\n        this.mods[this.modToIndexMap[name]!]?.goto(value, this.dt, atTime);\n    }\n}\n", "import { CompileState } from \"../compiler/prog\";\nimport { Synth } from \"./synth\";\nimport { PassMode, Tone } from \"./tone\";\n\nexport class Instrument {\n    liveNotes: Record<number, Tone> = {};\n    liveNoteCount = 0;\n    deadNotes: Record<number, [Tone, number]> = {};\n    fx: Tone;\n    inputs: Record<string, any> = {};\n    prevInputs: Record<string, any> = null as any;\n    lb = new Float32Array();\n    rb = new Float32Array();\n    constructor(\n        public dt: number,\n        public synth: Synth,\n        public voiceTemplate: CompileState,\n        fxDef: CompileState\n    ) {\n        this.fx = new Tone(fxDef, dt, synth, 1, 1);\n    }\n    noteOn(id: number, pitch: number, expression: number) {\n        if (this.liveNotes[id]) this.noteOff(id);\n        this.liveNotes[id] = new Tone(this.voiceTemplate, this.dt, this.synth, pitch, expression);\n        this.liveNoteCount++;\n    }\n    noteOff(id: number) {\n        const note = this.liveNotes[id];\n        if (!note) return;\n        this.deadNotes[id] = [note, gainForChord(this.liveNoteCount)];\n        delete this.liveNotes[id];\n        this.liveNoteCount--;\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this.liveNotes[id]?.pitch.goto(pitch, this.dt, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this.liveNotes[id]?.expression.goto(expression, this.dt, time);\n    }\n    automate(param: string, value: any, time: number, note?: number) {\n        if (note !== undefined) this.liveNotes[note]!.automate(param, value, time);\n        else {\n            for (var k of Object.keys(this.liveNotes)) this.liveNotes[+k]!.automate(param, value, time);\n            this.fx.automate(value, this.dt, time);\n        }\n    }\n    /** HOT CODE */\n    process(left: Float32Array, right: Float32Array) {\n        var lb = this.lb, rb = this.rb, len = left.length;\n        if (lb.buffer.byteLength < left.buffer.byteLength) {\n            this.lb = lb = new Float32Array(len);\n            this.rb = rb = new Float32Array(len);\n        } else if (lb.length !== len) {\n            this.lb = lb = new Float32Array(lb.buffer, 0, len);\n            this.rb = rb = new Float32Array(rb.buffer, 0, len);\n        }\n        var i: any;\n        const liveNoteCount = this.liveNoteCount, liveNotes = this.liveNotes, deadNotes = this.deadNotes\n        for (i in liveNotes) {\n            liveNotes[i]!.processBlock(lb, rb, PassMode.ADD, true, gainForChord(liveNoteCount));\n        }\n        for (i in deadNotes) {\n            var tone = deadNotes[i]![0];\n            var gain = deadNotes[i]![1];\n            tone.alive = false;\n            tone.processBlock(lb, rb, PassMode.ADD, false, gain);\n            if (!tone.alive) {\n                delete deadNotes[i];\n            }\n        }\n        this.fx.processBlock(lb, rb, PassMode.SET, true, 1);\n        for (i = 0; i < len; i++) {\n            left[i]! += lb[i]!;\n            right[i]! += rb[i]!;\n        }\n    }\n}\n\nfunction gainForChord(chordSize: number) {\n    return 1 / ((chordSize - 1) / 4 + 1);\n}\n", "import { NodeDef } from \"../compiler/evalState\";\nimport { CompileState } from \"../compiler/prog\";\nimport { Instrument } from \"./instrument\";\nimport { Tone } from \"./tone\";\n\nexport class Synth {\n    instruments: Instrument[] = [];\n    postFX: Tone;\n    n2i: Record<number, number> = {};\n    waves: Record<string, Float32Array> = {};\n    constructor(\n        public dt: number,\n        public nodes: NodeDef[],\n        instruments: [CompileState, CompileState][],\n        postFX: CompileState,\n    ) {\n        for (var [tt, fxt] of instruments) {\n            this.instruments.push(new Instrument(dt, this, tt, fxt));\n        }\n        this.postFX = new Tone(postFX, dt, this, 1, 0.3);\n    }\n    addWave(name: string, wave: Float32Array) {\n        this.waves[name] = wave;\n    }\n    private _ifn(noteID: number) {\n        return this.instruments[this.n2i[noteID]!];\n    }\n    noteOn(id: number, instrument: number, pitch: number, expression: number) {\n        this._ifn(id)?.noteOff(id);\n        this.instruments[this.n2i[id] = instrument]?.noteOn(id, pitch, expression);\n    }\n    noteOff(id: number) {\n        this._ifn(id)?.noteOff(id);\n        delete this.n2i[id];\n    }\n    automate(instrument: number | undefined, param: string, value: any, time: number) {\n        (this.instruments[instrument as any] ?? this.postFX).automate(param, value, time);\n    }\n    pitchBend(id: number, pitch: number, time: number) {\n        this._ifn(id)?.pitchBend(id, pitch, time);\n    }\n    expressionBend(id: number, expression: number, time: number) {\n        this._ifn(id)?.expressionBend(id, expression, time);\n    }\n    /** HOT CODE */\n    process(left: Float32Array, right: Float32Array) {\n        const instruments = this.instruments;\n        for (var i = 0; i < instruments.length; i++) {\n            instruments[i]!.process(left, right);\n        }\n    }\n}\n", "import { Message, MessageCode } from \".\";\nimport { nodes } from \"../lib\";\nimport { Synth } from \"../runtime/synth\";\n\nexport class SydWorklet extends AudioWorkletProcessor {\n    s: Synth | null = null;\n    dt: number;\n    constructor(sampleRate?: number) {\n        super();\n        this.dt = 1 / (sampleRate ?? globalThis.sampleRate);\n        this.port.addEventListener(\"message\", e => this.processMessage(e.data as Message));\n    }\n    processMessage(m: Message) {\n        switch (m[0]) {\n            case MessageCode.SETUP_SYNTH:\n                this.s = new Synth(this.dt, nodes(), m[1], m[2]);\n                return;\n        }\n        const s = this.s!;\n        switch (m[0]) {\n            case MessageCode.ADD_WAVETABLE:\n                s.addWave(m[1], m[2]);\n                break;\n            case MessageCode.NOTE_ON:\n                s.noteOn(m[1], m[2], m[3], m[4]);\n                break;\n            case MessageCode.NOTE_OFF:\n                s.noteOff(m[1]);\n                break;\n            case MessageCode.AUTOMATE:\n                s.automate(m[1], m[2], m[3], m[4]);\n                break;\n            case MessageCode.PITCH_BEND:\n                if (m[1]) s.pitchBend(m[2], m[3], m[4]);\n                else s.postFX.pitch.goto(m[2], m[3], m[4]);\n                break;\n            case MessageCode.EXPRESSION:\n                if (m[1]) s.expressionBend(m[2], m[3], m[4]);\n                else s.postFX.expression.goto(m[2], m[3], m[4]);\n                break;\n            default:\n                m[0] satisfies never;\n        }\n    }\n    process(input: Float32Array[][], out: Float32Array[][]) {\n        if (out.length > 0)\n            this.s!.process(out[0]![0]!, out[0]![1]!);\n        return true;\n    }\n}\n", "import { SydWorklet } from \"./worklet/worklet\";\nregisterProcessor(\"syd\", SydWorklet);\n"],
  "mappings": "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",
  "names": ["AutomatedValue", "initial", "mode", "__name", "newValue", "dt", "time", "Tone", "state", "dt", "synth", "pitch", "expression", "_", "nn", "nd", "AutomatedValue", "initial", "mode", "m", "i", "__name", "sampleNo", "l", "r", "gate", "gain", "stack", "args", "argsL", "argsR", "prog", "registers", "nodes", "tmp", "push", "x", "sp", "pop", "peek", "next", "pc", "a", "b", "c", "code", "OPERATORS", "isArray", "isNumber", "leftBuffer", "rightBuffer", "len", "modNo", "name", "value", "atTime", "Instrument", "dt", "synth", "voiceTemplate", "fxDef", "Tone", "__name", "id", "pitch", "expression", "note", "gainForChord", "time", "param", "value", "k", "left", "right", "lb", "rb", "len", "i", "liveNoteCount", "liveNotes", "deadNotes", "tone", "gain", "chordSize", "Synth", "dt", "nodes", "instruments", "postFX", "tt", "fxt", "Instrument", "Tone", "__name", "name", "wave", "noteID", "id", "instrument", "pitch", "expression", "param", "value", "time", "left", "right", "i", "SydWorklet", "__name", "sampleRate", "e", "m", "Synth", "nodes", "s", "input", "out", "SydWorklet"]
}
