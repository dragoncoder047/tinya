{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/instrument.ts", "../src/macro.ts", "../src/effectMacros.ts", "../src/channel.ts", "../src/math.ts", "../src/nodeImpl.ts", "../src/json.ts", "../src/play.ts", "../src/zzfx.ts"],
  "sourcesContent": ["import type { NodeName, NodeTree } from \"./types\";\n\nexport const mapObject = <T, U>(obj: Record<string, T>, func: (value: T, key: string) => U): Record<string, U> =>\n    Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, func(value, key)]));\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\nexport const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\nexport const isString = is(\"string\") as (x: any) => x is string;\nexport const isNull = (x: any): x is null => x === null;\nexport const isEmpty = (x: any[]): x is [] => x.length === 0;\ntype Predicate<T, U extends T> = (x: T) => x is U;\ntype AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\ntype UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\nexport const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\nexport const isObject = is(\"object\") as (x: any) => x is Record<string, any>;\n\n// NEW named references\n// constant = null, undefined, number\n// node = [nodeType, ...arguments], or [\"=nodeName\", nodeType, ...arguments] for a named node\n// node with constructor parameters = [[nodeType, ...constructorArgs], ...arguments] or [\"=nodeName\", [nodeType, ...constructorArgs], ...arguments] for a named node\n// ref = \"@nodeName\"\n// input ref = \">inputName\"\n// input ref multi-channel = \">inputName.channelName\"\n\nexport const isConstant = (x: any): x is null | undefined | number | string => any(x, isNull, isUndefined, isNumber) || (isString(x) && !(isRef(x) || isNodeName(x) || isInputRef(x)));\nexport const isNode = (x: any): x is NodeTree =>\n    any(x, isString, isNumber, isUndefined, isNull)\n        ? false\n        : isArray(x) && isString(x[0])\n            ? (isNamedNode(x) ? isNode(getNodeContents(x)) : true)\n            : (isArray(x[0]) && !isEmpty(x[0]) && isString(x[0][0]));\n\nconst isTypeString = <T extends string>(starter: T) => (x: any): x is `${T}${string}` =>\n    isString(x) && x.startsWith(starter);\nexport const isRef = isTypeString(\"@\");\nexport const isNodeName = isTypeString(\"=\");\nexport const isInputRef = isTypeString(\">\");\nexport const isNamedNode = (x: any): x is [NodeName, ...any[]] => isArray(x) && isNodeName(x[0]);\nexport const getNodeName = (x: any): NodeName | undefined => isNamedNode(x) ? x[0] : undefined;\nexport const getNodeContents = (x: any): any[] => isNamedNode(x) ? x.slice(1) : x;\n\n\nconst gensymCounters: Record<string, number> = {};\nexport const gensym = <T extends string>(prefix: T): `${T}${number}` => {\n    gensymCounters[prefix] = (gensymCounters[prefix] || 0) + 1;\n    return `${prefix}${gensymCounters[prefix]}` as const;\n}\n", "import type {\n    CompiledInstrument,\n    NodeImplFactory,\n    NodeInstrList,\n    NodeTree,\n    UsedNodes\n} from \"./types\";\nimport {\n    any,\n    getNodeContents,\n    getNodeName,\n    isArray,\n    isConstant,\n    isEmpty,\n    isInputRef,\n    isNode,\n    isNodeName,\n    isRef,\n    isString\n} from \"./utils\";\n\nexport const compileInstrument = (tree: NodeTree, nodeTypes: Record<string, NodeImplFactory>): CompiledInstrument => {\n    const instructions: NodeInstrList = [];\n    const nodes: UsedNodes = [];\n    const walk = (node: NodeTree) => {\n        const nodeName = getNodeName(node);\n        const nodeContents = getNodeContents(node);\n        for (var i = 1; i < nodeContents.length; i++) {\n            const curEl = nodeContents[i];\n            if (isNode(curEl)) {\n                walk(curEl);\n            } else if (any(curEl, isNodeName, isInputRef, isRef)) {\n                instructions.push(curEl);\n            } else if (isConstant(curEl)) {\n                instructions.push([curEl]);\n            }\n        }\n        // then output the node and register if needed\n        instructions.push([nodes.length, nodeContents.length - 1]);\n        const [nodeType, nodeArgs] = isArray(nodeContents[0]) && !isEmpty(nodeContents[0]) ? [nodeContents[0][0], nodeContents[0].slice(1)] : [nodeContents[0], []];\n        const nodeFactory = (isString(nodeType) && nodeTypes[nodeType]!) || (() => { throw new Error(\"undefined node type \" + nodeType); });\n        nodes.push([nodeFactory, nodeArgs]);\n        if (nodeName !== undefined) {\n            instructions.push(nodeName);\n        }\n    };\n    walk(tree);\n    return [instructions, nodes];\n};\n\n\nconst INDENT = \"|   \";\nexport const debugDumpInstrument = (instrument: CompiledInstrument, nodeTypes: Record<any, NodeImplFactory>): string => {\n    const [instructions, nodeFactories] = instrument;\n    const getNodeName = (factory: NodeImplFactory): string => {\n        for (var k of Object.keys(nodeTypes)) {\n            if (nodeTypes[k] === factory) return k;\n        }\n        return factory.name || \"unknown\";\n    }\n    const nodeNames = nodeFactories.map(([factory, args], index) => `call ${getNodeName(factory)}(${args.join(\", \")}) [index ${index}]`);\n    const output: string[] = [];\n    var i = instructions.length - 1;\n    const addLine = (depth: number, line: string) => {\n        output.push(`${INDENT.repeat(depth)}${line}`);\n    }\n    const walk = (depth: number) => {\n        if (i < 0) return;\n        const inst = instructions[i--]!;\n        if (isArray(inst)) {\n            if (inst.length === 1) {\n                addLine(depth, `push constant ${String(inst[0])}`);\n            } else {\n                const [nodeIndex, numArgs] = inst;\n                addLine(depth, `${nodeNames[nodeIndex]} with ${numArgs}`);\n                for (var j = 0; j < numArgs!; j++)\n                    walk(depth + 1);\n            }\n        } else if (isString(inst)) {\n            if (isRef(inst)) {\n                addLine(depth, `push register ${inst.slice(1)}`);\n            } else if (isInputRef(inst)) {\n                addLine(depth, `push input channel ${inst.slice(1)}`);\n            } else if (isNodeName(inst)) {\n                addLine(depth, `store register ${inst.slice(1)}`);\n                walk(depth);\n            }\n        }\n    };\n    walk(0);\n    return output.join(\"\\n\") + \"\\n\\n\";\n}\n", "import { any, isArray, isNull, isNumber, isObject, isString, isUndefined, mapObject } from \"./utils\";\n\ntype MacroExpander = (...args: any) => any;\nexport const macroexpand = (tree: any, macros: Record<string, MacroExpander>): any => {\n    var temp;\n    return any(tree, isString, isNumber, isUndefined, isNull)\n        ? tree\n        : !isArray(tree)\n            ? mapObject(tree, v => macroexpand(v, macros))\n            : isString(tree[0]) && tree[0] in macros\n                ? (any(temp = macros[tree[0]]!(...tree.slice(1)), isArray, isObject) ? macroexpand(temp, macros) : temp)\n                : tree.map(el => macroexpand(el, macros));\n}\n", "import type { NodeParameter, NodeTree } from \"./types\";\nimport { gensym, isNumber } from \"./utils\";\n\n// TODO nested macros are broken\n\nexport const unisons = (oscTemplate: NodeTree, voices = 1, spread = 0, offset = 0, sign = 1, amp = 1 / voices, freqIndex = 1): NodeTree => {\n    const out: Partial<NodeTree> = [\"a\"];\n    const baseFreq = oscTemplate[freqIndex];\n    for (var i = 1; i <= voices; i++) {\n        const offsetSemitones = offset + spread * (2 * (i - 1) / ((voices - 1) || 1) - .5);\n        const offsetFactor = Math.pow(2, offsetSemitones / 12);\n        out[i] = oscTemplate.with(freqIndex, isNumber(baseFreq) ? baseFreq * offsetFactor : [\"g\", baseFreq, offsetFactor]) as NodeTree;\n        if (i > 1 && sign !== 1) out[i] = [\"g\", sign, out[i]];\n    }\n    return amp !== 1 ? [\"g\", amp, out as NodeTree] : out as NodeTree;\n}\n\nexport const combFilter = (input: NodeTree, delayTime: number, feedbackGain: NodeParameter = .9, feedforward = false): NodeTree => {\n    const linkName = gensym(\"=cff_\");\n    const outName = feedforward ? [] : [linkName];\n    const inName = feedforward ? [linkName] : [];\n    return [...outName, \"a\", [...inName, \"a\", input], [\"g\", feedbackGain, [\"d\", delayTime, , \"@\" + linkName.slice(1)]]] as any;\n}\n\n// TODO: reverb effect\n\n/*\n\nTODO: FM synthesis\n\neach operator = [freqMul, gain, modulatedBy or [modulatedBy, overrideGain], outGain, hzOffset]\n\nso for example: guitar defined as 1<-(2 3<-4), 1=~1x 100%, 2=1x 75%, 3=1x 60%, 4=~2x 25%, feedback = 1->2 25%\nwould be: [[,,[2,3,4],1,5],[,.75,[[1,.25]],0],[,.25,[4],0,5],[2,.25,,0,5]]\n\n*/\n\n// MAIN MACROS OBJECT\nexport const builtinMacros: Record<string, (...args: any[]) => NodeTree> = {\n    u: unisons, // help me pls why are these name slightly different\n    cf: combFilter,\n};\n", "import type { ChannelImpl } from \"./types\";\n\n\n/*\n\nchannel header:\n    undefined or none (number first) = normal or multitrack channel\n        next is undefined or array of track names\n    t = tempo channel\n        integrated; time values are in beats, output values are in BPM\n    m = morph channel\n        next input is number of morph targets\n    e = envelope (gated) channel\n        next header field is which input is the gate\n        can only have 1 track, and a time value of -1 specifies hold while gate on\n\nwhat about multiple notes in the chord\n\ngeneralization of notes: each note entry is a list of time step, for each time event it has\n[pitch, expression] pairs like in a channel, and interpolation is the same, if undefined\nthe interpolation step is omitted and it just takes the intermediate value from the surrounding\ndefined events\n\nbeepbox stores each of the notes vertically: there is only ever zero or one active Note at once\nin each channel, and the Note stores a list of base pitches. Then there is a list of NotePins\nthat have the pitch bend and expression data and the pins apply to *all* of the notes in the chord\nsimultaneously. This is kind of dumb because you should be able to have notes continue at the same time\nanother note starts, as well as some notes pitch bend and others not, without duplicating the same\ninstrument across multiple channels (and then risk editing the instrument in one place and\nforgetting to update it in the copy channels). I had this problem with the white synths in my\nHeavy Light cover towards the end of it. The white synth does chords/pad, but also doubles the\npurple synth's melody in the bass which doesn't have the same note breaks so I couldn't use\n\"continue\" transition mode.\n\n\n\n\n*/\n\nexport type Channel = (number | undefined)[];\n\nconst splitTimings = (channel: Channel, sampleRate: number): [number[], number[], number[]] => {\n    const dts = [0], ts = [0], vals = [0];\n    var t = 0;\n    for (var i = 0; i < channel.length; i += 2) {\n        const dt = ((channel[i] ?? 0) * sampleRate);\n        dts.push(dt);\n        ts.push(t);\n        vals.push(channel[i + 1] ?? 0);\n        t += dt;\n    }\n    return [dts, ts, vals];\n}\n\nconst interpolate = (t: number, a: number, b: number, d: number) =>\n    d <= 0 ? b : a + (b - a) * (t / d);\n\nexport const standardChannel = (sampleRate: number, channel: Channel): ChannelImpl => {\n    const [dts, ts, vals] = splitTimings(channel, sampleRate);\n    var i = 0;\n    return (sampleNo: number) => {\n        if (sampleNo >= ts.at(-1)! + dts.at(-1)!) return 0;\n        while (sampleNo < ts[i]!) i--;\n        while (sampleNo > ts[i]! + dts[i]!) i++;\n        return interpolate(sampleNo - ts[i]!, vals[i - 1] ?? 0, vals[i]!, dts[i]!);\n    }\n}\n\nexport const makeADSRChannel = (attack = 0, decay = 0, sustain = 0, sustainVol = 1, release = .1): Channel =>\n    [attack, 1, decay, sustainVol, sustain, sustainVol, release]\n\nexport const adsrNode = (sampleRate: number, ...params: Parameters<typeof makeADSRChannel>): ChannelImpl => {\n    return standardChannel(sampleRate, makeADSRChannel(...params));\n}\n\nexport const channelDuration = (channel: Channel): number => {\n    const [dts, ts] = splitTimings(channel, 1);\n    return ts.at(-1)! + dts.at(-1)!;\n}\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nconst clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * Math.abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n", "import { standardChannel } from \"./channel\";\nimport {\n    abs,\n    cos,\n    noise3,\n    noise5,\n    saw,\n    sgn,\n    sin,\n    tan,\n    TAU,\n    tri\n} from \"./math\";\nimport type { NodeImpl, NodeImplFactory } from \"./types\";\nimport { isUndefined } from \"./utils\";\n\n\n/** constant node - discards all its inputs and returns the value passed to the constructor */\nexport const constant = (_: number, num: number): NodeImpl => () => num;\n\n/** summing mixer - sums all its inputs and returns the result (0 if no inputs) */\nexport const summingMixer = (): NodeImpl => (_, ...args) => args.reduce((a, b) => a + b, 0);\n/** gain mixer - multiplies all its inputs and returns the result (1 if no inputs) */\nexport const gainMixer = (): NodeImpl => (_, ...args) => args.reduce((a, b) => a * b, 1);\n\n\n/** ZzFX oscillator with 5th power noise. No tremolo, modulation, ADSR, filter, bitcrusher, or echo.\n * Shape is 0 = sine, 1 = triangle, 2 = sawtooth, 3 = tan (sounds like 2x frequency), 4 = cube noise. */\nexport const zzfxOscillator = (sampleRate: number) => {\n    var phase = 0;\n    return (sampleNo: number, frequency: number, shape: number, shapeCurve = 1, noise = 0, phaseOffset = 0) => {\n        const sample = (shape > 3 ? noise3 : shape > 2 ? tan : shape > 1 ? saw : shape ? tri : sin)(phaseOffset * TAU + (phase += (frequency * TAU / sampleRate) * (1 + noise * noise5(sampleNo))));\n        return sgn(sample) * (abs(sample) ** shapeCurve);\n    }\n}\n\n/** Biquad filter node, based on ZzFX's implementation.\n * filter param has the same meaning as there (greater than zero = highpass, less than zero = lowpass).\n * The init-time quality parameter controls the resonance of the filter (higher values = more resonance). */\nexport const biquadFilter = (sampleRate: number, quality = 2) => {\n    var x2 = 0, x1 = 0, y2 = 0, y1 = 0;\n    return (_: any, filter: number, sample: number) => {\n        // basically copied from ZzFX\n        var w = TAU * abs(filter) * 2 / sampleRate,\n            cos_ = cos(w), alpha = sin(w) / 2 / quality,\n            a0 = 1 + alpha, a1 = -2 * cos_ / a0, a2 = (1 - alpha) / a0,\n            b0 = (1 + sgn(filter) * cos_) / 2 / a0,\n            b1 = -(sgn(filter) + cos_) / a0, b2 = b0;\n        return y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = sample) - a2 * y2 - a1 * (y2 = y1);\n\n    }\n}\n\n/** Bit crush in num samples */\nexport const bitcrusher = () => {\n    var phase = 0, curSample = 0;\n    return (_: any, crushSamples: number = 0, sample: number) => {\n        if (++phase >= crushSamples) {\n            phase = 0;\n            curSample = sample;\n        }\n        return curSample;\n    }\n}\n\n\n/** Variable delay. For echo and flanger effects. If feedbackGain is non-zero, the filter's output\n * will be fed back into itself. Don't use a value greater than 1 for feedbackGain or you will\n * get a horrible feedback shriek. */\nexport const delay = (sampleRate: number) => {\n    var len = 1<<16;\n    var buffer: number[] = new Array(len).fill(0);\n    var pos = 0;\n    return (_: any, delayTime: number, feedbackGain = 0, sample: number) => {\n        const delaySamples = sampleRate * delayTime;\n        // len is always a power of 2\n        if (delaySamples > len) {\n            var newLen = len << 1;\n            const newBuffer = new Array(newLen).fill(0);\n            // poor man's memcpy\n            for (var i = 0; i < len; i++) newBuffer[i] = buffer[(pos + i) % len];\n            buffer = newBuffer;\n            pos = len;\n            len = newLen;\n        }\n        const out = buffer[((pos + len - delaySamples) | 0) % len]!;\n        buffer[pos] = sample + out * feedbackGain;\n        pos = (pos + 1) % len;\n        return out;\n    }\n}\n\n/** Shimmer effect. Adds a random amount to the value, but only if the value has changed.\n * The shimmer amount is relative to the value (0.05 = 5%). */\nexport const shimmerer = (_: any) => {\n    var oldValue = 0, out = 0;\n    return (_: any, value: number, shimmerAmount = .05) => {\n        if (oldValue !== value) {\n            out = value + (Math.random() - .5) * shimmerAmount * value;\n            oldValue = value;\n        }\n        return out;\n    }\n}\n\nexport const clock = (sampleRate: number) => {\n    var time = Infinity; // make it roll over on the first sample\n    const dt = 1 / sampleRate;\n    return (_: any, interval: number, speed = 1) => {\n        time += dt * speed;\n        if (time >= interval) {\n            time = 0;\n            return 1;\n        }\n        return 0;\n    }\n}\n\nexport const integrator = (sampleRate: number, initialValue = 0, sampleAccurate = 1) => {\n    var integral = initialValue;\n    return (_: number, integrand: number, reset = 0, resetTo?: number, wrapL?: number, wrapH?: number, clampL?: number, clampH?: number) => {\n        integral += integrand / (sampleAccurate ? sampleRate : 1);\n        if (!isUndefined(wrapL) && !isUndefined(wrapH)) {\n            const difference = wrapH - wrapL;\n            if (integral < wrapL) integral += difference;\n            if (integral > wrapH) integral -= difference;\n        }\n        if (!isUndefined(clampH) && integral > clampH) integral = clampH;\n        if (!isUndefined(clampL) && integral < clampL) integral = clampL;\n        if (reset > 0) integral = resetTo ?? 0;\n        return integral;\n    }\n}\n\n\n// MAIN EXPORTS OBJECT\nexport const builtinNodes: Record<string, NodeImplFactory> = {\n    g: gainMixer,\n    rm: gainMixer, // ring modulator is just a multiplicative gain mixer lol\n    a: summingMixer,\n    w: zzfxOscillator,\n    f: biquadFilter,\n    b: bitcrusher,\n    d: delay,\n    sh: shimmerer,\n    c: clock,\n    i: integrator,\n    ch: standardChannel as any,\n};\n", "interface JSONArray<T> extends Array<JSONValue<T>> { }\ninterface JSONObject<T> { [key: string]: JSONValue<T>; }\ntype JSONValue<T = never> = T | string | number | boolean | null | JSONArray<T> | JSONObject<T>;\nexport function minparse(str: string): JSONValue<undefined> {\n    str = str\n        .replace(/(?<=[,\\[\\{}])([=>@]?[a-z_][a-z\\d_]*)(?=[,:\\]\\}])/ig, \"\\\"$1\\\"\")\n        .replace(/([,\\[])!0([,\\]])/g, \"$1true$2\")\n        .replace(/([,\\[])!1([,\\]])/g, \"$1false$2\")\n        .replace(/\\[,/g, \"[null,\")\n        .replace(/,,\\]/g, \",null]\")\n        .replace(/,\\s*(?=[,\\]])/g, \",null\")\n        .replace(/([\\[,]-?)(?=\\.)/g, \"$10\")\n        .replace(/-\\./g, \"-0.\");\n    console.log(\"preprocessed JSON string:\", str);\n\n    return JSON.parse(str, (_, value) => value === null ? undefined : value);\n}\nexport function minstringify(x: JSONValue<undefined>): string {\n    return JSON.stringify(x)\n        .replace(/true/g, \"!0\")\n        .replace(/false/g, \"!1\")\n        .replace(/,null\\]/g, \",,]\")\n        .replace(/\\[null,/g, \"[,\")\n        .replace(/,null(?=[,\\]])/g, \",\")\n        .replace(/([\\[,]-?)0(?=\\.)/g, \"$1\")\n        .replace(/-0\\./g, \"-.\")\n        .replace(/(?<=[,\\[\\{])\"([=>@]?[a-z_][a-z\\d_]*?)\"(?=[,:\\}])/ig, \"$1\");\n}\n", "import { standardChannel, type Channel } from \"./channel\";\nimport { type CompiledInstrument } from \"./types\";\nimport { isInputRef, isNodeName, isNumber, isRef, mapObject } from \"./utils\";\n\nexport const buildSamples = (instrument: CompiledInstrument, channels: Record<string, Channel>, duration: number, sampleRate = 44100): number[] => {\n    const samples: number[] = [],\n        [instructions, nodeFactories] = instrument,\n        registers: Record<string, number> = {},\n        nodes = nodeFactories.map(([factory, args]) => factory(sampleRate, ...args)),\n        numSamples = duration * sampleRate,\n        // TODO: switch this for different kinds of channel once those are implemented\n        inputChannels = mapObject(channels, channel => standardChannel(sampleRate, channel)),\n        stack: number[] = [];\n    var channelValues: Record<string, number> = {};\n    var i, sampleNo;\n    for (sampleNo = 0; sampleNo < numSamples; sampleNo++) {\n        // do the input channels\n        channelValues = {};\n        for (i of Object.keys(inputChannels)) {\n            channelValues[i] = inputChannels[i]!(sampleNo, channelValues);\n        }\n        // do the node graph\n        stack.length = 0;\n        for (i = 0; i < instructions.length; i++) {\n            const inst = instructions[i]!;\n            if (isNodeName(inst)) {\n                registers[inst.slice(1)] = stack.at(-1)!;\n            } else if (isRef(inst)) {\n                stack.push(registers[inst.slice(1)] ?? 0);\n            } else if (isInputRef(inst)) {\n                stack.push(channelValues[inst.slice(1)] ?? 0);\n            } else {\n                if (inst.length === 1)\n                    stack.push(inst[0]);\n                else {\n                    const [nodeIndex, numArgs] = inst;\n                    stack.push(nodes[nodeIndex]!(sampleNo, ...stack.splice(stack.length - numArgs!, numArgs)));\n                }\n            }\n        }\n        const sample = stack.pop()!;\n        if (!isNumber(sample))\n            throw new Error(`got NaN sample at sampleNo=${sampleNo}`);\n        samples.push(sample);\n    }\n    return samples;\n}\n\nexport const toBufferNode = (samples: number[][] | number[], audioCtx: AudioContext, sampleRate = 44100): AudioBufferSourceNode => {\n    const normSamples = isNumber(samples[0]) ? [samples as number[]] : samples as number[][],\n        buffer = audioCtx.createBuffer(normSamples.length, normSamples[0]!.length, sampleRate),\n        source = audioCtx.createBufferSource();\n    normSamples.map((d, i) => buffer.getChannelData(i).set(d));\n    source.buffer = buffer;\n    return source;\n}\n", "import { makeADSRChannel } from \"./channel\";\nimport { compileInstrument } from \"./instrument\";\nimport { minstringify } from \"./json\";\nimport { builtinNodes } from \"./nodeImpl\";\nimport { buildSamples } from \"./play\";\nimport { NodeParameter } from \"./types\";\nimport { isArray, isUndefined } from \"./utils\";\n\nexport const ZZFX_SAMPLE_RATE = 44100;\n\nconst ZZFX_MASTER_GAIN = .3;\n\nexport const zzfxSamples = (\n    volume = 1,\n    randomness = .05,\n    frequency = 220,\n    attack = 0,\n    sustain = 0,\n    release = .1,\n    shape = 0,\n    shapeCurve = 1,\n    slide = 0,\n    deltaSlide = 0,\n    pitchJump = 0,\n    pitchJumpTime = 0,\n    repeatTime = 0,\n    noise = 0,\n    modulation = 0,\n    bitCrush = 0,\n    delay = 0,\n    sustainVolume = 1,\n    decay = 0,\n    tremolo = 0,\n    filter = 0\n): number[] => {\n    volume *= ZZFX_MASTER_GAIN;\n    slide *= 500;\n    deltaSlide *= 500;\n    bitCrush *= 100;\n    const playDuration = attack + decay + sustain + release;\n    const totalDuration = playDuration + delay;\n    // order is (pitch slide & pitch jump) --> modulation --> osc --> tremolo --> adsr --> delay --> filter --> bitcrusher\n    var jumpOutput: NodeParameter | undefined;\n    var rc: any;\n    const getResetClock = (): NodeParameter => {\n        if (!rc)\n            return rc = [\"c\", repeatTime] as NodeParameter;\n        if (rc[0] != \"=rc\")\n            rc.unshift(\"=rc\");\n        return \"@rc\";\n    }\n    // this logic is a mess\n    if (pitchJump) {\n        var jumpNode: NodeParameter | undefined;\n        if (repeatTime) {\n            // account for pitch jump having to roll over first\n            // before it can be restarted by repeat\n            var temp = repeatTime;\n            while (temp < pitchJumpTime)\n                temp += repeatTime;\n            jumpNode = [[\"i\", , 0], [\"g\", pitchJump, [\"c\", temp]]];\n        }\n        else\n            jumpNode = pitchJump;\n        if (pitchJumpTime)\n            jumpOutput = [\"d\", pitchJumpTime, , jumpNode];\n        else\n            jumpOutput = jumpNode;\n    }\n    var slideNode: NodeParameter | undefined;\n    if (slide || deltaSlide) {\n        var deltaSlideNode: NodeParameter | undefined;\n        if (deltaSlide)\n            deltaSlideNode = [[\"i\", slide], deltaSlide];\n        else\n            deltaSlideNode = slide;\n        slideNode = [\"i\", deltaSlideNode];\n        if (repeatTime) {\n            slideNode[2] = getResetClock();\n            slideNode[3] = 0;\n            if (isArray(deltaSlideNode)) {\n                deltaSlideNode[2] = getResetClock();\n                deltaSlideNode[3] = slide;\n            }\n        }\n    }\n    const randFreqNode = [\"sh\", frequency, randomness];\n    const freqNode = !isUndefined(jumpOutput) || !isUndefined(slideNode)\n        ? [\"a\", randFreqNode, jumpOutput, slideNode].filter(n => !isUndefined(n))\n        : randFreqNode;\n    const modFreqNode = modulation !== 0 ? [\"g\", freqNode, [\"w\", modulation, , , , .25]] : freqNode;\n    const oscNode = [\"w\", modFreqNode, shape, shapeCurve, noise];\n    const tremoloNode = repeatTime > 0 && tremolo > 0 ? [\"a\", 1 - tremolo, [\"g\", tremolo, [\"w\", 1 / repeatTime, , , , .5]]] : undefined;\n    const adsrNode = [[\"ch\", makeADSRChannel(attack, decay, sustain, sustainVolume, release)]];\n    const gainedOscNode = [\"g\", oscNode, tremoloNode, adsrNode].filter(n => !isUndefined(n));\n    const delayedNode = delay > 0 ? [\"a\", [\"g\", .5, gainedOscNode], [\"g\", [\"d\", delay, , \"@di\"], .5, [[\"ch\", [0, 1, playDuration, 1, delay]]]]] : gainedOscNode;\n    const filteredNode = filter ? [\"f\", filter, delayedNode] : delayedNode;\n    const bitcrushedNode = bitCrush ? [\"b\", bitCrush, filteredNode] : filteredNode;\n    if (delay > 0) bitcrushedNode.unshift(\"=di\");\n    const masterGainNode = [\"g\", volume, bitcrushedNode];\n    return buildSamples(compileInstrument(masterGainNode as any, builtinNodes), {}, totalDuration, ZZFX_SAMPLE_RATE);\n}\n"],
  "mappings": "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",
  "names": ["mapObject", "obj", "func", "key", "value", "typeOf", "x", "is", "t", "isNumber", "isUndefined", "isString", "isNull", "isEmpty", "any", "funcs", "f", "isArray", "isObject", "isConstant", "isRef", "isNodeName", "isInputRef", "isNode", "isNamedNode", "getNodeContents", "isTypeString", "starter", "getNodeName", "gensymCounters", "gensym", "prefix", "compileInstrument", "tree", "nodeTypes", "instructions", "nodes", "walk", "node", "nodeName", "getNodeName", "nodeContents", "getNodeContents", "i", "curEl", "isNode", "any", "isNodeName", "isInputRef", "isRef", "isConstant", "nodeType", "nodeArgs", "isArray", "isEmpty", "nodeFactory", "isString", "INDENT", "debugDumpInstrument", "instrument", "nodeFactories", "factory", "k", "nodeNames", "args", "index", "output", "addLine", "depth", "line", "inst", "nodeIndex", "numArgs", "j", "macroexpand", "tree", "macros", "temp", "any", "isString", "isNumber", "isUndefined", "isNull", "isArray", "isObject", "el", "mapObject", "v", "unisons", "oscTemplate", "voices", "spread", "offset", "sign", "amp", "freqIndex", "out", "baseFreq", "i", "offsetSemitones", "offsetFactor", "isNumber", "combFilter", "input", "delayTime", "feedbackGain", "feedforward", "linkName", "gensym", "outName", "inName", "builtinMacros", "splitTimings", "channel", "sampleRate", "dts", "ts", "vals", "t", "i", "dt", "interpolate", "a", "b", "d", "standardChannel", "sampleNo", "makeADSRChannel", "attack", "decay", "sustain", "sustainVol", "release", "adsrNode", "params", "channelDuration", "PI", "TAU", "clamp", "x", "min", "max", "sin", "cos", "sgn", "abs", "tan", "saw", "tri", "noise3", "noise5", "constant", "_", "num", "summingMixer", "args", "a", "b", "gainMixer", "zzfxOscillator", "sampleRate", "phase", "sampleNo", "frequency", "shape", "shapeCurve", "noise", "phaseOffset", "sample", "noise3", "tan", "saw", "tri", "sin", "TAU", "noise5", "sgn", "abs", "biquadFilter", "quality", "x2", "x1", "y2", "y1", "filter", "w", "cos_", "cos", "alpha", "a0", "a1", "a2", "b0", "b1", "b2", "bitcrusher", "curSample", "crushSamples", "delay", "len", "buffer", "pos", "delayTime", "feedbackGain", "delaySamples", "newLen", "newBuffer", "out", "shimmerer", "oldValue", "value", "shimmerAmount", "clock", "time", "dt", "interval", "speed", "integrator", "initialValue", "sampleAccurate", "integral", "integrand", "reset", "resetTo", "wrapL", "wrapH", "clampL", "clampH", "isUndefined", "difference", "builtinNodes", "standardChannel", "minparse", "str", "_", "value", "minstringify", "x", "buildSamples", "instrument", "channels", "duration", "sampleRate", "samples", "instructions", "nodeFactories", "registers", "nodes", "factory", "args", "numSamples", "inputChannels", "mapObject", "channel", "standardChannel", "stack", "channelValues", "i", "sampleNo", "inst", "isNodeName", "isRef", "isInputRef", "nodeIndex", "numArgs", "sample", "isNumber", "toBufferNode", "audioCtx", "normSamples", "buffer", "source", "d", "ZZFX_SAMPLE_RATE", "ZZFX_MASTER_GAIN", "zzfxSamples", "volume", "randomness", "frequency", "attack", "sustain", "release", "shape", "shapeCurve", "slide", "deltaSlide", "pitchJump", "pitchJumpTime", "repeatTime", "noise", "modulation", "bitCrush", "delay", "sustainVolume", "decay", "tremolo", "filter", "playDuration", "totalDuration", "jumpOutput", "rc", "getResetClock", "jumpNode", "temp", "slideNode", "deltaSlideNode", "isArray", "randFreqNode", "freqNode", "isUndefined", "n", "oscNode", "tremoloNode", "adsrNode", "makeADSRChannel", "gainedOscNode", "delayedNode", "filteredNode", "bitcrushedNode", "buildSamples", "compileInstrument", "builtinNodes"]
}
