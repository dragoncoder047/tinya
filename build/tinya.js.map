{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/instrument.ts", "../src/macro.ts", "../src/math.ts", "../src/effectMacros.ts", "../src/channel.ts", "../src/nodeImpl.ts", "../src/json.ts", "../src/play.ts"],
  "sourcesContent": ["import type { NodeTree, NodeImpl } from \"./types\";\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\nexport const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\nexport const isString = is(\"string\") as (x: any) => x is string;\nexport const isNull = (x: any): x is null => x === null;\nexport const isEmpty = (x: any[]): x is [] => x.length === 0;\nexport const isNegativeZero = (x: number): x is -0 => Object.is(x, -0);\nexport const isNotNegative = (x: number) => (x > 0) || ((x === 0) && !isNegativeZero(x));\ntype Predicate<T, U extends T> = (x: T) => x is U;\ntype AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\ntype UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\nexport const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\ntype NodeType = \"constant\" | \"node\" | \"ref\" | \"input\";\n// unholy ternary from hell\nconst classify = (x: any): NodeType | undefined =>\n    any(x, isNull, isUndefined, isNumber)\n        ? \"constant\"\n        : !isArray(x) || isEmpty(x)\n            ? undefined\n            : any(x[0], isString, isUndefined, isNull) || (isArray(x[0]) && (isEmpty(x[0]) || isString(x[0][0])))\n                ? \"node\"\n                : !isNumber(x[0])\n                    ? undefined\n                    : x.length > 1 && x.every(z => isNumber(z) && !isNotNegative(z))\n                        ? \"input\"\n                        : \"ref\";\nexport const isConstant = is(\"constant\", classify) as (x: any) => x is (null | undefined | number);\nexport const isNode = is(\"node\", classify) as (x: any) => x is NodeTree;\nexport const isRef = is(\"ref\", classify) as (x: any) => x is [number, ...number[]];\nexport const isInputRef = is(\"input\", classify) as (x: any) => x is [number, ...number[]];\nexport const constant = (_: number, num: number): NodeImpl => () => num;\n", "import type {\n    CompiledInstrument,\n    NodeImpl,\n    NodeImplFactory,\n    NodeInstrList,\n    NodeTree,\n    UsedNodes\n} from \"./types\";\nimport {\n    any,\n    constant,\n    isArray,\n    isConstant,\n    isEmpty,\n    isInputRef,\n    isNode,\n    isNotNegative,\n    isNull,\n    isNumber,\n    isRef,\n    isString,\n    isUndefined\n} from \"./utils\";\n\n\nconst isValidPath = (tree: NodeTree, path: number[]): boolean => {\n    for (var p of path) {\n        const next = tree[p];\n        if (any(next, isConstant, isRef, isInputRef, isString)) {\n            return false;\n        }\n        tree = next;\n    }\n    return true;\n};\n\nconst absPath = (relPath: number[], currentPath: number[]) => {\n    const back = relPath[0]!;\n    const path = back < 0 ? relPath.slice(1) : relPath;\n    return [currentPath.slice(0, back).concat(path), path];\n};\n\nconst findReferencedNodes = (node: NodeTree, parents: NodeTree[], currentPath: number[]): number[][] => {\n    const references: number[][] = [];\n    const nextParents = parents.concat([node]);\n    for (var i = 1; i < node.length; i++) {\n        const curEl = node[i];\n        if (isRef(curEl)) {\n            const bottom = curEl[0] < 0 ? parents.at(curEl[0]) : node;\n            const [abs, path] = absPath(curEl, currentPath);\n            if (!bottom || !isValidPath(bottom, path!)) {\n                // not valid -> silently reset to default\n                node[i] = undefined;\n            } else {\n                references.push(abs!);\n            }\n        }\n        if (isNode(curEl)) {\n            const nextPath = currentPath.concat(i);\n            references.push(...findReferencedNodes(curEl, nextParents, nextPath));\n        }\n    }\n    return references;\n};\n\nexport const compileInstrument = <T extends string>(tree: NodeTree<T>, nodeTypes: Record<T, NodeImplFactory>): CompiledInstrument => {\n    const registers: number[] = [];\n    const registerPaths: string[] = [];\n    const instructions: NodeInstrList = [];\n    const nodes: UsedNodes = [];\n    const referencedPaths = new Set(findReferencedNodes(tree, [], []).map(p => p.join(\",\")));\n    const pathReferenced = (p: number[]) => referencedPaths.has(p.join(\",\"));\n    const constantsValues: Record<number | string, number> = {};\n    const const_ = (c: number | null | undefined): [number, number] => {\n        var which = constantsValues[String(c)];\n        if (which === undefined) {\n            which = nodes.length;\n            const node = [constant, [c]] as [NodeImplFactory, number[]];\n            nodes.push(node);\n            constantsValues[String(c)] = which;\n        } else {\n        }\n        return [which, 0];\n    };\n    const regPath = (p: number[]) => {\n        var index = registerPaths.indexOf(p.join(\",\"));\n        if (index === -1) {\n            // reffing a node after self\n            index = registers.length;\n            registers.push(0);\n            registerPaths.push(p.join(\",\"));\n        }\n        return index;\n    };\n    const walk = (node: NodeTree<T>, parents: NodeTree<T>[], currentPath: number[]) => {\n        const nextParents = parents.concat([node]);\n        for (var i = 1; i < node.length; i++) {\n            const curEl = node[i];\n            if (isNode(curEl)) {\n                walk(curEl, nextParents, currentPath.concat(i));\n            } else if (isConstant(curEl)) {\n                instructions.push(const_(curEl));\n            } else if (isInputRef(curEl)) {\n                instructions.push([curEl[1]]);\n            } else if (isRef(curEl)) {\n                const [abs, _] = absPath(curEl, currentPath);\n                instructions.push(-regPath(abs!));\n            }\n        }\n        // then output the node and register if needed\n        instructions.push([nodes.length, node.length - 1]);\n        const [nodeName, nodeArgs] = isArray(node[0]) && !isEmpty(node[0]) ? [node[0][0], node[0].slice(1)] : [node[0], []];\n        const nodeFactory = isString(nodeName)\n            ? nodeTypes[nodeName]!\n            : isUndefined(nodeName) || isNull(nodeName)\n                ? getAvgMixer(node.length - 1)\n                : isArray(nodeName) && isEmpty(nodeName)\n                    ? getGainMixer(node.length - 1)\n                    : (() => { throw new Error(\"undefined node type \" + nodeName); });\n        nodes.push([nodeFactory, nodeArgs]);\n        if (pathReferenced(currentPath)) {\n            instructions.push(regPath(currentPath));\n        }\n    };\n    walk(tree, [], []);\n    return [registers, instructions, nodes];\n};\n// this may be premature optimization but whatever\nconst constant_zero: () => NodeImpl = () => () => 0;\nconst identity_mixer: () => NodeImpl = () => (_, s0) => s0;\nconst avgMixer_2: () => NodeImpl = () => (_, s0, s1) => (s0 + s1) / 2;\nconst avgMixer_3: () => NodeImpl = () => (_, s0, s1, s2) => (s0 + s1 + s2) / 3;\nconst avgMixer_4: () => NodeImpl = () => (_, s0, s1, s2, s3) => (s0 + s1 + s2 + s3) / 4;\nconst avgMixer_5: () => NodeImpl = () => (_, s0, s1, s2, s3, s4) => (s0 + s1 + s2 + s3 + s4) / 5;\nconst avgMixer_va: () => NodeImpl = () => (_, ...args) => args.reduce((a, b) => a + b, 0) / args.length;\nconst getAvgMixer = (n: number): NodeImplFactory => [constant_zero, identity_mixer, avgMixer_2, avgMixer_3, avgMixer_4, avgMixer_5][n] ?? avgMixer_va;\nconst gainMixer_2: () => NodeImpl = () => (_, s0, s1) => s0 * s1;\nconst gainMixer_3: () => NodeImpl = () => (_, s0, s1, s2) => s0 * s1 * s2;\nconst gainMixer_4: () => NodeImpl = () => (_, s0, s1, s2, s3) => s0 * s1 * s2 * s3;\nconst gainMixer_5: () => NodeImpl = () => (_, s0, s1, s2, s3, s4) => s0 * s1 * s2 * s3 * s4;\nconst gainMixer_va: () => NodeImpl = () => (_, ...args) => args.reduce((a, b) => a * b, 1);\nconst getGainMixer = (n: number): NodeImplFactory => [constant_zero, identity_mixer, gainMixer_2, gainMixer_3, gainMixer_4, gainMixer_5][n] ?? gainMixer_va;\n\nconst INDENT = \"|   \";\nexport const debugDumpInstrument = (instrument: CompiledInstrument, nodeTypes: Record<any, NodeImplFactory>): string => {\n    const [_, instructions, nodeFactories] = instrument;\n    nodeTypes = Object.assign({\n        __constant: constant,\n        __identity_mixer: identity_mixer,\n        __avgMixer_2: avgMixer_2,\n        __avgMixer_3: avgMixer_3,\n        __avgMixer_4: avgMixer_4,\n        __avgMixer_5: avgMixer_5,\n        __avgMixer_va: avgMixer_va,\n        __gainMixer_2: gainMixer_2,\n        __gainMixer_3: gainMixer_3,\n        __gainMixer_4: gainMixer_4,\n        __gainMixer_5: gainMixer_5,\n        __gainMixer_va: gainMixer_va\n    }, nodeTypes);\n    const getNodeName = (factory: NodeImplFactory): string => {\n        for (var k of Object.keys(nodeTypes)) {\n            if (nodeTypes[k] === factory) return k;\n        }\n        return factory.name || \"unknown\";\n    }\n    const nodeNames = nodeFactories.map(([factory, args], index) => `call ${getNodeName(factory)}(${args.join(\", \")}) [index ${index}]`);\n    const output: string[] = [];\n    var i = instructions.length - 1;\n    const walk = (depth: number) => {\n        if (i < 0) return;\n        const inst = instructions[i--]!;\n        if (isArray(inst)) {\n            const [nodeIndex, numArgs] = inst;\n            const nodeName = isNotNegative(nodeIndex) ? `${nodeNames[nodeIndex]} with ${numArgs}` : `get input channel ${-nodeIndex}`;\n            output.push(INDENT.repeat(depth) + nodeName);\n            if (isNotNegative(nodeIndex))\n                for (var j = 0; j < numArgs!; j++)\n                    walk(depth + 1);\n        } else if (isNumber(inst)) {\n            output.push(`${INDENT.repeat(depth)}${isNotNegative(inst) ? \"store\" : \"get\"} register ${inst}`);\n        }\n    };\n    walk(0);\n    return output.join(\"\\n\") + \"\\n\\n\";\n};", "import { isArray, isString } from \"./utils\";\n\ntype MacroExpander<T extends Array<any>> = (...args: T) => T;\nexport const macroexpand = <T extends Array<any>, M extends string>(tree: T, macros: Record<M, MacroExpander<T>>): T =>\n    !isArray(tree)\n        ? tree\n        : isString(tree[0]) && tree[0] in macros\n            ? macros[tree[0] as M](...tree.slice(1) as T)\n            : tree.map(el => macroexpand(el, macros)) as T;\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nconst clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * Math.abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n", "import { cos, PI } from \"./math\";\nimport type { NodeParameter, NodeTree } from \"./types\";\nimport { isNumber } from \"./utils\";\n\n// export const replace = (node: NodeTree, placeholder: string, value: NodeTree): NodeTree =>\n//     node.map(el => el === placeholder ? value : isArray(el) ? replace(el as NodeTree, placeholder, value) : el) as any;\n\n\nexport const unisons = (oscTemplate: NodeTree, voices = 1, spread = 0, offset = 0, sign = 1, amp = 1, freqIndex = 1): NodeTree => {\n    const out: Partial<NodeTree> = [];\n    const baseFreq = oscTemplate[freqIndex];\n    for (var i = 1; i <= voices; i++) {\n        const selfOffset = (offset ?? 0) + (i > 1 ? -cos(PI * i) * ((i / 2) | 0) * spread : 0);\n        const freqOffset = Math.pow(2, selfOffset / 12);\n        out[i] = oscTemplate.with(freqIndex, isNumber(baseFreq) ? baseFreq * freqOffset : [[], baseFreq, freqOffset]);\n        if (i > 1 && sign !== 1) out[i] = [[], sign, out[i]];\n    }\n    return amp !== 1 ? [[], amp, out as NodeTree] : out as NodeTree;\n}\n\nexport const combFilter = (input: NodeTree, delayTime: number, feedbackGain: NodeParameter = .9, feedforward = false, delayName = \"d\", delaySampleInputIndex = 1): NodeTree => {\n    const delayLine: NodeTree = [[delayName, delayTime]];\n    delayLine[delaySampleInputIndex] = feedforward ? [-2, 0] : [-2];\n    return [, input, [[], feedbackGain, delayLine]];\n}\n\n// TODO: reverb effect\n\n// TODO: FM synthesis\n", "import type { NodeImpl } from \"./types\";\n\nconst interpolationFunction = (t: number, p: number = 1, a: number, b: number, d: number) =>\n    d > 0 ? (p < 0 ? (b + (a - b) * ((d - t) / d) ** -p) : (a + (b - a) * (t / d) ** p)) : b;\n\n\nexport type Channel = (number | undefined)[];\n\nconst splitTimings = (channel: Channel, sampleRate: number): [number[], number[], number[], number[]] => {\n    const dts = [], ts = [], ps = [], vals = [];\n    var t = 0;\n    for (var i = 0; i < channel.length; i += 3) {\n        const dt = ((channel[i] ?? 0) * sampleRate);\n        dts.push(dt);\n        ts.push(t);\n        ps.push(channel[i + 1] ?? 1);\n        vals.push(channel[i + 2] ?? 0);\n        t += dt;\n    }\n    return [dts, ts, ps, vals];\n}\n\nexport const standardChannel = (sampleRate: number, channel: Channel): NodeImpl => {\n    const [dts, ts, ps, vals] = splitTimings(channel, sampleRate);\n    var i = 0;\n    return (sampleNo: number) => {\n        if (sampleNo >= ts.at(-1)! + dts.at(-1)!) return 0;\n        while (sampleNo < ts[i]!) i--;\n        while (sampleNo > ts[i]! + dts[i]!) i++;\n        return interpolationFunction(sampleNo - ts[i]!, ps[i], vals[i - 1] ?? 0, vals[i]!, dts[i]!);\n    }\n}\n\nexport const makeADSRChannel = (attack = 0, decay = 0, sustain = 0, sustainVol = 1, release = .1, gateChannel = 0, behavior = 5): Channel =>\n    [...(sustain < 0 ? [, -gateChannel, behavior] : []), attack, , 1, decay, , sustainVol, sustain, , sustainVol, release]\n\nexport const adsrNode = (sampleRate: number, ...params: Parameters<typeof makeADSRChannel>): NodeImpl => {\n    return standardChannel(sampleRate, makeADSRChannel(...params));\n}\n\nexport const channelDuration = (channel: Channel): number => {\n    const [dts, ts] = splitTimings(channel, 1);\n    return ts.at(-1)! + dts.at(-1)!;\n}\n\n// TODO: BPM / tempo channel and articulation channel\n", "import {\n    abs,\n    cos,\n    noise3,\n    noise5,\n    saw,\n    sgn,\n    sin,\n    tan,\n    TAU,\n    tri\n} from \"./math\";\n\n/** ZzFX oscillator. No tremolo, modulation, ADSR, filter, bitcrusher, or echo. */\nexport const zzfxOscillator = (sampleRate: number) => {\n    var phase = 0;\n    return (sampleNo: number, frequency: number, shape: number, shapeCurve = 1, noise = 0, phaseOffset = 0) => {\n        const sample = (shape > 3 ? noise3 : shape > 2 ? tan : shape > 1 ? saw : shape ? tri : sin)(phaseOffset * TAU + (phase += (frequency * TAU / sampleRate) * (1 + noise * noise5(sampleNo))));\n        return sgn(sample) * (abs(sample) ** shapeCurve);\n    }\n}\n\n/** Biquad filter node, based on ZzFX's implementation.\n * filter param has the same meaning as there (greater than zero = highpass, less than zero = lowpass).\n * The init-time quality parameter controls the resonance of the filter (higher values = more resonance). */\nexport const biquadFilter = (sampleRate: number, quality = 2) => {\n    var x2 = 0, x1 = 0, y2 = 0, y1 = 0;\n    return (_: any, filter: number, sample: number) => {\n        console.log(\"biquadFilter\", filter, sample);\n        // basically copied from ZzFX\n        var w = TAU * abs(filter) * 2 / sampleRate,\n            cos_ = cos(w), alpha = sin(w) / 2 / quality,\n            a0 = 1 + alpha, a1 = -2 * cos_ / a0, a2 = (1 - alpha) / a0,\n            b0 = (1 + sgn(filter) * cos_) / 2 / a0,\n            b1 = -(sgn(filter) + cos_) / a0, b2 = b0;\n        return y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = sample) - a2 * y2 - a1 * (y2 = y1);\n\n    }\n}\n\n/** Bit crush in num samples */\nexport const bitcrusher = () => {\n    var phase = 0, curSample = 0;\n    return (_: any, crushSamples: number = 0, sample: number) =>\n        (crushSamples > 0 && (phase = (phase + 1) % (crushSamples | 0)) >= 1) ? curSample : (curSample = sample);\n}\n\n\n/** Fixed delay. For echo and flanger effects. If feedbackGain is non-zero, the filter's output will be fed back into itself. Don't use a value greater than 1 for feedbackGain or you will get a horrible feedback shriek. */\nexport const delay = (sampleRate: number, delayTime: number) => {\n    if (delayTime === 0) return (_: any, sample: number) => sample; // special case no delay\n    const delaySamples = (sampleRate * delayTime) | 0;\n    const buffer: number[] = new Array(delaySamples).fill(0);\n    var i = 0;\n    return (_: any, sample: number, feedbackGain = 0) => {\n        const output = buffer[i]!;\n        buffer[i] = sample + output * feedbackGain;\n        i = (i + 1) % delaySamples;\n        return output;\n    }\n}\n\n/** Shimmer effect. Adds a random amount to the value, but only if the value has changed. The shimmer amount is relative to the value (0.05 = 5%). */\nexport const shimmerer = (_: any) => {\n    var oldValue = 0, out = 0;\n    return (_: any, value: number, shimmerAmount = .05) => {\n        if (oldValue !== value) {\n            out = value + (Math.random() - .5) * shimmerAmount * value;\n            oldValue = value;\n        }\n        return out;\n    }\n}\n", "import { isNegativeZero, isNumber } from \"./utils\";\n\ninterface JSONArray<T> extends Array<JSONValue<T>> { }\ninterface JSONObject<T> { [key: string]: JSONValue<T>; }\ntype JSONValue<T = never> = T | string | number | boolean | null | JSONArray<T> | JSONObject<T>;\nexport function minparse(str: string): JSONValue<undefined> {\n    str = str\n        .replace(/([,\\[])([a-z_]+?)([,\\]])/ig, \"$1\\\"$2\\\"$3\")\n        .replace(/([,\\[])!0([,\\]])/g, \"$1true$2\")\n        .replace(/([,\\[])!1([,\\]])/g, \"$1false$2\")\n        .replace(/\\[,/g, \"[null,\")\n        .replace(/,,\\]/g, \",null]\")\n        .replace(/,\\s*(?=[,\\]])/g, \",null\")\n        .replace(/([\\[,]-?)(?=\\.)/g, \"$10\")\n        .replace(/-\\./g, \"-0.\");\n\n    return JSON.parse(str, (_, value) => value === null ? undefined : value);\n}\nconst NEGATIVE_ZERO_SENTINEL = \"____NZ\"\nconst stringify = JSON.stringify;\nconst NEGATIVE_ZERO_SENTINEL_REGEXP = new RegExp(stringify(NEGATIVE_ZERO_SENTINEL), \"g\");\nexport function minstringify(x: JSONValue<undefined>): string {\n    return stringify(x, (_, v) => isNumber(v) && isNegativeZero(v) ? NEGATIVE_ZERO_SENTINEL : v)\n        .replace(/true/g, \"!0\")\n        .replace(/false/g, \"!1\")\n        .replace(/,null\\]/g, \",,]\")\n        .replace(/\\[null,/g, \"[,\")\n        .replace(/,null(?=[,\\]])/g, \",\")\n        .replace(/([\\[,]-?)0(?=\\.)/g, \"$1\")\n        .replace(/-0\\./g, \"-.\")\n        .replace(NEGATIVE_ZERO_SENTINEL_REGEXP, \"-0\")\n        .replace(/([,\\[])\"([a-z_]+?)\"([,\\]])/ig, \"$1$2$3\");\n}\n", "import { standardChannel, type Channel } from \"./channel\";\nimport { type CompiledInstrument } from \"./types\";\nimport { isNotNegative, isNumber } from \"./utils\";\n\nexport const buildSamples = (instrument: CompiledInstrument, channels: Channel[], duration: number, sampleRate = 44100): number[] => {\n    const samples: number[] = [],\n        [registers, instructions, nodeFactories] = instrument,\n        nodes = nodeFactories.map(([factory, args]) => factory(sampleRate, ...args)),\n        numSamples = duration * sampleRate,\n        // TODO: switch this for different kinds of channel once those are implemented\n        inputChannels = channels.map(c => standardChannel(sampleRate, c)),\n        channelValues: number[] = [],\n        stack: number[] = [];\n    var i, sampleNo;\n    for (sampleNo = 0; sampleNo < numSamples; sampleNo++) {\n        // do the input channels\n        channelValues.length = 0;\n        for (i = 0; i < inputChannels.length; i++)\n            channelValues.push(inputChannels[i]!(sampleNo, ...channelValues));\n        // do the node graph\n        stack.length = 0;\n        for (i = 0; i < instructions.length; i++) {\n            const inst = instructions[i]!;\n            if (isNumber(inst)) {\n                if (isNotNegative(inst))\n                    registers[inst] = stack.at(-1)!;\n                else\n                    stack.push(registers[-inst]!)\n            } else {\n                const [nodeIndex, numArgs] = inst;\n                if (isNotNegative(nodeIndex))\n                    stack.push(nodes[nodeIndex]!(sampleNo, ...stack.splice(stack.length - numArgs!, numArgs)));\n                else\n                    stack.push(channelValues[-nodeIndex]! ?? 0);\n            }\n        }\n        const sample = stack.pop()!;\n        if (!isNumber(sample))\n            throw new Error(`got NaN sample at sampleNo=${sampleNo}`);\n        samples.push(sample);\n    }\n    return samples;\n}\n\nexport const toBufferNode = (samples: number[][] | number[], audioCtx: AudioContext, sampleRate = 44100): AudioBufferSourceNode => {\n    const normSamples = isNumber(samples[0]) ? [samples as number[]] : samples as number[][],\n        buffer = audioCtx.createBuffer(normSamples.length, normSamples[0]!.length, sampleRate),\n        source = audioCtx.createBufferSource();\n    normSamples.map((d, i) => buffer.getChannelData(i).set(d));\n    source.buffer = buffer;\n    return source;\n}\n"],
  "mappings": "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",
  "names": ["typeOf", "x", "is", "t", "func", "isNumber", "isUndefined", "isString", "isNull", "isEmpty", "isNegativeZero", "isNotNegative", "any", "funcs", "f", "isArray", "classify", "z", "isConstant", "isNode", "isRef", "isInputRef", "constant", "_", "num", "isValidPath", "tree", "path", "p", "next", "any", "isConstant", "isRef", "isInputRef", "isString", "absPath", "relPath", "currentPath", "back", "findReferencedNodes", "node", "parents", "references", "nextParents", "i", "curEl", "bottom", "abs", "isNode", "nextPath", "compileInstrument", "nodeTypes", "registers", "registerPaths", "instructions", "nodes", "referencedPaths", "pathReferenced", "constantsValues", "const_", "c", "which", "constant", "regPath", "index", "walk", "_", "nodeName", "nodeArgs", "isArray", "isEmpty", "nodeFactory", "isUndefined", "isNull", "getAvgMixer", "getGainMixer", "constant_zero", "identity_mixer", "s0", "avgMixer_2", "s1", "avgMixer_3", "s2", "avgMixer_4", "s3", "avgMixer_5", "s4", "avgMixer_va", "args", "a", "b", "n", "gainMixer_2", "gainMixer_3", "gainMixer_4", "gainMixer_5", "gainMixer_va", "INDENT", "debugDumpInstrument", "instrument", "nodeFactories", "getNodeName", "factory", "k", "nodeNames", "output", "depth", "inst", "nodeIndex", "numArgs", "isNotNegative", "j", "isNumber", "macroexpand", "tree", "macros", "isArray", "isString", "el", "PI", "TAU", "clamp", "x", "min", "max", "sin", "cos", "sgn", "abs", "tan", "saw", "tri", "noise3", "noise5", "unisons", "oscTemplate", "voices", "spread", "offset", "sign", "amp", "freqIndex", "out", "baseFreq", "i", "selfOffset", "cos", "PI", "freqOffset", "isNumber", "combFilter", "input", "delayTime", "feedbackGain", "feedforward", "delayName", "delaySampleInputIndex", "delayLine", "interpolationFunction", "t", "p", "a", "b", "d", "splitTimings", "channel", "sampleRate", "dts", "ts", "ps", "vals", "i", "dt", "standardChannel", "sampleNo", "makeADSRChannel", "attack", "decay", "sustain", "sustainVol", "release", "gateChannel", "behavior", "adsrNode", "params", "channelDuration", "zzfxOscillator", "sampleRate", "phase", "sampleNo", "frequency", "shape", "shapeCurve", "noise", "phaseOffset", "sample", "noise3", "tan", "saw", "tri", "sin", "TAU", "noise5", "sgn", "abs", "biquadFilter", "quality", "x2", "x1", "y2", "y1", "_", "filter", "w", "cos_", "cos", "alpha", "a0", "a1", "a2", "b0", "b1", "b2", "bitcrusher", "curSample", "crushSamples", "delay", "delayTime", "delaySamples", "buffer", "i", "feedbackGain", "output", "shimmerer", "oldValue", "out", "value", "shimmerAmount", "minparse", "str", "_", "value", "NEGATIVE_ZERO_SENTINEL", "stringify", "NEGATIVE_ZERO_SENTINEL_REGEXP", "minstringify", "x", "v", "isNumber", "isNegativeZero", "buildSamples", "instrument", "channels", "duration", "sampleRate", "samples", "registers", "instructions", "nodeFactories", "nodes", "factory", "args", "numSamples", "inputChannels", "c", "standardChannel", "channelValues", "stack", "i", "sampleNo", "inst", "isNumber", "isNotNegative", "nodeIndex", "numArgs", "sample", "toBufferNode", "audioCtx", "normSamples", "buffer", "source", "d"]
}
