{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/instrument.ts", "../src/macro.ts", "../src/effectMacros.ts", "../src/channel.ts", "../src/math.ts", "../src/nodeImpl.ts", "../src/json.ts", "../src/play.ts"],
  "sourcesContent": ["import type { NodeName, NodeTree } from \"./types\";\n\nexport const mapObject = <T, U>(obj: Record<string, T>, func: (value: T, key: string) => U): Record<string, U> =>\n    Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, func(value, key)]));\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\nexport const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\nexport const isString = is(\"string\") as (x: any) => x is string;\nexport const isNull = (x: any): x is null => x === null;\nexport const isEmpty = (x: any[]): x is [] => x.length === 0;\nexport const isNegativeZero = (x: number): x is -0 => Object.is(x, -0);\nexport const isNotNegative = (x: number) => (x > 0) || ((x === 0) && !isNegativeZero(x));\ntype Predicate<T, U extends T> = (x: T) => x is U;\ntype AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\ntype UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\nexport const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\nexport const isObject = is(\"object\") as (x: any) => x is Record<string, any>;\n\n// NEW named references\n// constant = null, undefined, number\n// node = [nodeType, ...arguments], or [\"=nodeName\", nodeType, ...arguments] for a named node\n// node with constructor parameters = [[nodeType, ...constructorArgs], ...arguments] or [\"=nodeName\", [nodeType, ...constructorArgs], ...arguments] for a named node\n// ref = \"@nodeName\"\n// input ref = \">inputName\"\n\nexport const isConstant = (x: any): x is null | undefined | number | string => any(x, isNull, isUndefined, isNumber) || (isString(x) && !(isRef(x) || isNodeName(x) || isInputRef(x)));\nexport const isNode = (x: any): x is NodeTree =>\n    any(x, isString, isNumber, isUndefined, isNull)\n        ? false\n        : isArray(x) && isString(x[0])\n            ? (isNamedNode(x) ? isNode(getNodeContents(x)) : true)\n            : (isArray(x[0]) && !isEmpty(x[0]) && isString(x[0][0]));\n\nconst isTypeString = <T extends string>(starter: T) => (x: any): x is `${T}${string}` =>\n    isString(x) && x.startsWith(starter);\nexport const isRef = isTypeString(\".\");\nexport const isNodeName = isTypeString(\"=\");\nexport const isInputRef = isTypeString(\">\");\nexport const isNamedNode = (x: any): x is [NodeName, ...any[]] => isArray(x) && isNodeName(x[0]);\nexport const getNodeName = (x: any): NodeName | undefined => isNamedNode(x) ? x[0] : undefined;\nexport const getNodeContents = (x: any): any[] => isNamedNode(x) ? x.slice(1) : x;\n\n\nconst gensymCounters: Record<string, number> = {};\nexport const gensym = <T extends string>(prefix: T): `${T}${number}` => {\n    gensymCounters[prefix] = (gensymCounters[prefix] || 0) + 1;\n    return `${prefix}${gensymCounters[prefix]}` as const;\n}\n", "import type {\n    CompiledInstrument,\n    NodeImplFactory,\n    NodeInstrList,\n    NodeTree,\n    UsedNodes\n} from \"./types\";\nimport {\n    any,\n    getNodeContents,\n    getNodeName,\n    isArray,\n    isConstant,\n    isEmpty,\n    isInputRef,\n    isNode,\n    isNodeName,\n    isRef,\n    isString\n} from \"./utils\";\n\nexport const compileInstrument = (tree: NodeTree, nodeTypes: Record<string, NodeImplFactory>): CompiledInstrument => {\n    const instructions: NodeInstrList = [];\n    const nodes: UsedNodes = [];\n    const walk = (node: NodeTree) => {\n        const nodeName = getNodeName(node);\n        const nodeContents = getNodeContents(node);\n        for (var i = 1; i < nodeContents.length; i++) {\n            const curEl = nodeContents[i];\n            if (isNode(curEl)) {\n                walk(curEl);\n            } else if (any(curEl, isNodeName, isInputRef, isRef)) {\n                instructions.push(curEl);\n            } else if (isConstant(curEl)) {\n                instructions.push([curEl]);\n            }\n        }\n        // then output the node and register if needed\n        instructions.push([nodes.length, nodeContents.length - 1]);\n        const [nodeType, nodeArgs] = isArray(nodeContents[0]) && !isEmpty(nodeContents[0]) ? [nodeContents[0][0], nodeContents[0].slice(1)] : [nodeContents[0], []];\n        const nodeFactory = (isString(nodeType) && nodeTypes[nodeType]!) || (() => { throw new Error(\"undefined node type \" + nodeType); });\n        nodes.push([nodeFactory, nodeArgs]);\n        if (nodeName !== undefined) {\n            instructions.push(nodeName);\n        }\n    };\n    walk(tree);\n    return [instructions, nodes];\n};\n\n\nconst INDENT = \"|   \";\nexport const debugDumpInstrument = (instrument: CompiledInstrument, nodeTypes: Record<any, NodeImplFactory>): string => {\n    const [instructions, nodeFactories] = instrument;\n    const getNodeName = (factory: NodeImplFactory): string => {\n        for (var k of Object.keys(nodeTypes)) {\n            if (nodeTypes[k] === factory) return k;\n        }\n        return factory.name || \"unknown\";\n    }\n    const nodeNames = nodeFactories.map(([factory, args], index) => `call ${getNodeName(factory)}(${args.join(\", \")}) [index ${index}]`);\n    const output: string[] = [];\n    var i = instructions.length - 1;\n    const addLine = (depth: number, line: string) => {\n        output.push(`${INDENT.repeat(depth)}${line}`);\n    }\n    const walk = (depth: number) => {\n        if (i < 0) return;\n        const inst = instructions[i--]!;\n        if (isArray(inst)) {\n            if (inst.length === 1) {\n                addLine(depth, `push constant ${String(inst[0])}`);\n            } else {\n                const [nodeIndex, numArgs] = inst;\n                addLine(depth, `${nodeNames[nodeIndex]} with ${numArgs}`);\n                for (var j = 0; j < numArgs!; j++)\n                    walk(depth + 1);\n            }\n        } else if (isString(inst)) {\n            if (isRef(inst)) {\n                addLine(depth, `push register ${inst.slice(1)}`);\n            } else if (isInputRef(inst)) {\n                addLine(depth, `push input channel ${inst.slice(1)}`);\n            } else if (isNodeName(inst)) {\n                addLine(depth, `store register ${inst.slice(1)}`);\n                walk(depth);\n            }\n        }\n    };\n    walk(0);\n    return output.join(\"\\n\") + \"\\n\\n\";\n}\n", "import { any, isArray, isNull, isNumber, isObject, isString, isUndefined, mapObject } from \"./utils\";\n\ntype MacroExpander = (...args: any) => any;\nexport const macroexpand = (tree: any, macros: Record<string, MacroExpander>): any => {\n    var temp;\n    return any(tree, isString, isNumber, isUndefined, isNull)\n        ? tree\n        : !isArray(tree)\n            ? mapObject(tree, v => macroexpand(v, macros))\n            : isString(tree[0]) && tree[0] in macros\n                ? (any(temp = macros[tree[0]]!(...tree.slice(1)), isArray, isObject) ? macroexpand(temp, macros) : temp)\n                : tree.map(el => macroexpand(el, macros));\n}\n", "import type { NodeParameter, NodeTree } from \"./types\";\nimport { gensym, isNumber } from \"./utils\";\n\n// TODO nested macros are broken\n\nexport const unisons = (oscTemplate: NodeTree, voices = 1, spread = 0, offset = 0, sign = 1, amp = 1 / voices, freqIndex = 1): NodeTree => {\n    const out: Partial<NodeTree> = [\"add\"];\n    const baseFreq = oscTemplate[freqIndex];\n    for (var i = 1; i <= voices; i++) {\n        const offsetSemitones = offset + spread * (2 * (i - 1) / ((voices - 1) || 1) - .5);\n        const offsetFactor = Math.pow(2, offsetSemitones / 12);\n        out[i] = oscTemplate.with(freqIndex, isNumber(baseFreq) ? baseFreq * offsetFactor : [\"gain\", baseFreq, offsetFactor]) as NodeTree;\n        if (i > 1 && sign !== 1) out[i] = [\"gain\", sign, out[i]];\n    }\n    return amp !== 1 ? [\"gain\", amp, out as NodeTree] : out as NodeTree;\n}\n\nexport const combFilter = (input: NodeTree, delayTime: number, feedbackGain: NodeParameter = .9, feedforward = false): NodeTree => {\n    const linkName = gensym(\"=combfilter_feed_\");\n    const outName = feedforward ? [] : [linkName];\n    const inName = feedforward ? [linkName] : [];\n    return [...outName, \"add\", [...inName, \"add\", input], [\"gain\", feedbackGain, [[\"delay\", delayTime], \".\" + linkName.slice(1)]]] as any;\n}\n\n// TODO: reverb effect\n\n// TODO: FM synthesis\n\n// MAIN MACROS OBJECT\nexport const builtinMacros: Record<string, (...args: any[]) => NodeTree> = {\n    unison: unisons,\n    combfilter: combFilter,\n};\n", "import type { ChannelImpl, NodeImpl } from \"./types\";\n\nconst interpolationFunction = (t: number, p: number = 1, a: number, b: number, d: number) =>\n    d > 0 ? (p < 0 ? (b + (a - b) * ((d - t) / d) ** -p) : (a + (b - a) * (t / d) ** p)) : b;\n\n\nexport type Channel = (number | undefined)[];\n\nconst splitTimings = (channel: Channel, sampleRate: number): [number[], number[], number[], number[]] => {\n    const dts = [], ts = [], ps = [], vals = [];\n    var t = 0;\n    for (var i = 0; i < channel.length; i += 3) {\n        const dt = ((channel[i] ?? 0) * sampleRate);\n        dts.push(dt);\n        ts.push(t);\n        ps.push(channel[i + 1] ?? 1);\n        vals.push(channel[i + 2] ?? 0);\n        t += dt;\n    }\n    return [dts, ts, ps, vals];\n}\n\nexport const standardChannel = (sampleRate: number, channel: Channel): ChannelImpl => {\n    const [dts, ts, ps, vals] = splitTimings(channel, sampleRate);\n    var i = 0;\n    return (sampleNo: number) => {\n        if (sampleNo >= ts.at(-1)! + dts.at(-1)!) return 0;\n        while (sampleNo < ts[i]!) i--;\n        while (sampleNo > ts[i]! + dts[i]!) i++;\n        return interpolationFunction(sampleNo - ts[i]!, ps[i], vals[i - 1] ?? 0, vals[i]!, dts[i]!);\n    }\n}\n\nexport const makeADSRChannel = (attack = 0, decay = 0, sustain = 0, sustainVol = 1, release = .1, gateChannel = 0, behavior = 5): Channel =>\n    [...(sustain < 0 ? [, -gateChannel, behavior] : []), attack, , 1, decay, , sustainVol, sustain, , sustainVol, release]\n\nexport const adsrNode = (sampleRate: number, ...params: Parameters<typeof makeADSRChannel>): ChannelImpl => {\n    return standardChannel(sampleRate, makeADSRChannel(...params));\n}\n\nexport const channelDuration = (channel: Channel): number => {\n    const [dts, ts] = splitTimings(channel, 1);\n    return ts.at(-1)! + dts.at(-1)!;\n}\n\n// TODO: BPM / tempo channel and articulation channel\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nconst clamp = (x: number, min: number, max: number) => Math.max(Math.min(x, max), min);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * Math.abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n", "import {\n    abs,\n    cos,\n    noise3,\n    noise5,\n    saw,\n    sgn,\n    sin,\n    tan,\n    TAU,\n    tri\n} from \"./math\";\nimport { NodeImpl, NodeImplFactory } from \"./types\";\n\n\n/** constant node - discards all its inputs and returns the value passed to the constructor */\nexport const constant = (_: number, num: number): NodeImpl => () => num;\n\n/** summing mixer - sums all its inputs and returns the result (0 if no inputs) */\nexport const summingMixer = (): NodeImpl => (_, ...args) => args.reduce((a, b) => a + b, 0);\n/** gain mixer - multiplies all its inputs and returns the result (1 if no inputs) */\nexport const gainMixer = (): NodeImpl => (_, ...args) => args.reduce((a, b) => a * b, 1);\n\n\n/** ZzFX oscillator with 5th power noise. No tremolo, modulation, ADSR, filter, bitcrusher, or echo.\n * Shape is 0 = sine, 1 = triangle, 2 = sawtooth, 3 = tan (sounds like 2x frequency), 4 = cube noise. */\nexport const zzfxOscillator = (sampleRate: number) => {\n    var phase = 0;\n    return (sampleNo: number, frequency: number, shape: number, shapeCurve = 1, noise = 0, phaseOffset = 0) => {\n        const sample = (shape > 3 ? noise3 : shape > 2 ? tan : shape > 1 ? saw : shape ? tri : sin)(phaseOffset * TAU + (phase += (frequency * TAU / sampleRate) * (1 + noise * noise5(sampleNo))));\n        return sgn(sample) * (abs(sample) ** shapeCurve);\n    }\n}\n\n/** Biquad filter node, based on ZzFX's implementation.\n * filter param has the same meaning as there (greater than zero = highpass, less than zero = lowpass).\n * The init-time quality parameter controls the resonance of the filter (higher values = more resonance). */\nexport const biquadFilter = (sampleRate: number, quality = 2) => {\n    var x2 = 0, x1 = 0, y2 = 0, y1 = 0;\n    return (_: any, filter: number, sample: number) => {\n        // basically copied from ZzFX\n        var w = TAU * abs(filter) * 2 / sampleRate,\n            cos_ = cos(w), alpha = sin(w) / 2 / quality,\n            a0 = 1 + alpha, a1 = -2 * cos_ / a0, a2 = (1 - alpha) / a0,\n            b0 = (1 + sgn(filter) * cos_) / 2 / a0,\n            b1 = -(sgn(filter) + cos_) / a0, b2 = b0;\n        return y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = sample) - a2 * y2 - a1 * (y2 = y1);\n\n    }\n}\n\n/** Bit crush in num samples */\nexport const bitcrusher = () => {\n    var phase = 0, curSample = 0;\n    return (_: any, crushSamples: number = 0, sample: number) => {\n        if (++phase >= crushSamples) {\n            phase = 0;\n            curSample = sample;\n        }\n        return curSample;\n    }\n}\n\n\n/** Fixed delay. For echo and flanger effects. If feedbackGain is non-zero, the filter's output will be fed back into itself. Don't use a value greater than 1 for feedbackGain or you will get a horrible feedback shriek. */\nexport const delay = (sampleRate: number, delayTime: number) => {\n    if (delayTime === 0) return (_: any, sample: number) => sample; // special case no delay\n    const delaySamples = (sampleRate * delayTime) | 0;\n    const buffer: number[] = new Array(delaySamples).fill(0);\n    var i = 0;\n    return (_: any, sample: number, feedbackGain = 0) => {\n        // TODO: variable delay time (if less than buffer length, advance read in next line by bufLen-delayTime samples, if too long resize buffer)\n        const output = buffer[i]!;\n        buffer[i] = sample + output * feedbackGain;\n        i = (i + 1) % delaySamples;\n        return output;\n    }\n}\n\n/** Shimmer effect. Adds a random amount to the value, but only if the value has changed. The shimmer amount is relative to the value (0.05 = 5%). */\nexport const shimmerer = (_: any) => {\n    var oldValue = 0, out = 0;\n    return (_: any, value: number, shimmerAmount = .05) => {\n        if (oldValue !== value) {\n            out = value + (Math.random() - .5) * shimmerAmount * value;\n            oldValue = value;\n        }\n        return out;\n    }\n}\n\n\n// MAIN EXPORTS OBJECT\nexport const builtinNodes: Record<string, NodeImplFactory> = {\n    gain: gainMixer,\n    ringmod: gainMixer, // ring modulator is just a multiplicative gain mixer lol\n    add: summingMixer,\n    wave: zzfxOscillator,\n    filter: biquadFilter,\n    bitcrush: bitcrusher,\n    delay: delay,\n    shimmer: shimmerer,\n};\n", "import { isNegativeZero, isNumber } from \"./utils\";\n\ninterface JSONArray<T> extends Array<JSONValue<T>> { }\ninterface JSONObject<T> { [key: string]: JSONValue<T>; }\ntype JSONValue<T = never> = T | string | number | boolean | null | JSONArray<T> | JSONObject<T>;\nexport function minparse(str: string): JSONValue<undefined> {\n    str = str\n        .replace(/([,\\[\\{}])([=>.]?[a-z_]+?)([,:\\]\\}])/ig, \"$1\\\"$2\\\"$3\")\n        .replace(/([,\\[])!0([,\\]])/g, \"$1true$2\")\n        .replace(/([,\\[])!1([,\\]])/g, \"$1false$2\")\n        .replace(/\\[,/g, \"[null,\")\n        .replace(/,,\\]/g, \",null]\")\n        .replace(/,\\s*(?=[,\\]])/g, \",null\")\n        .replace(/([\\[,]-?)(?=\\.)/g, \"$10\")\n        .replace(/-\\./g, \"-0.\");\n    console.log(\"preprocessed JSON string:\", str);\n\n    return JSON.parse(str, (_, value) => value === null ? undefined : value);\n}\nconst NEGATIVE_ZERO_SENTINEL = \"____NZ\"\nconst stringify = JSON.stringify;\nconst NEGATIVE_ZERO_SENTINEL_REGEXP = new RegExp(stringify(NEGATIVE_ZERO_SENTINEL), \"g\");\nexport function minstringify(x: JSONValue<undefined>): string {\n    return stringify(x, (_, v) => isNumber(v) && isNegativeZero(v) ? NEGATIVE_ZERO_SENTINEL : v)\n        .replace(/true/g, \"!0\")\n        .replace(/false/g, \"!1\")\n        .replace(/,null\\]/g, \",,]\")\n        .replace(/\\[null,/g, \"[,\")\n        .replace(/,null(?=[,\\]])/g, \",\")\n        .replace(/([\\[,]-?)0(?=\\.)/g, \"$1\")\n        .replace(/-0\\./g, \"-.\")\n        .replace(NEGATIVE_ZERO_SENTINEL_REGEXP, \"-0\")\n        .replace(/([,\\[\\{])\"([=>.]?[a-z_]+?)\"([,:\\}])/ig, \"$1$2$3\");\n}\n", "import { standardChannel, type Channel } from \"./channel\";\nimport { type CompiledInstrument } from \"./types\";\nimport { isInputRef, isNodeName, isNotNegative, isNumber, isRef, mapObject } from \"./utils\";\n\nexport const buildSamples = (instrument: CompiledInstrument, channels: Record<string, Channel>, duration: number, sampleRate = 44100): number[] => {\n    const samples: number[] = [],\n        [instructions, nodeFactories] = instrument,\n        registers: Record<string, number> = {},\n        nodes = nodeFactories.map(([factory, args]) => factory(sampleRate, ...args)),\n        numSamples = duration * sampleRate,\n        // TODO: switch this for different kinds of channel once those are implemented\n        inputChannels = mapObject(channels, channel => standardChannel(sampleRate, channel)),\n        stack: number[] = [];\n    var channelValues: Record<string, number> = {};\n    var i, sampleNo;\n    for (sampleNo = 0; sampleNo < numSamples; sampleNo++) {\n        // do the input channels\n        channelValues = {};\n        for (i of Object.keys(inputChannels)) {\n            channelValues[i] = inputChannels[i]!(sampleNo, channelValues);\n        }\n        // do the node graph\n        stack.length = 0;\n        for (i = 0; i < instructions.length; i++) {\n            const inst = instructions[i]!;\n            if (isNodeName(inst)) {\n                registers[inst.slice(1)] = stack.at(-1)!;\n            } else if (isRef(inst)) {\n                stack.push(registers[inst.slice(1)] ?? 0);\n            } else if (isInputRef(inst)) {\n                stack.push(channelValues[inst.slice(1)] ?? 0);\n            } else {\n                if (inst.length === 1)\n                    stack.push(inst[0]);\n                else {\n                    const [nodeIndex, numArgs] = inst;\n                    if (isNotNegative(nodeIndex))\n                        stack.push(nodes[nodeIndex]!(sampleNo, ...stack.splice(stack.length - numArgs!, numArgs)));\n                    else\n                        stack.push(channelValues[-nodeIndex]! ?? 0);\n                }\n            }\n        }\n        const sample = stack.pop()!;\n        if (!isNumber(sample))\n            throw new Error(`got NaN sample at sampleNo=${sampleNo}`);\n        samples.push(sample);\n    }\n    return samples;\n}\n\nexport const toBufferNode = (samples: number[][] | number[], audioCtx: AudioContext, sampleRate = 44100): AudioBufferSourceNode => {\n    const normSamples = isNumber(samples[0]) ? [samples as number[]] : samples as number[][],\n        buffer = audioCtx.createBuffer(normSamples.length, normSamples[0]!.length, sampleRate),\n        source = audioCtx.createBufferSource();\n    normSamples.map((d, i) => buffer.getChannelData(i).set(d));\n    source.buffer = buffer;\n    return source;\n}\n"],
  "mappings": "AAEO,IAAMA,EAAY,CAAOC,EAAwBC,IACpD,OAAO,YAAY,OAAO,QAAQD,CAAG,EAAE,IAAI,CAAC,CAACE,EAAKC,CAAK,IAAM,CAACD,EAAKD,EAAKE,EAAOD,CAAG,CAAC,CAAC,CAAC,EAEnFE,GAAUC,GAAW,OAAOA,EACrBC,EAAK,CAACC,EAAWN,EAAwBG,KAAYC,GAAWJ,EAAKI,CAAC,IAAME,EAC5EC,EAAWF,EAAG,QAAQ,EACtBG,EAAcH,EAAG,WAAW,EAC5BI,EAAWJ,EAAG,QAAQ,EACtBK,EAAUN,GAAsBA,IAAM,KACtCO,EAAWP,GAAsBA,EAAE,SAAW,EAC9CQ,EAAkBR,GAAuB,OAAO,GAAGA,EAAG,EAAE,EACxDS,EAAiBT,GAAeA,EAAI,GAAQA,IAAM,GAAM,CAACQ,EAAeR,CAAC,EAIzEU,EAAM,CAAoDV,KAASW,IAA+CA,EAAM,KAAKC,GAAKA,EAAEZ,CAAC,CAAC,EACtIa,EAAU,MAAM,QAChBC,EAAWb,EAAG,QAAQ,EAStBc,EAAcf,GAAoDU,EAAIV,EAAGM,EAAQF,EAAaD,CAAQ,GAAME,EAASL,CAAC,GAAK,EAAEgB,EAAMhB,CAAC,GAAKiB,EAAWjB,CAAC,GAAKkB,EAAWlB,CAAC,GACtKmB,EAAUnB,GACnBU,EAAIV,EAAGK,EAAUF,EAAUC,EAAaE,CAAM,EACxC,GACAO,EAAQb,CAAC,GAAKK,EAASL,EAAE,CAAC,CAAC,EACtBoB,EAAYpB,CAAC,EAAImB,EAAOE,EAAgBrB,CAAC,CAAC,EAAI,GAC9Ca,EAAQb,EAAE,CAAC,CAAC,GAAK,CAACO,EAAQP,EAAE,CAAC,CAAC,GAAKK,EAASL,EAAE,CAAC,EAAE,CAAC,CAAC,EAE5DsB,EAAkCC,GAAgBvB,GACpDK,EAASL,CAAC,GAAKA,EAAE,WAAWuB,CAAO,EAC1BP,EAAQM,EAAa,GAAG,EACxBL,EAAaK,EAAa,GAAG,EAC7BJ,EAAaI,EAAa,GAAG,EAC7BF,EAAepB,GAAsCa,EAAQb,CAAC,GAAKiB,EAAWjB,EAAE,CAAC,CAAC,EAClFwB,EAAexB,GAAiCoB,EAAYpB,CAAC,EAAIA,EAAE,CAAC,EAAI,OACxEqB,EAAmBrB,GAAkBoB,EAAYpB,CAAC,EAAIA,EAAE,MAAM,CAAC,EAAIA,EAG1EyB,EAAyC,CAAC,EACnCC,EAA4BC,IACrCF,EAAeE,CAAM,GAAKF,EAAeE,CAAM,GAAK,GAAK,EAClD,GAAGA,CAAM,GAAGF,EAAeE,CAAM,CAAC,IC5BtC,IAAMC,GAAoB,CAACC,EAAgBC,IAAmE,CACjH,IAAMC,EAA8B,CAAC,EAC/BC,EAAmB,CAAC,EACpBC,EAAQC,GAAmB,CAC7B,IAAMC,EAAWC,EAAYF,CAAI,EAC3BG,EAAeC,EAAgBJ,CAAI,EACzC,QAASK,EAAI,EAAGA,EAAIF,EAAa,OAAQE,IAAK,CAC1C,IAAMC,EAAQH,EAAaE,CAAC,EACxBE,EAAOD,CAAK,EACZP,EAAKO,CAAK,EACHE,EAAIF,EAAOG,EAAYC,EAAYC,CAAK,EAC/Cd,EAAa,KAAKS,CAAK,EAChBM,EAAWN,CAAK,GACvBT,EAAa,KAAK,CAACS,CAAK,CAAC,CAEjC,CAEAT,EAAa,KAAK,CAACC,EAAM,OAAQK,EAAa,OAAS,CAAC,CAAC,EACzD,GAAM,CAACU,EAAUC,CAAQ,EAAIC,EAAQZ,EAAa,CAAC,CAAC,GAAK,CAACa,EAAQb,EAAa,CAAC,CAAC,EAAI,CAACA,EAAa,CAAC,EAAE,CAAC,EAAGA,EAAa,CAAC,EAAE,MAAM,CAAC,CAAC,EAAI,CAACA,EAAa,CAAC,EAAG,CAAC,CAAC,EACpJc,EAAeC,EAASL,CAAQ,GAAKjB,EAAUiB,CAAQ,IAAQ,IAAM,CAAE,MAAM,IAAI,MAAM,uBAAyBA,CAAQ,CAAG,GACjIf,EAAM,KAAK,CAACmB,EAAaH,CAAQ,CAAC,EAC9Bb,IAAa,QACbJ,EAAa,KAAKI,CAAQ,CAElC,EACA,OAAAF,EAAKJ,CAAI,EACF,CAACE,EAAcC,CAAK,CAC/B,EAGMqB,GAAS,OACFC,GAAsB,CAACC,EAAgCzB,IAAoD,CACpH,GAAM,CAACC,EAAcyB,CAAa,EAAID,EAChCnB,EAAeqB,GAAqC,CACtD,QAASC,KAAK,OAAO,KAAK5B,CAAS,EAC/B,GAAIA,EAAU4B,CAAC,IAAMD,EAAS,OAAOC,EAEzC,OAAOD,EAAQ,MAAQ,SAC3B,EACME,EAAYH,EAAc,IAAI,CAAC,CAACC,EAASG,CAAI,EAAGC,IAAU,QAAQzB,EAAYqB,CAAO,CAAC,IAAIG,EAAK,KAAK,IAAI,CAAC,YAAYC,CAAK,GAAG,EAC7HC,EAAmB,CAAC,EAC1B,IAAIvB,EAAIR,EAAa,OAAS,EAC9B,IAAMgC,EAAU,CAACC,EAAeC,IAAiB,CAC7CH,EAAO,KAAK,GAAGT,GAAO,OAAOW,CAAK,CAAC,GAAGC,CAAI,EAAE,CAChD,EACMhC,EAAQ+B,GAAkB,CAC5B,GAAIzB,EAAI,EAAG,OACX,IAAM2B,EAAOnC,EAAaQ,GAAG,EAC7B,GAAIU,EAAQiB,CAAI,EACZ,GAAIA,EAAK,SAAW,EAChBH,EAAQC,EAAO,iBAAiB,OAAOE,EAAK,CAAC,CAAC,CAAC,EAAE,MAC9C,CACH,GAAM,CAACC,EAAWC,CAAO,EAAIF,EAC7BH,EAAQC,EAAO,GAAGL,EAAUQ,CAAS,CAAC,SAASC,CAAO,EAAE,EACxD,QAASC,EAAI,EAAGA,EAAID,EAAUC,IAC1BpC,EAAK+B,EAAQ,CAAC,CACtB,MACOZ,EAASc,CAAI,IAChBrB,EAAMqB,CAAI,EACVH,EAAQC,EAAO,iBAAiBE,EAAK,MAAM,CAAC,CAAC,EAAE,EACxCtB,EAAWsB,CAAI,EACtBH,EAAQC,EAAO,sBAAsBE,EAAK,MAAM,CAAC,CAAC,EAAE,EAC7CvB,EAAWuB,CAAI,IACtBH,EAAQC,EAAO,kBAAkBE,EAAK,MAAM,CAAC,CAAC,EAAE,EAChDjC,EAAK+B,CAAK,GAGtB,EACA,OAAA/B,EAAK,CAAC,EACC6B,EAAO,KAAK;AAAA,CAAI,EAAI;AAAA;AAAA,CAC/B,ECxFO,IAAMQ,EAAc,CAACC,EAAWC,IAA+C,CAClF,IAAIC,EACJ,OAAOC,EAAIH,EAAMI,EAAUC,EAAUC,EAAaC,CAAM,EAClDP,EACCQ,EAAQR,CAAI,EAETI,EAASJ,EAAK,CAAC,CAAC,GAAKA,EAAK,CAAC,IAAKC,EAC3BE,EAAID,EAAOD,EAAOD,EAAK,CAAC,CAAC,EAAG,GAAGA,EAAK,MAAM,CAAC,CAAC,EAAGQ,EAASC,CAAQ,EAAIV,EAAYG,EAAMD,CAAM,EAAIC,EACjGF,EAAK,IAAIU,GAAMX,EAAYW,EAAIT,CAAM,CAAC,EAH1CU,EAAUX,EAAMY,GAAKb,EAAYa,EAAGX,CAAM,CAAC,CAIzD,ECPO,IAAMY,GAAU,CAACC,EAAuBC,EAAS,EAAGC,EAAS,EAAGC,EAAS,EAAGC,EAAO,EAAGC,EAAM,EAAIJ,EAAQK,EAAY,IAAgB,CACvI,IAAMC,EAAyB,CAAC,KAAK,EAC/BC,EAAWR,EAAYM,CAAS,EACtC,QAASG,EAAI,EAAGA,GAAKR,EAAQQ,IAAK,CAC9B,IAAMC,EAAkBP,EAASD,GAAU,GAAKO,EAAI,IAAOR,EAAS,GAAM,GAAK,IACzEU,EAAe,KAAK,IAAI,EAAGD,EAAkB,EAAE,EACrDH,EAAIE,CAAC,EAAIT,EAAY,KAAKM,EAAWM,EAASJ,CAAQ,EAAIA,EAAWG,EAAe,CAAC,OAAQH,EAAUG,CAAY,CAAC,EAChHF,EAAI,GAAKL,IAAS,IAAGG,EAAIE,CAAC,EAAI,CAAC,OAAQL,EAAMG,EAAIE,CAAC,CAAC,EAC3D,CACA,OAAOJ,IAAQ,EAAI,CAAC,OAAQA,EAAKE,CAAe,EAAIA,CACxD,EAEaM,GAAa,CAACC,EAAiBC,EAAmBC,EAA8B,GAAIC,EAAc,KAAoB,CAC/H,IAAMC,EAAWC,EAAO,mBAAmB,EACrCC,EAAUH,EAAc,CAAC,EAAI,CAACC,CAAQ,EACtCG,EAASJ,EAAc,CAACC,CAAQ,EAAI,CAAC,EAC3C,MAAO,CAAC,GAAGE,EAAS,MAAO,CAAC,GAAGC,EAAQ,MAAOP,CAAK,EAAG,CAAC,OAAQE,EAAc,CAAC,CAAC,QAASD,CAAS,EAAG,IAAMG,EAAS,MAAM,CAAC,CAAC,CAAC,CAAC,CACjI,EAOaI,GAA8D,CACvE,OAAQvB,GACR,WAAYc,EAChB,EC9BA,IAAMU,GAAwB,CAACC,EAAWC,EAAY,EAAGC,EAAWC,EAAWC,IAC3EA,EAAI,EAAKH,EAAI,EAAKE,GAAKD,EAAIC,KAAOC,EAAIJ,GAAKI,IAAM,CAACH,EAAMC,GAAKC,EAAID,IAAMF,EAAII,IAAMH,EAAME,EAKrFE,EAAe,CAACC,EAAkBC,IAAiE,CACrG,IAAMC,EAAM,CAAC,EAAGC,EAAK,CAAC,EAAGC,EAAK,CAAC,EAAGC,EAAO,CAAC,EAE1C,QADIX,EAAI,EACCY,EAAI,EAAGA,EAAIN,EAAQ,OAAQM,GAAK,EAAG,CACxC,IAAMC,GAAOP,EAAQM,CAAC,GAAK,GAAKL,EAChCC,EAAI,KAAKK,CAAE,EACXJ,EAAG,KAAKT,CAAC,EACTU,EAAG,KAAKJ,EAAQM,EAAI,CAAC,GAAK,CAAC,EAC3BD,EAAK,KAAKL,EAAQM,EAAI,CAAC,GAAK,CAAC,EAC7BZ,GAAKa,CACT,CACA,MAAO,CAACL,EAAKC,EAAIC,EAAIC,CAAI,CAC7B,EAEaG,EAAkB,CAACP,EAAoBD,IAAkC,CAClF,GAAM,CAACE,EAAKC,EAAIC,EAAIC,CAAI,EAAIN,EAAaC,EAASC,CAAU,EAC5D,IAAIK,EAAI,EACR,OAAQG,GAAqB,CACzB,GAAIA,GAAYN,EAAG,GAAG,EAAE,EAAKD,EAAI,GAAG,EAAE,EAAI,MAAO,GACjD,KAAOO,EAAWN,EAAGG,CAAC,GAAIA,IAC1B,KAAOG,EAAWN,EAAGG,CAAC,EAAKJ,EAAII,CAAC,GAAIA,IACpC,OAAOb,GAAsBgB,EAAWN,EAAGG,CAAC,EAAIF,EAAGE,CAAC,EAAGD,EAAKC,EAAI,CAAC,GAAK,EAAGD,EAAKC,CAAC,EAAIJ,EAAII,CAAC,CAAE,CAC9F,CACJ,EAEaI,GAAkB,CAACC,EAAS,EAAGC,EAAQ,EAAGC,EAAU,EAAGC,EAAa,EAAGC,EAAU,GAAIC,EAAc,EAAGC,EAAW,IAC1H,CAAC,GAAIJ,EAAU,EAAI,CAAC,CAAE,CAACG,EAAaC,CAAQ,EAAI,CAAC,EAAIN,EAAQ,CAAE,EAAGC,EAAO,CAAEE,EAAYD,EAAS,CAAEC,EAAYC,CAAO,EAE5GG,GAAW,CAACjB,KAAuBkB,IACrCX,EAAgBP,EAAYS,GAAgB,GAAGS,CAAM,CAAC,EAGpDC,GAAmBpB,GAA6B,CACzD,GAAM,CAACE,EAAKC,CAAE,EAAIJ,EAAaC,EAAS,CAAC,EACzC,OAAOG,EAAG,GAAG,EAAE,EAAKD,EAAI,GAAG,EAAE,CACjC,EC3CO,IAAMmB,GAAK,KAAK,GACVC,EAAM,EAAID,GACjBE,GAAQ,CAACC,EAAWC,EAAaC,IAAgB,KAAK,IAAI,KAAK,IAAIF,EAAGE,CAAG,EAAGD,CAAG,EACxEE,EAAM,KAAK,IACXC,EAAM,KAAK,IACXC,EAAM,KAAK,KACXC,EAAM,KAAK,IACXC,EAAOP,GAAcD,GAAM,KAAK,IAAIC,CAAC,EAAG,GAAI,CAAC,EAC7CQ,EAAOR,GAAc,GAAK,EAAIA,EAAIF,EAAM,EAAI,GAAK,EACjDW,EAAOT,GAAc,EAAI,EAAI,KAAK,IAAI,KAAK,MAAMA,EAAIF,CAAG,EAAIE,EAAIF,CAAG,EACnEY,EAAUV,GAAcG,EAAIH,GAAK,CAAC,EAClCW,GAAUX,GAAcG,EAAIH,GAAK,CAAC,ECKxC,IAAMY,GAAW,CAACC,EAAWC,IAA0B,IAAMA,EAGvDC,GAAe,IAAgB,CAACF,KAAMG,IAASA,EAAK,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAE7EC,GAAY,IAAgB,CAACN,KAAMG,IAASA,EAAK,OAAO,CAACC,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAK1EE,GAAkBC,GAAuB,CAClD,IAAIC,EAAQ,EACZ,MAAO,CAACC,EAAkBC,EAAmBC,EAAeC,EAAa,EAAGC,EAAQ,EAAGC,EAAc,IAAM,CACvG,IAAMC,GAAUJ,EAAQ,EAAIK,EAASL,EAAQ,EAAIM,EAAMN,EAAQ,EAAIO,EAAMP,EAAQQ,EAAMC,GAAKN,EAAcO,GAAOb,GAAUE,EAAYW,EAAMd,GAAe,EAAIM,EAAQS,GAAOb,CAAQ,GAAG,EAC1L,OAAOc,EAAIR,CAAM,EAAKS,EAAIT,CAAM,GAAKH,CACzC,CACJ,EAKaa,GAAe,CAAClB,EAAoBmB,EAAU,IAAM,CAC7D,IAAIC,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAAGC,EAAK,EACjC,MAAO,CAAC/B,EAAQgC,EAAgBhB,IAAmB,CAE/C,IAAIiB,EAAIX,EAAMG,EAAIO,CAAM,EAAI,EAAIxB,EAC5B0B,EAAOC,EAAIF,CAAC,EAAGG,EAAQf,EAAIY,CAAC,EAAI,EAAIN,EACpCU,EAAK,EAAID,EAAOE,EAAK,GAAKJ,EAAOG,EAAIE,GAAM,EAAIH,GAASC,EACxDG,GAAM,EAAIhB,EAAIQ,CAAM,EAAIE,GAAQ,EAAIG,EACpCI,EAAK,EAAEjB,EAAIQ,CAAM,EAAIE,GAAQG,EAAIK,EAAKF,EAC1C,OAAOT,EAAKW,EAAKd,EAAKa,GAAMb,EAAKC,GAAMW,GAAMX,EAAKb,GAAUuB,EAAKT,EAAKQ,GAAMR,EAAKC,EAErF,CACJ,EAGaY,GAAa,IAAM,CAC5B,IAAIlC,EAAQ,EAAGmC,EAAY,EAC3B,MAAO,CAAC5C,EAAQ6C,EAAuB,EAAG7B,KAClC,EAAEP,GAASoC,IACXpC,EAAQ,EACRmC,EAAY5B,GAET4B,EAEf,EAIaE,GAAQ,CAACtC,EAAoBuC,IAAsB,CAC5D,GAAIA,IAAc,EAAG,MAAO,CAAC/C,EAAQgB,IAAmBA,EACxD,IAAMgC,EAAgBxC,EAAauC,EAAa,EAC1CE,EAAmB,IAAI,MAAMD,CAAY,EAAE,KAAK,CAAC,EACvD,IAAIE,EAAI,EACR,MAAO,CAAClD,EAAQgB,EAAgBmC,EAAe,IAAM,CAEjD,IAAMC,EAASH,EAAOC,CAAC,EACvB,OAAAD,EAAOC,CAAC,EAAIlC,EAASoC,EAASD,EAC9BD,GAAKA,EAAI,GAAKF,EACPI,CACX,CACJ,EAGaC,GAAarD,GAAW,CACjC,IAAIsD,EAAW,EAAGC,EAAM,EACxB,MAAO,CAACvD,EAAQwD,EAAeC,EAAgB,OACvCH,IAAaE,IACbD,EAAMC,GAAS,KAAK,OAAO,EAAI,IAAMC,EAAgBD,EACrDF,EAAWE,GAERD,EAEf,EAIaG,GAAgD,CACzD,KAAMpD,GACN,QAASA,GACT,IAAKJ,GACL,KAAMK,GACN,OAAQmB,GACR,SAAUiB,GACV,MAAOG,GACP,QAASO,EACb,ECjGO,SAASM,GAASC,EAAmC,CACxD,OAAAA,EAAMA,EACD,QAAQ,yCAA0C,UAAY,EAC9D,QAAQ,oBAAqB,UAAU,EACvC,QAAQ,oBAAqB,WAAW,EACxC,QAAQ,OAAQ,QAAQ,EACxB,QAAQ,QAAS,QAAQ,EACzB,QAAQ,iBAAkB,OAAO,EACjC,QAAQ,mBAAoB,KAAK,EACjC,QAAQ,OAAQ,KAAK,EAC1B,QAAQ,IAAI,4BAA6BA,CAAG,EAErC,KAAK,MAAMA,EAAK,CAACC,EAAGC,IAAUA,IAAU,KAAO,OAAYA,CAAK,CAC3E,CACA,IAAMC,GAAyB,SACzBC,GAAY,KAAK,UACjBC,GAAgC,IAAI,OAAOD,GAAUD,EAAsB,EAAG,GAAG,EAChF,SAASG,GAAaC,EAAiC,CAC1D,OAAOH,GAAUG,EAAG,CAACN,EAAGO,IAAMC,EAASD,CAAC,GAAKE,EAAeF,CAAC,EAAIL,GAAyBK,CAAC,EACtF,QAAQ,QAAS,IAAI,EACrB,QAAQ,SAAU,IAAI,EACtB,QAAQ,WAAY,KAAK,EACzB,QAAQ,WAAY,IAAI,EACxB,QAAQ,kBAAmB,GAAG,EAC9B,QAAQ,oBAAqB,IAAI,EACjC,QAAQ,QAAS,IAAI,EACrB,QAAQH,GAA+B,IAAI,EAC3C,QAAQ,wCAAyC,QAAQ,CAClE,CC7BO,IAAMM,GAAe,CAACC,EAAgCC,EAAmCC,EAAkBC,EAAa,QAAoB,CAC/I,IAAMC,EAAoB,CAAC,EACvB,CAACC,EAAcC,CAAa,EAAIN,EAChCO,EAAoC,CAAC,EACrCC,EAAQF,EAAc,IAAI,CAAC,CAACG,EAASC,CAAI,IAAMD,EAAQN,EAAY,GAAGO,CAAI,CAAC,EAC3EC,EAAaT,EAAWC,EAExBS,EAAgBC,EAAUZ,EAAUa,GAAWC,EAAgBZ,EAAYW,CAAO,CAAC,EACnFE,EAAkB,CAAC,EACvB,IAAIC,EAAwC,CAAC,EACzCC,EAAGC,EACP,IAAKA,EAAW,EAAGA,EAAWR,EAAYQ,IAAY,CAElDF,EAAgB,CAAC,EACjB,IAAKC,KAAK,OAAO,KAAKN,CAAa,EAC/BK,EAAcC,CAAC,EAAIN,EAAcM,CAAC,EAAGC,EAAUF,CAAa,EAIhE,IADAD,EAAM,OAAS,EACVE,EAAI,EAAGA,EAAIb,EAAa,OAAQa,IAAK,CACtC,IAAME,EAAOf,EAAaa,CAAC,EAC3B,GAAIG,EAAWD,CAAI,EACfb,EAAUa,EAAK,MAAM,CAAC,CAAC,EAAIJ,EAAM,GAAG,EAAE,UAC/BM,EAAMF,CAAI,EACjBJ,EAAM,KAAKT,EAAUa,EAAK,MAAM,CAAC,CAAC,GAAK,CAAC,UACjCG,EAAWH,CAAI,EACtBJ,EAAM,KAAKC,EAAcG,EAAK,MAAM,CAAC,CAAC,GAAK,CAAC,UAExCA,EAAK,SAAW,EAChBJ,EAAM,KAAKI,EAAK,CAAC,CAAC,MACjB,CACD,GAAM,CAACI,EAAWC,CAAO,EAAIL,EACzBM,EAAcF,CAAS,EACvBR,EAAM,KAAKR,EAAMgB,CAAS,EAAGL,EAAU,GAAGH,EAAM,OAAOA,EAAM,OAASS,EAAUA,CAAO,CAAC,CAAC,EAEzFT,EAAM,KAAKC,EAAc,CAACO,CAAS,GAAM,CAAC,CAClD,CAER,CACA,IAAMG,EAASX,EAAM,IAAI,EACzB,GAAI,CAACY,EAASD,CAAM,EAChB,MAAM,IAAI,MAAM,8BAA8BR,CAAQ,EAAE,EAC5Df,EAAQ,KAAKuB,CAAM,CACvB,CACA,OAAOvB,CACX,EAEayB,GAAe,CAACzB,EAAgC0B,EAAwB3B,EAAa,QAAiC,CAC/H,IAAM4B,EAAcH,EAASxB,EAAQ,CAAC,CAAC,EAAI,CAACA,CAAmB,EAAIA,EAC/D4B,EAASF,EAAS,aAAaC,EAAY,OAAQA,EAAY,CAAC,EAAG,OAAQ5B,CAAU,EACrF8B,EAASH,EAAS,mBAAmB,EACzC,OAAAC,EAAY,IAAI,CAACG,EAAGhB,IAAMc,EAAO,eAAed,CAAC,EAAE,IAAIgB,CAAC,CAAC,EACzDD,EAAO,OAASD,EACTC,CACX",
  "names": ["mapObject", "obj", "func", "key", "value", "typeOf", "x", "is", "t", "isNumber", "isUndefined", "isString", "isNull", "isEmpty", "isNegativeZero", "isNotNegative", "any", "funcs", "f", "isArray", "isObject", "isConstant", "isRef", "isNodeName", "isInputRef", "isNode", "isNamedNode", "getNodeContents", "isTypeString", "starter", "getNodeName", "gensymCounters", "gensym", "prefix", "compileInstrument", "tree", "nodeTypes", "instructions", "nodes", "walk", "node", "nodeName", "getNodeName", "nodeContents", "getNodeContents", "i", "curEl", "isNode", "any", "isNodeName", "isInputRef", "isRef", "isConstant", "nodeType", "nodeArgs", "isArray", "isEmpty", "nodeFactory", "isString", "INDENT", "debugDumpInstrument", "instrument", "nodeFactories", "factory", "k", "nodeNames", "args", "index", "output", "addLine", "depth", "line", "inst", "nodeIndex", "numArgs", "j", "macroexpand", "tree", "macros", "temp", "any", "isString", "isNumber", "isUndefined", "isNull", "isArray", "isObject", "el", "mapObject", "v", "unisons", "oscTemplate", "voices", "spread", "offset", "sign", "amp", "freqIndex", "out", "baseFreq", "i", "offsetSemitones", "offsetFactor", "isNumber", "combFilter", "input", "delayTime", "feedbackGain", "feedforward", "linkName", "gensym", "outName", "inName", "builtinMacros", "interpolationFunction", "t", "p", "a", "b", "d", "splitTimings", "channel", "sampleRate", "dts", "ts", "ps", "vals", "i", "dt", "standardChannel", "sampleNo", "makeADSRChannel", "attack", "decay", "sustain", "sustainVol", "release", "gateChannel", "behavior", "adsrNode", "params", "channelDuration", "PI", "TAU", "clamp", "x", "min", "max", "sin", "cos", "sgn", "abs", "tan", "saw", "tri", "noise3", "noise5", "constant", "_", "num", "summingMixer", "args", "a", "b", "gainMixer", "zzfxOscillator", "sampleRate", "phase", "sampleNo", "frequency", "shape", "shapeCurve", "noise", "phaseOffset", "sample", "noise3", "tan", "saw", "tri", "sin", "TAU", "noise5", "sgn", "abs", "biquadFilter", "quality", "x2", "x1", "y2", "y1", "filter", "w", "cos_", "cos", "alpha", "a0", "a1", "a2", "b0", "b1", "b2", "bitcrusher", "curSample", "crushSamples", "delay", "delayTime", "delaySamples", "buffer", "i", "feedbackGain", "output", "shimmerer", "oldValue", "out", "value", "shimmerAmount", "builtinNodes", "minparse", "str", "_", "value", "NEGATIVE_ZERO_SENTINEL", "stringify", "NEGATIVE_ZERO_SENTINEL_REGEXP", "minstringify", "x", "v", "isNumber", "isNegativeZero", "buildSamples", "instrument", "channels", "duration", "sampleRate", "samples", "instructions", "nodeFactories", "registers", "nodes", "factory", "args", "numSamples", "inputChannels", "mapObject", "channel", "standardChannel", "stack", "channelValues", "i", "sampleNo", "inst", "isNodeName", "isRef", "isInputRef", "nodeIndex", "numArgs", "isNotNegative", "sample", "isNumber", "toBufferNode", "audioCtx", "normSamples", "buffer", "source", "d"]
}
