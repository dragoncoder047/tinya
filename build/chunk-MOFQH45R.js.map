{
  "version": 3,
  "sources": ["../src/lib/index.syd", "../src/lib/nodes/effects.ts", "../src/lib/nodes/generators.ts", "../src/lib/nodes/logic.ts", "../src/lib/index.ts", "../src/runtime/synthProxy.ts", "../src/runtime/disassemble.ts", "../src/index.ts"],
  "sourcesContent": ["import { LocationTrace, DefaultPlaceholder, Mapping, ParameterDescriptor, Name, InterpolatedValue, Call, Block, Value, Conditional, Template, Definition, Assignment, BinaryOp } from \"syd\";\n\nexport const sources = /* @__PURE__ */ {\n    \"index.syd\":\n    [\n        \"#!include \\\"./macros/control.syd\\\";\",\n        \"#!include \\\"./macros/functions.syd\\\";\",\n        \"#!include \\\"./macros/effects.syd\\\";\",\n        \"\"\n    ].join(\"\\n\"),\n    \"control.syd\":\n    [\n        \"// basic control flow stuff\",\n        \"\",\n        \"/** while - repeats body while cond is true */\",\n        \"@while(@cond, @body) :- {\",\n        \"    &cond\",\n        \"        ? (&body;\",\n        \"            while(&cond, &body))\",\n        \"        : 0\",\n        \"};\",\n        \"\",\n        \"/**\",\n        \" * for - repeats body with var running through min-max\",\n        \" * (equivalent to `for (var = min; var < max; var += step) {body}` in JS)\",\n        \" */\",\n        \"@for(@var, min, max, @body, step=1) :- {\",\n        \"    &var = &min;\",\n        \"    while(&var < &max, (\",\n        \"        &body;\",\n        \"        &var += &step\",\n        \"    ))\",\n        \"};\",\n        \"\",\n        \"/** quotes the expression and does NOT evaluate it - returns the AST node verbatim */\",\n        \"quote(@code) :- code;\",\n        \"\",\n        \"/** forces the code to be expanded in the caller's local scope */\",\n        \"@expand(code) :- code;\",\n        \"\"\n    ].join(\"\\n\"),\n    \"functions.syd\":\n    [\n        \"\"\n    ].join(\"\\n\"),\n    \"effects.syd\":\n    [\n        \"\"\n    ].join(\"\\n\")\n};\n\nconst     \n    _str0unknown = \"unknown\", \n    _str1while = \"while\", \n    _str2cond = \"cond\", \n    _str3controlsyd = \"control.syd\", \n    _str4body = \"body\", \n    _str5for = \"for\", \n    _str6var = \"var\", \n    _str7min = \"min\", \n    _str8max = \"max\", \n    _str9step = \"step\", \n    _str10 = \"<\", \n    _str11 = \"+\", \n    _str12quote = \"quote\", \n    _str13code = \"code\", \n    _str14expand = \"expand\", \n    _str15indexsyd = \"index.syd\";\n\nconst _effects0 = new DefaultPlaceholder(new LocationTrace(0, 0, _str0unknown))\n\nconst _functions1 = new DefaultPlaceholder(new LocationTrace(0, 0, _str0unknown))\n\nconst _control2 = new Block(new LocationTrace(3, 0, _str3controlsyd),\n    [\n        new Definition(new LocationTrace(3, 1, _str3controlsyd),\n            _str1while,\n            true,\n            [\n                new ParameterDescriptor(new LocationTrace(3, 8, _str3controlsyd),\n                    _str2cond,\n                    new Mapping(new LocationTrace(3, 8, _str3controlsyd),\n                        []),\n                    new DefaultPlaceholder(new LocationTrace(3, 8, _str3controlsyd)),\n                    true),\n                new ParameterDescriptor(new LocationTrace(3, 15, _str3controlsyd),\n                    _str4body,\n                    new Mapping(new LocationTrace(3, 15, _str3controlsyd),\n                        []),\n                    new DefaultPlaceholder(new LocationTrace(3, 15, _str3controlsyd)),\n                    true)],\n            new Template(new LocationTrace(3, 24, _str3controlsyd),\n                new Conditional(new LocationTrace(5, 8, _str3controlsyd),\n                    new InterpolatedValue(new LocationTrace(4, 4, _str3controlsyd),\n                        new Name(new LocationTrace(4, 5, _str3controlsyd),\n                            _str2cond)),\n                    new Block(new LocationTrace(5, 12, _str3controlsyd),\n                        [\n                            new InterpolatedValue(new LocationTrace(5, 11, _str3controlsyd),\n                                new Name(new LocationTrace(5, 12, _str3controlsyd),\n                                    _str4body)),\n                            new Call(new LocationTrace(6, 12, _str3controlsyd),\n                                _str1while,\n                                [\n                                    new InterpolatedValue(new LocationTrace(6, 18, _str3controlsyd),\n                                        new Name(new LocationTrace(6, 19, _str3controlsyd),\n                                            _str2cond)),\n                                    new InterpolatedValue(new LocationTrace(6, 25, _str3controlsyd),\n                                        new Name(new LocationTrace(6, 26, _str3controlsyd),\n                                            _str4body))])]),\n                    new Value(new LocationTrace(7, 10, _str3controlsyd),\n                        0)))),\n        new Definition(new LocationTrace(14, 1, _str3controlsyd),\n            _str5for,\n            true,\n            [\n                new ParameterDescriptor(new LocationTrace(14, 6, _str3controlsyd),\n                    _str6var,\n                    new Mapping(new LocationTrace(14, 6, _str3controlsyd),\n                        []),\n                    new DefaultPlaceholder(new LocationTrace(14, 6, _str3controlsyd)),\n                    true),\n                new Name(new LocationTrace(14, 11, _str3controlsyd),\n                    _str7min),\n                new Name(new LocationTrace(14, 16, _str3controlsyd),\n                    _str8max),\n                new ParameterDescriptor(new LocationTrace(14, 22, _str3controlsyd),\n                    _str4body,\n                    new Mapping(new LocationTrace(14, 22, _str3controlsyd),\n                        []),\n                    new DefaultPlaceholder(new LocationTrace(14, 22, _str3controlsyd)),\n                    true),\n                new ParameterDescriptor(new LocationTrace(14, 28, _str3controlsyd),\n                    _str9step,\n                    new Mapping(new LocationTrace(14, 32, _str3controlsyd),\n                        []),\n                    new Value(new LocationTrace(14, 33, _str3controlsyd),\n                        1),\n                    false)],\n            new Template(new LocationTrace(14, 39, _str3controlsyd),\n                new Block(new LocationTrace(15, 5, _str3controlsyd),\n                    [\n                        new Assignment(new LocationTrace(15, 4, _str3controlsyd),\n                            new InterpolatedValue(new LocationTrace(15, 4, _str3controlsyd),\n                                new Name(new LocationTrace(15, 5, _str3controlsyd),\n                                    _str6var)),\n                            new InterpolatedValue(new LocationTrace(15, 11, _str3controlsyd),\n                                new Name(new LocationTrace(15, 12, _str3controlsyd),\n                                    _str7min))),\n                        new Call(new LocationTrace(16, 4, _str3controlsyd),\n                            _str1while,\n                            [\n                                new BinaryOp(new LocationTrace(16, 15, _str3controlsyd),\n                                    _str10,\n                                    new InterpolatedValue(new LocationTrace(16, 10, _str3controlsyd),\n                                        new Name(new LocationTrace(16, 11, _str3controlsyd),\n                                            _str6var)),\n                                    new InterpolatedValue(new LocationTrace(16, 17, _str3controlsyd),\n                                        new Name(new LocationTrace(16, 18, _str3controlsyd),\n                                            _str8max))),\n                                new Block(new LocationTrace(17, 9, _str3controlsyd),\n                                    [\n                                        new InterpolatedValue(new LocationTrace(17, 8, _str3controlsyd),\n                                            new Name(new LocationTrace(17, 9, _str3controlsyd),\n                                                _str4body)),\n                                        new Assignment(new LocationTrace(18, 8, _str3controlsyd),\n                                            new InterpolatedValue(new LocationTrace(18, 8, _str3controlsyd),\n                                                new Name(new LocationTrace(18, 9, _str3controlsyd),\n                                                    _str6var)),\n                                            new BinaryOp(new LocationTrace(18, 13, _str3controlsyd),\n                                                _str11,\n                                                new InterpolatedValue(new LocationTrace(18, 8, _str3controlsyd),\n                                                    new Name(new LocationTrace(18, 9, _str3controlsyd),\n                                                        _str6var)),\n                                                new InterpolatedValue(new LocationTrace(18, 16, _str3controlsyd),\n                                                    new Name(new LocationTrace(18, 17, _str3controlsyd),\n                                                        _str9step))))])])]))),\n        new Definition(new LocationTrace(23, 0, _str3controlsyd),\n            _str12quote,\n            false,\n            [\n                new ParameterDescriptor(new LocationTrace(23, 7, _str3controlsyd),\n                    _str13code,\n                    new Mapping(new LocationTrace(23, 7, _str3controlsyd),\n                        []),\n                    new DefaultPlaceholder(new LocationTrace(23, 7, _str3controlsyd)),\n                    true)],\n            new Name(new LocationTrace(23, 16, _str3controlsyd),\n                _str13code)),\n        new Definition(new LocationTrace(26, 1, _str3controlsyd),\n            _str14expand,\n            true,\n            [\n                new Name(new LocationTrace(26, 8, _str3controlsyd),\n                    _str13code)],\n            new Name(new LocationTrace(26, 17, _str3controlsyd),\n                _str13code))])\n\nconst _index3 = new Block(new LocationTrace(0, 2, _str15indexsyd),\n    [\n        _control2,\n        _functions1,\n        _effects0])\n\nexport const ast = _index3;\n\nexport default ast;\n", "import { NodeDef, NodeHelp, NodeValueType } from \"../../compiler/evalState\";\nimport { TAU, abs, cos, sin, sgn } from \"../../math\";\n\n\nexport const zzfxFilter: NodeDef = [\n    \"zzfxFilter\",\n    [[\"sample\", null], [\"cutoff\", null], [\"quality\", 2]],\n    NodeValueType.NORMAL_OR_MONO,\n    [],\n    () => {\n        var x2 = 0, x1 = 0, y2 = 0, y1 = 0;\n        return (dt, args) => {\n            const sample = args[0]!, cutoff = args[1]!, quality = args[2]!;\n            // basically copied from ZzFX\n            var w = TAU * abs(cutoff) * 2 * dt,\n                cos_ = cos(w), alpha = sin(w) / 2 / quality,\n                a0 = 1 + alpha, a1 = -2 * cos_ / a0, a2 = (1 - alpha) / a0,\n                b0 = (1 + sgn(cutoff) * cos_) / 2 / a0,\n                b1 = -(sgn(cutoff) + cos_) / a0, b2 = b0;\n            return y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = sample) - a2 * y2 - a1 * (y2 = y1);\n\n        };\n    }\n];\n\nexport const zzfxFilterHelp: NodeHelp = {\n    description: \"Combination biquad low-pass / high-pass filter as implemented in ZzFX.\",\n    parameters: {\n        cutoff: {\n            range: [-10000, 10000],\n            unit: \"Hz\",\n            description: \"The cutoff frequency of the filter. The sign decides between low-pass (>=0) and high-pass (<0) and the magnitude is the cutoff frequency.\"\n        },\n        quality: {\n            range: [0, 2],\n            description: \"Affects the resonance of the filter.\"\n        }\n    }\n};\n\nexport const bitcrusher: NodeDef = [\n    \"bitcrusher\",\n    [[\"sample\", null], [\"sampleRate\", 8000]],\n    NodeValueType.NORMAL_OR_MONO,\n    [],\n    () => {\n        var phase = 0, last = 0;\n        return (dt, args) => {\n            const sample = args[0]!, bitcrushSampleRate = args[1]!;\n            phase += bitcrushSampleRate * dt;\n            if (phase >= 1) {\n                phase -= (phase | 0);\n                last = sample;\n            }\n            return last;\n        };\n    }\n];\n\nexport const bitcrusherHelp: NodeHelp = {\n    description: \"The classic low-fidelity effect produced by resampling the audio at a lower sample rate.\",\n    parameters: {\n        sampleRate: {\n            range: [1, 48000],\n            unit: \"Hz\",\n        },\n    }\n}\n\nexport const delay: NodeDef = [\n    \"delay\",\n    [[\"sample\", null], [\"time\", 0]],\n    NodeValueType.NORMAL_OR_MONO,\n    [],\n    () => {\n        var len = 1 << 14; // ~ 0.3 seconds of audio at 48kHz\n        var buffer = new Float32Array(len);\n        var pos = 0;\n        return (dt, args) => {\n            const sample = args[0]!, delayTime = args[1]!;\n            const delaySamples = delayTime / dt;\n            // len is always a power of 2\n            if (delaySamples > len) {\n                var newLen = len << 1;\n                const newBuffer = new Float32Array(len);\n                // poor man's memcpy to make it wrap right\n                // (.set() is just a singular memcpy with no wrapping)\n                for (var i = 0; i < len; i++) newBuffer[i] = buffer[(pos + i) & (len - 1)]!;\n                buffer = newBuffer;\n                pos = len;\n                len = newLen;\n            }\n            const out = buffer[(pos + len - delaySamples) & (len - 1)]!;\n            buffer[pos] = sample;\n            pos = (pos + 1) & (len - 1);\n            return out;\n        }\n    }\n];\n\nexport const delayHelp: NodeHelp = {\n    description: \"Singular delay line. No self-feedback or interpolation between samples.\",\n    parameters: {\n        time: {\n            range: [0, 100],\n            unit: \"seconds\",\n            description: \"How long to delay the sample for. Changing this mid-delay will effectively pitch-shift the buffered samples\"\n        }\n    }\n};\n\n// TODO: comb filter macros, allpass filter macros, reverb macros\n// https://medium.com/the-seekers-project/coding-a-basic-reverb-algorithm-part-2-an-introduction-to-audio-programming-4db79dd4e325\n", "import { NodeDef, NodeHelp, NodeValueType } from \"../../compiler/evalState\";\nimport { abs, noise3, noise5, saw, sgn, sin, tan, TAU, tri } from \"../../math\";\n\nexport const zzfxOscillator: NodeDef = [\n    \"zzfxOscillator\",\n    [[\"freq\", null], [\"shape\", 0], [\"distortion\", 1], [\"noise\", 0], [\"phi\", 0]],\n    NodeValueType.NORMAL_OR_MONO,\n    [, { sine: 0, triangle: 1, sawtooth: 2, tangent: 3, noise3: 4 }],\n    () => {\n        var phase = 0, sampleNo = 0;\n        return (dt, args) => {\n            const frequency = args[0]!, shape = args[1]!, distortion = args[2]!, noise = args[3]!, phaseMod = args[4]!;\n            const sample = (shape > 3 ? noise3 : shape > 2 ? tan : shape > 1 ? saw : shape ? tri : sin)(phaseMod * TAU + (phase += (frequency * TAU * dt) * (1 + noise * noise5(sampleNo++))));\n            return sgn(sample) * (abs(sample) ** distortion);\n        }\n    }\n];\nexport const zzfxOscillatorHelp: NodeHelp = {\n    description: \"Multi-waveform oscillator like that of ZzFX.\",\n    parameters: {\n        freq: {\n            unit: \"Hz\",\n            range: [0, 20000],\n        },\n        shape: {\n            description: \"Which base shape of oscillator to start with. Note: tangent wave sounds like double the desired frequency.\"\n        },\n        distortion: {\n            range: [0, 10],\n            description: \"How much to distort the wave shape by. A value of 0 returns a 50% duty cycle squarewave with the same frequency as the original, a value of 1 returns the real shape unchanged, and large values warp the wave towards the alternating Dirac comb function (and aliasing is increasingly likely)\"\n        },\n        noise: {\n            range: [0, 100],\n            description: \"How much extra noise to add to the wave.\",\n        },\n        phi: {\n            range: [0, 1],\n            unit: \"cycles (NOT radians!)\",\n            description: \"Modulates the oscillator's phase without adding to the internal accumulator. Useful for FM synthesis.\"\n        }\n    }\n};\n", "import { NodeDef, NodeHelp, NodeValueType } from \"../../compiler/evalState\";\nexport const shimmered: NodeDef = [\n    \"shimmered\",\n    [[\"value\", 0], [\"amount\", 0.05]],\n    NodeValueType.NORMAL_OR_MONO,\n    [],\n    () => {\n        var oldValue = 0, out = 0;\n        return (dt, args) => {\n            const value = args[0]!, amount = args[1]!;\n            if (oldValue !== value) {\n                out = value + (Math.random() - .5) * amount * value;\n                oldValue = value;\n            }\n            return out;\n        }\n    }\n];\n\nexport const shimmeredHelp: NodeHelp = {\n    description: \"Each time the input value changes, perturbs it by a small amount. No noise is added.\",\n    parameters: {\n        amount: {\n            unit: \"fraction of value\",\n            range: [0, 1]\n        }\n    }\n};\nexport const integrator: NodeDef = [\n    \"integrate\",\n    [[\"derivative\", 0], [\"resetClock\", 0], [\"resetValue\", 0], [\"boundaryMode\", 1], [\"low\", -Infinity], [\"high\", Infinity], [\"sampleMode\", 1]],\n    NodeValueType.NORMAL_OR_MONO,\n    [, , , { clamp: 1, wrap: 0 }, , , { integrate: 1, accumulate: 0 }],\n    () => {\n        var integral = 0, prevReset = 0;\n        return (dt, args) => {\n            const integrand = args[0]!, reset = args[1]!, resetTo = args[2]!, boundaryMode = args[3]!, low = Math.min(args[4]!, args[5]!), high = Math.max(args[4]!, args[5]!), sampleMode = args[6]!;\n            if (reset > 0 && prevReset <= 0) integral = resetTo;\n            prevReset = reset;\n            integral += integrand * (sampleMode ? dt : 1);\n            const difference = high - low;\n            if (boundaryMode === 0 && difference > 0) {\n                while (integral < low) integral += difference;\n                while (integral > high) integral -= difference;\n            } else {\n                if (integral < low) integral = low;\n                if (integral > high) integral = high;\n            }\n            return integral;\n        }\n    }\n];\n\nexport const integratorHelp: NodeHelp = {\n    description: \"An integrator/accumulator which can be used to sweep a value at a variable speed.\",\n    parameters: {\n        resetClock: {\n            description: \"When this changes from 0 to 1, the internal integrand is reset instantly to resetValue. A 1 on the very first sample triggers a reset as well.\"\n        },\n        boundaryMode: {\n            description: \"If boundaryMode is 0 (wrap), the integrand will jump down to low when it passes high, and vice versa. If boundaryMode is 1 (clamp), the integrand will saturate when it reaches high or low.\"\n        },\n        sampleMode: {\n            description: \"If sampleMode is 1 (integrate) the derivative value will be treated as a value with units, and will be scaled by the sample rate - useful when it is a continuous value varying in real units with time. If sampleMode is 0 (accumulate) the derivative value will not be scaled and will be added on every sample - this is useful in combination with the clock node to create a stepping motion.\"\n        }\n    }\n};\n\nexport const clock: NodeDef = [\n    \"clock\",\n    [[\"period\", 1], [\"speed\", 1]],\n    NodeValueType.NORMAL_OR_MONO,\n    [],\n    () => {\n        var time = Infinity;\n        return (dt, args) => {\n            const period = args[0]!, speedScale = args[1]!;\n            time += speedScale * dt;\n            if (time >= period) {\n                time = 0;\n                return 1;\n            }\n            return 0;\n        }\n    }\n];\n\nexport const clockHelp: NodeHelp = {\n    description: \"A clock, that counts time internally and outputs 1 when the timer rolls over, and 0 otherwise.\",\n    parameters: {\n        period: {\n            unit: \"seconds\",\n            range: [0, Infinity],\n            description: \"The interval which the clock should roll over at. If this is suddenly lowered, the clock may immediately roll over if the internal counter was less than the old period, but now greater than the new period.\"\n        },\n        speed: {\n            unit: \"seconds per second\",\n            description: \"Makes the clock run faster or slower internally. If this is suddenly increased, the clock will NOT roll over as this doesn't affect the rollover point, only how fast that point is reached.\"\n        }\n    }\n};\n", "import * as AST from \"../compiler/ast\";\nimport { EvalState, NodeDef, NodeHelp } from \"../compiler/evalState\";\nimport { CompiledVoiceData, Opcode } from \"../compiler/prog\";\nimport { ast as lib, sources } from \"./index.syd\";\nimport { bitcrusher, bitcrusherHelp, delay, delayHelp, zzfxFilter, zzfxFilterHelp } from \"./nodes/effects\";\nimport { zzfxOscillator, zzfxOscillatorHelp } from \"./nodes/generators\";\nimport { clock, clockHelp, integrator, integratorHelp, shimmered, shimmeredHelp } from \"./nodes/logic\";\nexport { sources as libSrc };\n\nexport function nodes(): NodeDef[] {\n    return [\n        zzfxOscillator,\n        zzfxFilter,\n        bitcrusher,\n        delay,\n        shimmered,\n        integrator,\n        clock,\n    ]\n}\n\nexport function baseEnv(): EvalState {\n    return {\n        globalEnv: {},\n        env: {},\n        functions: [],\n        nodes: nodes(),\n        callstack: [],\n        recursionLimit: 1000,\n        // TODO\n        annotators: {},\n    };\n}\n\nexport function silenceInstrument(): CompiledVoiceData {\n    return {\n        p: [[Opcode.PUSH_CONSTANT, [0, 0]]],\n        r: [],\n        nn: [],\n        tosStereo: true,\n        mods: []\n    }\n}\nexport function passthroughFx(): CompiledVoiceData {\n    return {\n        p: [[Opcode.PUSH_INPUT_SAMPLES]],\n        r: [],\n        nn: [],\n        tosStereo: true,\n        mods: []\n    }\n}\n\nexport function nodeHelp(): Record<string, NodeHelp> {\n    return {\n        zzfxOscillator: zzfxOscillatorHelp,\n        zzfxFilter: zzfxFilterHelp,\n        bitcrusher: bitcrusherHelp,\n        delay: delayHelp,\n        shimmered: shimmeredHelp,\n        integrator: integratorHelp,\n        clock: clockHelp\n    }\n}\nexport async function newEnv() {\n    const env = baseEnv();\n    await (lib as AST.Node).eval(env);\n    return env;\n}\nexport async function compileInstrument(source: string, filename: string) {\n\n}\n", "import { str } from \"../utils\";\nimport { WorkletSynth } from \"./synthImpl\";\n\nexport function newSynth(context: AudioContext): ProxiedSynth {\n    try {\n        return makeSynthProxy(new AudioWorkletNode(context, \"syd\", { numberOfInputs: 0, numberOfOutputs: 1, outputChannelCount: [2] }));\n    } catch (e: any) {\n        if (e.name === \"InvalidStateError\") {\n            throw new Error(\"failed to create Syd synthesizer node. Did you call initWorklet() and await the result?\")\n        }\n        throw e;\n    }\n}\n\nfunction makeSynthProxy(audioNode: AudioWorkletNode): ProxiedSynth {\n    var idCounter = Number.MIN_SAFE_INTEGER;\n    const resolvers = new Map<number, ReturnType<PromiseConstructor[\"withResolvers\"]>>();\n    audioNode.port.onmessage = event => {\n        const data: MessageReply = event.data;\n        console.log(\"[main thread] received message reply\", data);\n        const p = resolvers.get(data.id);\n        if (p) {\n            if (data.failed) p.reject(data.result);\n            else p.resolve(data.result);\n        }\n        resolvers.delete(data.id);\n    };\n    return new Proxy<ProxyObject>({\n        audioNode,\n    }, {\n        get(target: any, method: keyof ProxiedSynth) {\n            if (method in target) return target[method];\n            return (...args: Message[\"args\"]) => {\n                const id = idCounter++;\n                const p = Promise.withResolvers();\n                resolvers.set(id, p);\n                audioNode.port.postMessage({ id, method, args } as Message);\n                return p.promise;\n            };\n        },\n        set(target, p) {\n            throw new TypeError(`Cannot set property of ProxiedSynth ${str(p)} which is read-only`);\n        }\n    }) as ProxiedSynth;\n}\n\ntype SynthMethod = {\n    [K in keyof WorkletSynth]: WorkletSynth[K] extends Function ? K : never;\n}[keyof WorkletSynth];\n\ntype PromiseFunction<T extends (...args: any) => any> = (...args: Parameters<T>) => Promise<ReturnType<T>>;\n\nexport type Message<T extends SynthMethod = SynthMethod> = {\n    method: T;\n    id: number;\n    args: Parameters<WorkletSynth[T]>;\n};\nexport type MessageReply<T extends SynthMethod = SynthMethod> = {\n    id: number;\n    result: ReturnType<WorkletSynth[T]>;\n    failed: false;\n} | {\n    id: number;\n    result: Error;\n    failed: true;\n};\n\ntype ProxyObject = {\n    audioNode: AudioWorkletNode;\n}\nexport type ProxiedSynth = ProxyObject & {\n    [K in SynthMethod]: PromiseFunction<WorkletSynth[K]>\n}\n", "import { CompiledVoiceData, Opcode } from \"../compiler/prog\";\nimport { str } from \"../utils\";\n\nexport function disassemble(data: CompiledVoiceData): string {\n    const outLines: string[] = [];\n    const prog = data.p;\n    const nNode = (number: number) => {\n        return `${number} (${data.nn[number]})`;\n    }\n\n    for (var command of prog) {\n        const opName = Opcode[command[0]];\n        var arg: string[] = [];\n        switch (command[0]) {\n            case Opcode.PUSH_CONSTANT:\n                arg = [str(command[1])];\n                break;\n            case Opcode.PUSH_INPUT_SAMPLES:\n            case Opcode.PUSH_PITCH:\n            case Opcode.PUSH_EXPRESSION:\n            case Opcode.PUSH_GATE:\n            case Opcode.MARK_STILL_ALIVE:\n            case Opcode.DROP_TOP:\n            case Opcode.PUSH_FRESH_EMPTY_LIST:\n            case Opcode.APPEND_TO_LIST:\n            case Opcode.EXTEND_TO_LIST:\n                break;\n            case Opcode.DO_BINARY_OP:\n            case Opcode.DO_BINARY_OP_STEREO:\n            case Opcode.DO_UNARY_OP:\n            case Opcode.DO_UNARY_OP_STEREO:\n            case Opcode.GET_REGISTER:\n            case Opcode.TAP_REGISTER:\n                arg = [str(command[1])];\n                break;\n            case Opcode.CONDITIONAL_SELECT:\n            case Opcode.STEREO_DOUBLE_WIDEN:\n                break;\n            case Opcode.APPLY_NODE:\n                arg = [nNode(command[1] as number), str(command[2]) + \" args\"];\n                break;\n            case Opcode.GET_MOD:\n                arg = [str(command[1])];\n                break;\n            case Opcode.APPLY_DOUBLE_NODE_STEREO:\n                arg = [nNode(command[1] as number), nNode(command[2] as number), str(command[1]) + \" args\"];\n                break;\n            default:\n                command[0] satisfies never;\n        }\n        outLines.push(`${opName} ${arg.join(\", \")}`)\n    }\n    return outLines.join(\"\\n\");\n}\n", "export { baseEnv, nodes, nodeHelp, libSrc, newEnv, compileInstrument } from \"./lib\";\nexport * from \"./compiler/ast\";\nexport * as AST from \"./compiler/ast\";\nexport { SydError, ErrorNote, LocationTrace, ParseError, CompileError, RuntimeError } from \"./compiler/errors\";\nexport { parse } from \"./compiler\";\nexport { newSynth } from \"./runtime/synthProxy\";\nexport { disassemble } from \"./runtime/disassemble\";\n\nexport function initWorklet(context: AudioContext, pathToWorkletScript?: URL | string): Promise<void> {\n    if (pathToWorkletScript === undefined) {\n        pathToWorkletScript = new URL(\"./sydWorklet.js\", import.meta.url);\n    }\n    return context.audioWorklet.addModule(pathToWorkletScript);\n}\n"],
  "mappings": "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",
  "names": []
}
