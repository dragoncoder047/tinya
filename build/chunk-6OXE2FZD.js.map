{
  "version": 3,
  "sources": ["../src/compiler/errors.ts", "../src/compiler/ast.ts", "../src/utils.ts", "../src/compiler/call.ts", "../src/compiler/evalState.ts", "../src/compiler/codemacro.ts", "../src/math.ts", "../src/compiler/operator.ts", "../src/compiler/prog.ts", "../src/compiler/tokenizer.ts", "../src/compiler/expression.ts", "../src/compiler/core.ts", "../src/compiler/pipe.ts", "../src/compiler/transformers.ts", "../src/compiler/index.ts"],
  "sourcesContent": ["export class LocationTrace {\n    constructor(\n        public line: number,\n        public col: number,\n        public file: string,\n        public source: [string, LocationTrace] | null = null) { }\n\n    static nowhere = new LocationTrace(0, 0, \"unknown\");\n}\nfunction formatTrace(trace: LocationTrace, message: string, sources: Record<string, string>): string {\n    const src = sources[trace.file];\n    var lineInfo = \"\";\n    if (src) {\n        const lines = src.split(\"\\n\");\n        const relevantLine = lines[trace.line] || \"\";\n        const lineNumberString = trace.line + 1 + \"\";\n        lineInfo = `\\n${lineNumberString} | ${relevantLine}\\n${\" \".repeat(lineNumberString.length)} | ${\" \".repeat(trace.col)}^`;\n    }\n    return `${trace.file}:${trace.line + 1}:${trace.col + 1}: ${message}${lineInfo}${trace.source ? \"\\n\" + formatTrace(trace.source[1], trace.source[0], sources) : \"\"}`;\n}\n\nexport class ErrorNote {\n    constructor(public message: string, public location: LocationTrace) { }\n}\n\nexport class SydError extends Error {\n    constructor(message: string, public trace: LocationTrace = LocationTrace.nowhere, public notes: ErrorNote[] = []) {\n        super(message);\n    }\n    displayOn(sources: Record<string, string>): string {\n        return formatTrace(this.trace, \"error: \" + this.message, sources) + this.notes.map(note => \"\\n\" + formatTrace(note.location, note.message, sources)).join(\"\") + \"\\n\";\n    }\n}\n\nexport class ParseError extends SydError { }\n\nexport class RuntimeError extends SydError { }\n\nexport class CompileError extends SydError { }\n", "import { id, isinstance, str } from \"../utils\";\nimport { processArgsInCall } from \"./call\";\nimport { makeCodeMacroExpander } from \"./codemacro\";\nimport { CompileError, ErrorNote, LocationTrace, RuntimeError } from \"./errors\";\nimport { EvalState, NodeDef, NodeValueType, pushNamed } from \"./evalState\";\nimport { OPERATORS } from \"./operator\";\nimport { allocNode, allocRegister, CompiledVoiceData, Opcode, Program } from \"./prog\";\n\nexport abstract class Node {\n    constructor(public loc: LocationTrace) { }\n    abstract edgemost(left: boolean): Node;\n    abstract pipe(fn: (node: Node) => Promise<Node>): Promise<Node>;\n    abstract eval(state: EvalState): Promise<Node>;\n    abstract compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]): void;\n}\n\nexport abstract class NotCodeNode extends Node {\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        throw new CompileError(\"how did we get here ?!? (\" + this.constructor.name + \")\", this.loc);\n    }\n}\n\nexport abstract class Leaf extends NotCodeNode {\n    edgemost() { return this; }\n    async pipe() { return this; }\n    async eval(_: EvalState): Promise<Node> { return this; }\n}\n\nexport class AnnotatedValue extends NotCodeNode {\n    constructor(trace: LocationTrace, public attributes: Node[], public value: Node | null = null) { super(trace); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new AnnotatedValue(this.loc, await asyncNodePipe(this.attributes, fn), this.value ? await fn(this.value) : null); }\n    edgemost(left: boolean): Node { return left ? (this.attributes.length > 0 ? this.attributes[0]!.edgemost(left) : this) : (this.value ?? this); }\n    async eval(state: EvalState) {\n        var v = this.value;\n        for (var attr of this.attributes) {\n            var args: Node[] | null = null;\n            var name: string;\n            if (isinstance(attr, Call) || isinstance(attr, Name)) {\n                name = attr.name;\n                const impl = state.annotators[name];\n                if (!impl) {\n                    throw new RuntimeError(\"unknown annotation \" + str(name), attr.loc, stackToNotes(state.callstack));\n                }\n                if (isinstance(attr, Call)) {\n                    args = attr.args;\n                }\n                v = await impl(v, args, state);\n            } else {\n                throw new RuntimeError(\"illegal annotation\", attr.loc, stackToNotes(state.callstack));\n            }\n        }\n        return v!;\n    }\n}\n\nexport class Value extends Leaf {\n    constructor(trace: LocationTrace, public value: any) { super(trace); };\n    async eval(state: EvalState): Promise<Node> {\n        if (isinstance(this.value, Node)) return this.value;\n        return this;\n    }\n    compile(state: CompiledVoiceData) {\n        state.p.push([Opcode.PUSH_CONSTANT, this.value]);\n        state.tosStereo = false;\n    }\n}\n\nexport class Symbol extends Leaf {\n    constructor(trace: LocationTrace, public value: string) { super(trace); };\n    async eval(state: EvalState): Promise<Symbol> {\n        return this;\n    }\n}\n\nexport class Assignment extends Node {\n    constructor(trace: LocationTrace, public target: Node, public value: Node) { super(trace); };\n    edgemost(left: boolean): Node { return left ? this.target.edgemost(left) : this.value.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Assignment(this.loc, await fn(this.target), await fn(this.value)); }\n    async eval(state: EvalState) {\n        if (!isinstance(this.target, Name)) {\n            throw new RuntimeError(\"cannot assign to this\", this.target.loc);\n        }\n        const name = this.target.name;\n        const scope = scopeForName(name, state);\n        var b = scope[name];\n        if (!b) {\n            b = new LateBinding(this.loc, name);\n            scope[name] = b;\n        }\n        const result = scope[name] = await this.value.eval(state);\n        if (isinstance(b, LateBinding)) {\n            b.boundValue = result;\n        }\n        return result;\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        compileNode(this.value, state, refMap, ni);\n        state.p.push([Opcode.TAP_REGISTER, allocRegister((this.target as any).name, state)]);\n    }\n}\n\nexport class Name extends Leaf {\n    constructor(trace: LocationTrace, public name: string) { super(trace); };\n    async eval(state: EvalState) {\n        const val = state.env[this.name];\n        if (!val) {\n            return scopeForName(this.name, state)[this.name] = new LateBinding(this.loc, this.name);\n        }\n        return val;\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        state.p.push([Opcode.GET_REGISTER, allocRegister(this.name, state)]);\n    }\n}\n\nexport class LateBinding extends Name {\n    boundValue: Node | undefined = undefined;\n    async eval() {\n        return this.boundValue ?? this;\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        if (!this.boundValue) {\n            throw new CompileError(`${this.name} was never assigned to in this scope`, this.loc);\n        }\n        compileNode(this.boundValue, state, refMap, ni);\n    }\n}\n\nexport class Call extends Node {\n    constructor(trace: LocationTrace, public name: string, public args: Node[]) { super(trace); };\n    edgemost(left: boolean): Node { return left ? this : this.args.at(-1)?.edgemost(left) ?? this; }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Call(this.loc, this.name, await asyncNodePipe(this.args, fn)); }\n    async eval(state: EvalState): Promise<Node> {\n        const funcImpl = state.functions.find(f => f[0] === this.name);\n        if (funcImpl) {\n            const impl = funcImpl[2];\n            const newState: EvalState = { ...state, callstack: state.callstack.concat(this) };\n            return impl(this.args, newState);\n        }\n        const nodeImpl = state.nodes.find(n => n[0] === this.name);\n        if (!nodeImpl) {\n            throw new RuntimeError(\"undefined node or function \" + this.name, this.loc, stackToNotes(state.callstack));\n        }\n        var x: List;\n        if (nodeImpl[2] === NodeValueType.DECOUPLED_MATH && (x = new List(this.loc, this.args)).isImmediate()) {\n            return new Value(this.loc, nodeImpl[4]!(null as any)(null!, x.toImmediate()!));\n        }\n        return new Call(this.loc, nodeImpl[0], await processArgsInCall(state, true, this.loc, this.args, nodeImpl));\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        var i: number;\n        const nodeImpl = ni.find(n => n[0] === this.name);\n        if (!nodeImpl) {\n            throw new CompileError(`cannot find node ${this.name} (should be unreachable!!)`, this.loc);\n        }\n        const argProgs: [argProg: Program, isStereo: NodeValueType][] = [];\n        const existingProg: Program = state.p;\n        for (i = 0; i < this.args.length; i++) {\n            state.p = [];\n            compileNode(this.args[i]!, state, refMap, ni);\n            argProgs.push([state.p, state.tosStereo ? NodeValueType.STEREO : NodeValueType.NORMAL_OR_MONO]);\n        }\n        state.p = existingProg;\n        const callProg: Program[number] = [Opcode.APPLY_NODE, allocNode(this.name, state), nodeImpl[1].length];\n        // logic for stereo/mono nodes:\n        // if the node is x -> stereo, the inputs must all be the right type (mono to stereo can be widened; stereo to mono can't be narrowed, error)\n        // if the node is mono -> mono, the node itself is duplicated if any inputs are stereo and the output is stereo, else mono\n        // if the node is stereo -> mono, normal with the inputs also being widened if needed\n        // We assume our arguments are correct and line up positionally already\n        // (this should have been handled by the eval() stage)\n        state.tosStereo = nodeImpl[2] === NodeValueType.STEREO;\n        if (nodeImpl[1].every(a => a[2] !== NodeValueType.STEREO) && argProgs.some(s => s[1] === NodeValueType.STEREO)) {\n            // Can stereo widen\n            for (i = 0; i < nodeImpl[1].length; i++) {\n                const gottenArgType = argProgs[i]![1];\n                if (gottenArgType !== NodeValueType.STEREO) {\n                    argProgs[i]![0].push([Opcode.STEREO_DOUBLE_WIDEN]);\n                }\n            }\n            state.tosStereo = true;\n            callProg[0] = Opcode.APPLY_DOUBLE_NODE_STEREO;\n            callProg.splice(2, 0, allocNode(this.name, state)); // 2nd node\n        }\n        else {\n            for (i = 0; i < nodeImpl[1].length; i++) {\n                const neededArgType = nodeImpl[1][i]![2]! ?? NodeValueType.NORMAL_OR_MONO;\n                const gottenArgType = argProgs[i]![1];\n                if (neededArgType !== NodeValueType.STEREO && gottenArgType === NodeValueType.STEREO) {\n                    throw new CompileError(\"cannot implicitly convert stereo output to mono\", this.args[i]!.loc);\n                } else if (neededArgType === NodeValueType.STEREO && gottenArgType !== NodeValueType.STEREO) {\n                    argProgs[i]![0].push([Opcode.STEREO_DOUBLE_WIDEN]);\n                }\n            }\n            state.tosStereo = nodeImpl[2] === NodeValueType.STEREO;\n        }\n        for (i = 0; i < this.args.length; i++) {\n            state.p.push(...argProgs[i]![0]);\n        }\n        state.p.push(callProg);\n    }\n}\n\nexport class List extends Node {\n    constructor(trace: LocationTrace, public values: Node[]) { super(trace); };\n    edgemost(left: boolean): Node { return this.values.length > 0 ? left ? this.values[0]!.edgemost(left) : this.values.at(-1)!.edgemost(left) : this; }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new List(this.loc, await asyncNodePipe(this.values, fn)); }\n    async eval(state: EvalState) {\n        const values: Node[] = [];\n        for (var v of this.values) {\n            const v2 = await v.eval(state);\n            if (isinstance(v2, SplatValue) && isinstance(v2.value, List)) {\n                values.push(...v2.value.values);\n            } else {\n                values.push(v2);\n            }\n        }\n        return new List(this.loc, values);\n    }\n    hasSplats() {\n        return this.values.some(v => isinstance(v, SplatValue));\n    }\n    isImmediate(): boolean {\n        return this.values.every(v => isinstance(v, Value) || (isinstance(v, List) && v.isImmediate()));\n    }\n    toImmediate(): any[] | undefined {\n        if (this.isImmediate()) {\n            return this.values.map(v => isinstance(v, Value) ? v.value : (v as List).toImmediate());\n        }\n    }\n    static fromImmediate(trace: LocationTrace, m: any[]): List | Value {\n        return Array.isArray(m) ? new List(trace, m.map(r => List.fromImmediate(trace, r))) : new Value(trace, m);\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        if (this.isImmediate()) {\n            const imm = this.toImmediate() as any;\n            state.p.push([Opcode.PUSH_CONSTANT, imm]);\n        } else {\n            state.p.push([Opcode.PUSH_FRESH_EMPTY_LIST]);\n            for (var arg of this.values) {\n                compileNode(arg, state, refMap, ni);\n                if (isinstance(arg, SplatValue)) {\n                    state.p.push([Opcode.EXTEND_TO_LIST]);\n                } else {\n                    state.p.push([Opcode.APPEND_TO_LIST]);\n                }\n            }\n        }\n        state.tosStereo = this.values.length === 2;\n    }\n}\n\nexport class Definition extends NotCodeNode {\n    constructor(trace: LocationTrace, public name: string, public outMacro: boolean, public parameters: Node[], public body: Node) { super(trace); };\n    edgemost(left: boolean): Node { return left ? this.parameters.length > 0 ? this.parameters[0]!.edgemost(left) : this : this.body.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Definition(this.loc, this.name, this.outMacro, await asyncNodePipe(this.parameters, fn), await fn(this.body)); }\n    async eval(state: EvalState) {\n        pushNamed(state.functions, [this.name, this.parameters.length, makeCodeMacroExpander(this.name, this.outMacro, this.parameters, this.body)]);\n        return new Value(this.loc, undefined);\n    }\n}\n\nexport class ParameterDescriptor extends NotCodeNode {\n    constructor(trace: LocationTrace, public name: string, public enumOptions: Mapping, public defaultValue: Node, public lazy: boolean) { super(trace) }\n    edgemost(left: boolean): Node { return left ? this : this.defaultValue.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new ParameterDescriptor(this.loc, this.name, await fn(this.enumOptions) as Mapping, await fn(this.defaultValue), this.lazy) }\n    async eval(state: EvalState): Promise<never> {\n        throw new RuntimeError(\"cannot evaluate\", this.loc, stackToNotes(state.callstack));\n    }\n}\n\nexport class Template extends NotCodeNode {\n    constructor(trace: LocationTrace, public result: Node) { super(trace); };\n    edgemost(left: boolean): Node { return this.result.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Template(this.loc, await fn(this.result)); }\n    async eval(state: EvalState) {\n        const replaceTrace = async (arg: Node): Promise<Node> => {\n            const val = await arg.pipe(replaceTrace);\n            val.loc = new LocationTrace(arg.loc.line, arg.loc.col, arg.loc.file, [\"note: expanded from template:\", this.loc]);\n            return val;\n        }\n        const recur = async (arg: Node, depth: number): Promise<Node> => {\n            if (isinstance(arg, Template)) return arg.pipe(n => recur(n, depth + 1));\n            if (isinstance(arg, InterpolatedValue)) {\n                if (depth <= 1) {\n                    return replaceTrace(await arg.value.eval(state));\n                } else {\n                    const val = await arg.pipe(n => recur(n, depth - 1));\n                    if (isinstance(val, InterpolatedValue) && isinstance(val.value, Value)) return val.value;\n                    return val;\n                }\n            }\n            return arg.pipe(n => recur(n, depth));\n        }\n        return recur(await replaceTrace(this.result), 1);\n    }\n}\n\nexport class BinaryOp extends Node {\n    constructor(trace: LocationTrace, public op: string, public left: Node, public right: Node, public noLift: boolean = false, public assign?: LocationTrace | undefined) { super(trace); };\n    edgemost(left: boolean): Node { return this[left ? \"left\" : \"right\"].edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new BinaryOp(this.loc, this.op, await fn(this.left), await fn(this.right), this.noLift, this.assign); }\n    async eval(state: EvalState) {\n        return this._applied(await this.left.eval(state), await this.right.eval(state));\n    }\n    private _applied(left: Node, right: Node) {\n        var fn: (typeof OPERATORS)[keyof typeof OPERATORS][\"cb\"] | undefined;\n        var imm = true, a, b;\n        if (isinstance(left, Value)) {\n            a = left.value;\n        } else if (isinstance(left, List) && left.isImmediate()) {\n            a = left.toImmediate();\n        } else {\n            imm = false;\n        }\n        if (isinstance(right, Value)) {\n            b = right.value;\n        } else if (isinstance(right, List) && right.isImmediate()) {\n            b = right.toImmediate();\n        } else {\n            imm = false;\n        }\n        if ((fn = OPERATORS[this.op]?.cb) && imm) {\n            return List.fromImmediate(this.loc, fn(a, b))\n        }\n        // Special case for comparing in/equality of 2 symbols\n        if (isinstance(left, Symbol) && isinstance(right, Symbol) && /^[!=]=$/.test(this.op)) {\n            return List.fromImmediate(this.loc, fn!(left.value, b.value));\n        }\n        return new BinaryOp(this.loc, this.op, left, right);\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        compileNode(this.left, state, refMap, ni);\n        const aStereo = state.tosStereo;\n        const aIndex = state.p.length;\n        compileNode(this.right, state, refMap, ni);\n        const bStereo = state.tosStereo;\n        if ((state.tosStereo ||= aStereo)) {\n            if (!aStereo) state.p.splice(aIndex, 0, [Opcode.STEREO_DOUBLE_WIDEN]);\n            if (!bStereo) state.p.push([Opcode.STEREO_DOUBLE_WIDEN]);\n        }\n        state.p.push([state.tosStereo ? Opcode.DO_BINARY_OP_STEREO : Opcode.DO_BINARY_OP, this.op]);\n    }\n}\n\nexport class UnaryOp extends Node {\n    constructor(trace: LocationTrace, public op: string, public value: Node) { super(trace); };\n    edgemost(left: boolean): Node { return left ? this : this.value.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new UnaryOp(this.loc, this.op, await fn(this.value)); }\n    async eval(state: EvalState) {\n        return this._applied(await this.value.eval(state));\n    }\n    private _applied(val: Node): Node {\n        var fn: (typeof OPERATORS)[keyof typeof OPERATORS][\"cu\"] | undefined;\n        var imm = true, value;\n        if (isinstance(val, Value)) {\n            value = val.value;\n        } else if (isinstance(val, List) && val.isImmediate()) {\n            value = val.toImmediate();\n        } else {\n            imm = false;\n        }\n        if (imm && (fn = OPERATORS[this.op]?.cu)) {\n            return List.fromImmediate(this.loc, fn(value));\n        }\n        return new UnaryOp(this.loc, this.op, val);\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        compileNode(this.value, state, refMap, ni);\n        state.p.push([state.tosStereo ? Opcode.DO_UNARY_OP_STEREO : Opcode.DO_UNARY_OP, this.op]);\n    }\n}\n\nexport class DefaultPlaceholder extends Leaf {\n    async eval(state: EvalState): Promise<never> {\n        throw new RuntimeError(\"cannot evaluate\", this.loc, stackToNotes(state.callstack));\n    }\n}\n\nexport class KeywordArgument extends NotCodeNode {\n    constructor(trace: LocationTrace, public name: string, public arg: Node) { super(trace); }\n    edgemost(left: boolean): Node { return left ? this : this.arg.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new KeywordArgument(this.loc, this.name, await fn(this.arg)); }\n    async eval(state: EvalState) {\n        return new KeywordArgument(this.loc, this.name, await this.arg.eval(state));\n    }\n}\n\nexport class Mapping extends NotCodeNode {\n    constructor(trace: LocationTrace, public mapping: { key: Node, val: Node }[]) { super(trace); }\n    edgemost(left: boolean): Node { return this.mapping.length > 0 ? left ? this.mapping[0]!.key.edgemost(left) : this.mapping.at(-1)!.val.edgemost(left) : this; }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Mapping(this.loc, await asyncNodePipe(this.mapping, async ({ key, val }) => ({ key: await fn(key), val: await fn(val) }))); }\n    async eval(state: EvalState) {\n        return new Mapping(this.loc, await Promise.all(this.mapping.map(async ({ key, val }) => ({ key: await key.eval(state), val: await val.eval(state) }))));\n    }\n    async toJS(state: EvalState): Promise<Record<string, Node>> {\n        const out: Record<string, Node> = {};\n        for (var { key, val } of this.mapping) {\n            if (!isinstance(key, Symbol)) {\n                throw new Error(\"unreachable\");\n            }\n            out[key.value] = await val.eval(state);\n        }\n        return out;\n    }\n}\n\nexport class Conditional extends Node {\n    constructor(trace: LocationTrace, public cond: Node, public caseTrue: Node, public caseFalse: Node) { super(trace); }\n    edgemost(left: boolean): Node { return (left ? this.cond : this.caseFalse).edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Conditional(this.loc, await fn(this.cond), await fn(this.caseTrue), await fn(this.caseFalse)); }\n    async eval(state: EvalState): Promise<Node> {\n        const cond = await this.cond.eval(state);\n        if (isinstance(cond, Value)) {\n            return (!cond.value ? this.caseFalse : this.caseTrue).eval(state);\n        }\n        const ct = await this.caseTrue.eval(state);\n        const cf = await this.caseFalse.eval(state);\n        return new Conditional(this.loc, cond, ct, cf);\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        compileNode(this.caseFalse, state, refMap, ni);\n        const stereoF = state.tosStereo;\n        const stereoI = state.p.length;\n        compileNode(this.caseTrue, state, refMap, ni);\n        const stereoT = state.tosStereo;\n        if ((state.tosStereo ||= stereoF)) {\n            if (!stereoT) state.p.push([Opcode.STEREO_DOUBLE_WIDEN]);\n            if (!stereoF) state.p.splice(stereoI, 0, [Opcode.STEREO_DOUBLE_WIDEN]);\n        }\n        compileNode(this.cond, state, refMap, ni);\n        if (state.tosStereo) {\n            throw new CompileError(\"cannot use stereo output as condition\", this.cond.loc);\n        }\n        state.p.push([Opcode.CONDITIONAL_SELECT]);\n    }\n}\n\nexport class InterpolatedValue extends NotCodeNode {\n    constructor(trace: LocationTrace, public value: Node) { super(trace); }\n    edgemost(left: boolean): Node { return this.value.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new InterpolatedValue(this.loc, await fn(this.value)); }\n    async eval(state: EvalState): Promise<never> {\n        throw new RuntimeError(\"too many &'s\", this.loc, stackToNotes(state.callstack));\n    }\n}\n\nexport class SplatValue extends NotCodeNode {\n    constructor(trace: LocationTrace, public value: Node) { super(trace); }\n    edgemost(left: boolean): Node { return this.value.edgemost(left); }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new SplatValue(this.loc, await fn(this.value)); }\n    async eval(state: EvalState) {\n        return new SplatValue(this.loc, await this.value.eval(state));\n    }\n}\n\nexport class PipePlaceholder extends Leaf {\n    async eval(state: EvalState): Promise<never> {\n        throw new RuntimeError(\"not valid outside of a pipe expression\", this.loc, stackToNotes(state.callstack));\n    }\n}\n\nexport class Block extends Node {\n    constructor(trace: LocationTrace, public body: Node[]) { super(trace); }\n    edgemost(left: boolean): Node { return this.body.length > 0 ? left ? this.body[0]!.edgemost(left) : this.body.at(-1)!.edgemost(left) : this; }\n    async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Block(this.loc, await asyncNodePipe(this.body, fn)); }\n    async eval(state: EvalState): Promise<Node> {\n        var last: Node = new Value(this.loc, undefined);\n        for (var v of this.body) {\n            if (isinstance(v, DefaultPlaceholder)) last = new Value(v.loc, undefined);\n            else last = await v.eval(state);\n        }\n        return last;\n    }\n    compile(state: CompiledVoiceData, refMap: Map<Node, ResultCacheEntry>, ni: NodeDef[]) {\n        for (var statement of this.body) {\n            statement.compile(state, refMap, ni);\n            state.p.push([Opcode.DROP_TOP]);\n        }\n        // *Don't* drop the last value\n        state.p.pop();\n    }\n}\n\nasync function asyncNodePipe<T>(nodes: T[], fn: (node: T) => Promise<T>): Promise<T[]> {\n    return await Promise.all(nodes.map(fn));\n}\n\nexport function stackToNotes(stack: Call[]): ErrorNote[] {\n    const out: ErrorNote[] = [];\n    for (var s of stack) {\n        out.push(new ErrorNote(`note: while evaluating function ${str(s.name)}`, s.loc));\n    }\n    return out.reverse();\n}\n\nexport function newCompileData(): CompiledVoiceData {\n    return {\n        p: [],\n        r: [],\n        nn: [],\n        tosStereo: false,\n        mods: [],\n    }\n}\n\nfunction scopeForName(name: string, state: EvalState) {\n    return Object.hasOwn(state.env, name) ? state.env : Object.hasOwn(state.globalEnv, name) ? state.globalEnv : state.env;\n}\n\ntype ResultCacheEntry = [\n    used: boolean, // whether this node is reffed multiple times\n    index: number | null, // index into prog to insert tap - defined if node is completed and tap must be spliced in\n    stereo: boolean, // whether node said top of stack was stereo\n];\n\nexport function compileNode(node: Node, state: CompiledVoiceData, cache: Map<Node, ResultCacheEntry>, ni: NodeDef[]): CompiledVoiceData {\n    if (isinstance(node, Value)) {\n        node.compile(state);\n        return state;\n    }\n    const entry = cache.get(node);\n    const regname = \"\" + id(node);\n    if (entry) {\n        if (!entry[0]) {\n            entry[0] = true;\n            // haven't assigned a tap yet\n            if (entry[1] !== null) {\n                // ... but the node has been compiled in fully\n                state.p.splice(entry[1], 0, [Opcode.TAP_REGISTER, allocRegister(regname, state)]);\n                // update nodes further down the line after this in the program\n                for (var e of cache.values()) {\n                    if (e[0] && e[1] !== null && e[1] > entry[1]) e[1]++;\n                }\n            } else {\n                // node has NOT been compiled in fully so tap point doesn't exist yet - this is a backreference!\n                // we don't need to adjust any indices\n            }\n        } else {\n            // node's tap has been handled already or will be handled\n        }\n        state.p.push([Opcode.GET_REGISTER, allocRegister(regname, state)]);\n        state.tosStereo = entry[2];\n    }\n    else {\n        // New node\n        const myEntry: ResultCacheEntry = [false, null, false];\n        cache.set(node, myEntry);\n        // Do the thing\n        node.compile(state, cache, ni);\n        // Tap out if needed\n        if (myEntry[0]) {\n            state.p.push([Opcode.TAP_REGISTER, allocRegister(regname, state)]);\n        }\n        myEntry[1] = state.p.length;\n    }\n    return state;\n}\n", "// export const mapObject = <T, U>(obj: Record<string, T>, func: (value: T, key: string) => U): Record<string, U> =>\n//     Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, func(value, key)]));\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\n// export const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\n// export const isString = is(\"string\") as (x: any) => x is string;\n// export const isNull = (x: any): x is null => x === null;\n// export const isEmpty = (x: any[]): x is [] => x.length === 0;\n// type Predicate<T, U extends T> = (x: T) => x is U;\n// type AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\n// type UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\n// export const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\n// export const isObject = is(\"object\") as (x: any) => x is Record<string, any>;\n\n// export const isConstant = (x: any): x is null | undefined | number | string => any(x, isNull, isUndefined, isNumber) || (isString(x) && !(isRef(x) || isNodeName(x) || isInputRef(x)));\n// export const isNode = (x: any): x is NodeTree =>\n//     any(x, isString, isNumber, isUndefined, isNull)\n//         ? false\n//         : isArray(x) && isString(x[0])\n//             ? (isNamedNode(x) ? isNode(getNodeContents(x)) : true)\n//             : (isArray(x[0]) && !isEmpty(x[0]) && isString(x[0][0]));\n\n// const isTypeString = <T extends string>(starter: T) => (x: any): x is `${T}${string}` =>\n//     isString(x) && x.startsWith(starter);\n// export const isRef = isTypeString(\"@\");\n// export const isNodeName = isTypeString(\"=\");\n// export const isInputRef = isTypeString(\">\");\n// export const isNamedNode = (x: any): x is [NodeName, ...any[]] => isArray(x) && isNodeName(x[0]);\n// export const getNodeName = (x: any): NodeName | undefined => isNamedNode(x) ? x[0] : undefined;\n// export const getNodeContents = (x: any): any[] => isNamedNode(x) ? x.slice(1) : x;\n\nexport const str = JSON.stringify;\n\n// const gensymCounters: Record<string, number> = {};\n// export function gensym<T extends string>(prefix: T): `${T}${number}` {\n//     gensymCounters[prefix] = (gensymCounters[prefix] || 0) + 1;\n//     return `${prefix}${gensymCounters[prefix]}` as const;\n// }\n\nexport function isinstance<C>(obj: any, cls: abstract new (...args: any[]) => C): obj is C {\n    return obj instanceof cls;\n}\n\nconst idMap = new WeakMap<Object, number>();\nvar idCounter = 0;\nexport const id = (obj: any): number => {\n    if (!idMap.has(obj)) idMap.set(obj, idCounter++);\n    return idMap.get(obj)!\n}\n", "import { isinstance, str } from \"../utils\";\nimport * as AST from \"./ast\";\nimport { EvalState, NodeDef } from \"./evalState\";\nimport { RuntimeError, ErrorNote, LocationTrace } from \"./errors\";\n\nexport async function processArgsInCall(state: EvalState, doEvalArgs: boolean, site: LocationTrace, args: AST.Node[], nodeImpl: NodeDef) {\n    const newArgs: (AST.Node | null)[] = nodeImpl[1].map(arg => arg[1] !== null ? new AST.Value(site, arg[1]) : null);\n    const seenArgs: (AST.Node | null)[] = newArgs.map(_ => null);\n    var firstKW: AST.Node | undefined;\n    for (var i = 0; i < args.length; i++) {\n        const arg = args[i]!;\n        var argIndex = i;\n        if (isinstance(arg, AST.KeywordArgument)) {\n            if (!firstKW) firstKW = arg;\n            argIndex = nodeImpl[1].findIndex(a => a[0] === arg.name);\n            if (argIndex === -1) {\n                throw new RuntimeError(`no such keyword argument ${str(arg.name)} on node ${nodeImpl[0]}`, arg.loc, AST.stackToNotes(state.callstack));\n            }\n        } else {\n            if (firstKW) throw new RuntimeError(\"positional argument can't come after keyword argument\", arg.loc, [new ErrorNote(\"note: first keyword argument was here:\", firstKW.loc), ...AST.stackToNotes(state.callstack)]);\n            if (i >= nodeImpl[1].length) throw new RuntimeError(\"too many arguments to \" + nodeImpl[0], arg.edgemost(true).loc, AST.stackToNotes(state.callstack));\n        }\n        const argEntry = nodeImpl[1][argIndex]!;\n        if (seenArgs[argIndex]) {\n            throw new RuntimeError(`argument ${str(argEntry[0])} already provided`, arg.loc, [new ErrorNote(\"note: first occurrance was here:\", seenArgs[argIndex]!.edgemost(true).loc), ...AST.stackToNotes(state.callstack)]);\n        }\n        seenArgs[argIndex] = arg;\n\n        const defaultValue = argEntry[1];\n        const enumChoices = nodeImpl[3][argIndex] ?? null;\n        const walkAndReplaceSymbols = async (ast: AST.Node): Promise<AST.Node> => {\n            if (isinstance(ast, AST.Call)) return ast; // Don't walk into another call's symbols\n            if (isinstance(ast, AST.Symbol)) {\n                var value: any = enumChoices?.[ast.value];\n                if ((value ?? undefined) === undefined) {\n                    throw new RuntimeError(enumChoices ? `unknown symbol name ${str(ast.value)} for parameter` : \"symbol constant not valid here\", ast.loc, enumChoices ? [new ErrorNote(\"note: valid options are: \" + Object.keys(enumChoices).join(\", \"), ast.loc)] : []);\n                }\n                if (!isinstance(value, AST.Value)) {\n                    value = new AST.Value(ast.loc, value);\n                }\n                return value;\n            }\n            return ast.pipe(walkAndReplaceSymbols);\n        };\n        var value = await walkAndReplaceSymbols(isinstance(arg, AST.KeywordArgument) ? arg.arg : arg);\n        if (isinstance(arg, AST.DefaultPlaceholder)) {\n            if ((defaultValue ?? null) === null) {\n                throw new RuntimeError(`missing value for argument ${argEntry[0]}`, arg.loc, AST.stackToNotes(state.callstack));\n            }\n            value = new AST.Value(arg.loc, defaultValue);\n        } else if (isinstance(arg, AST.SplatValue)) {\n            throw new RuntimeError(\"splats are only valid in a list\", arg.loc, AST.stackToNotes(state.callstack));\n        } else if (doEvalArgs) {\n            value = await value.eval(state);\n            if (value.hasNodes) throw new RuntimeError(\"cannot use value dependent on audio node output in compile-time calculation\", value.loc);\n        }\n        newArgs[argIndex] = value;\n    }\n    // now all of the ones that still have null arguments, that were not provided, are truly missing\n    for (var i = 0; i < nodeImpl[1].length; i++) {\n        if (newArgs[i] === null) {\n            const argEntry = nodeImpl[1][i]!;\n            throw new RuntimeError(`missing value for argument ${argEntry[0]}`, site, AST.stackToNotes(state.callstack));\n        }\n    }\n    return newArgs as AST.Node[];\n}\n", "import { WorkletSynth } from \"../runtime/synthImpl\";\nimport * as AST from \"./ast\";\n\nexport interface EvalState {\n    env: Record<string, AST.Node>;\n    globalEnv: Record<string, AST.Node>;\n    functions: MacroDef[];\n    nodes: NodeDef[];\n    callstack: AST.Call[],\n    recursionLimit: number;\n    annotators: Record<string, (\n        val: AST.Node | null,\n        evaledArgs: AST.Node[] | null,\n        state: EvalState,\n    ) => Promise<AST.Node>>;\n}\n\nexport type MacroDef = [\n    name: string,\n    argc: number | undefined,\n    expand: (args: AST.Node[], state: EvalState) => Promise<AST.Node>,\n];\n\nexport enum NodeValueType {\n    NORMAL_OR_MONO,\n    STEREO,\n    DECOUPLED_MATH\n}\nexport type NodeDef = [\n    name: string,\n    params: [name: string, default_: number | null, type?: NodeValueType][],\n    returnType: NodeValueType,\n    enumChoices: (Record<string, number> | undefined)[],\n    impl: (synth: WorkletSynth) => (dt: number, args: number[]) => number,\n];\n\nexport function pushNamed<T extends NodeDef | MacroDef>(defs: T[], newDef: T) {\n    const i = defs.findIndex(d => d[0] === newDef[0]);\n    if (i !== -1) defs[i] = newDef;\n    else defs.push(newDef);\n}\n\nexport type NodeHelp = {\n    description: string;\n    parameters: Record<string, {\n        range?: [number, number, step?: number],\n        allowNonEnum?: boolean,\n        unit?: string,\n        description?: string,\n    }>;\n};\n", "import { isinstance } from \"../utils\";\nimport * as AST from \"./ast\";\nimport { processArgsInCall } from \"./call\";\nimport { EvalState, NodeDef, NodeValueType } from \"./evalState\";\nimport { RuntimeError } from \"./errors\";\n\nexport function makeCodeMacroExpander(name: string, finalMacro: boolean, params: AST.Node[], body: AST.Node): ((args: AST.Node[], state: EvalState) => Promise<AST.Node>) & { body: AST.Node } {\n    const fakeNodeDef: NodeDef = [name, [], NodeValueType.NORMAL_OR_MONO, [], null as any];\n    const shouldEvalParam: boolean[] = [];\n    var built = false;\n    async function build(state: EvalState) {\n        await validate(state);\n        built = true;\n        for (var i = 0; i < params.length; i++) {\n            var param = params[i]!;\n            if (isinstance(param, AST.Name)) {\n                fakeNodeDef[1].push([param.name, null]);\n                fakeNodeDef[3].push(undefined);\n                shouldEvalParam.push(true);\n            } else if (isinstance(param, AST.ParameterDescriptor)) {\n                var v: any = param.defaultValue;\n                if (isinstance(v, AST.DefaultPlaceholder)) v = null;\n                fakeNodeDef[1].push([param.name, v]);\n                fakeNodeDef[3].push(await param.enumOptions.toJS(state) as any);\n                shouldEvalParam.push(!param.lazy);\n            } else throw new RuntimeError(\"unreachable\", param.loc, AST.stackToNotes(state.callstack));\n        }\n    }\n    async function validate(state: EvalState) {\n        // TODO: check for possible infinite recursion and throw an error\n    }\n    const f = async (args: AST.Node[], state: EvalState): Promise<AST.Node> => {\n        if (!built) await build(state);\n        if (state.callstack.length > state.recursionLimit) throw new RuntimeError(\"too much recursion\", state.callstack.at(-1)!.loc, AST.stackToNotes(state.callstack));\n        const givenArgs = await processArgsInCall(state, false, state.callstack.at(-1)!.loc, args, fakeNodeDef);\n        const newState = { ...state, env: Object.create(state.globalEnv) };\n        for (var i = 0; i < fakeNodeDef[1].length; i++) {\n            const param = givenArgs[i]!;\n            newState.env[fakeNodeDef[1][i]![0]] = shouldEvalParam[i] ? await param.eval(state) : param;\n        }\n        const result = await body.eval(newState);\n        return finalMacro ? result.eval(state) : result;\n    };\n    f.body = body;\n    return f;\n}\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const min = Math.min;\nexport const max = Math.max;\nexport const clamp = (x: number, y: number, z: number) => max(min(x, z), y);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n\n// From https://stackoverflow.com/a/27205341/23626926\nexport const matMul = (a: number[][], b: number[][]) => {\n    var aNumRows = a.length, aNumCols = a[0]!.length, bNumCols = b[0]!.length, m = [] as number[][];\n    for (var r = 0; r < aNumRows; r++) {\n        m[r] = [] as number[];\n        for (var c = 0; c < bNumCols; c++) {\n            m[r]![c] = 0;\n            for (var i = 0; i < aNumCols; i++) {\n                m[r]![c]! += a[r]![i]! * b[i]![c]!;\n            }\n        }\n    }\n    return m;\n};\n", "import { matMul } from \"../math\";\nimport { str } from \"../utils\";\nimport { ParseError } from \"./errors\";\nimport type { Token } from \"./tokenizer\";\n\n/** constant used to note that an operator is not valid in this context (unary or binary) */\nexport const INVALID = -1;\n\nclass Operator {\n    cb: ((this: unknown, a: any, b: any) => any) | null = null;\n    cu: ((this: unknown, a: any) => any) | null = null;\n    constructor(\n        public b: number,\n        public u: number = INVALID,\n        public r: boolean = false) { }\n    code(b: this[\"cb\"], u: this[\"cu\"] = null) {\n        this.cb = b;\n        this.cu = u;\n        return this;\n    }\n}\n\nconst op: (...args: ConstructorParameters<typeof Operator>) => Operator = (b, u, r) => new Operator(b, u, r);\n\nexport const OPERATORS: Record<string, Operator> = {\n    // attribute sigil\n    \"#!\": op(INVALID, -Infinity),\n    // symbol name\n    \".\": op(INVALID, -Infinity),\n    // interpolate and bitwise AND\n    \"&\": op(6, 0).code((a, b) => a & b),\n    // length or as 0-ary pipeline placeholder (that is handled specially)\n    \"#\": op(INVALID, 0).code(null, a => a.length),\n    // boolean NOT\n    \"!\": op(INVALID, 0).code(null, a => !a),\n    // power\n    \"**\": op(1, INVALID, true).code((a, b) => a ** b),\n    // multiply or splat operator\n    \"*\": op(3, -Infinity).code((a, b) => a * b),\n    // divide & modulo\n    \"/\": op(3).code((a, b) => a / b),\n    \"%\": op(3).code((a, b) => a % b),\n    // matrix multiply\n    // or decorator to mark param or declaration as lazy/macro\n    \"@\": op(3, -Infinity).code(matMul as any),\n    // add\n    \"+\": op(4).code((a, b) => a + b),\n    // subtract, negate\n    \"-\": op(4, 2).code((a, b) => a - b, a => -a),\n    // boolean OR / AND\n    \"||\": op(5).code((a, b) => a || b),\n    \"&&\": op(5).code((a, b) => a && b),\n    // bitwise OR / XOR\n    \"|\": op(6).code((a, b) => a | b),\n    \"^\": op(6).code((a, b) => a ^ b),\n    // bit shifting (slightly before other bitwise to match C)\n    \">>\": op(5.9).code((a, b) => a >> b),\n    \"<<\": op(5.9).code((a, b) => a << b),\n    // comparison\n    \"==\": op(7).code((a, b) => a == b),\n    \">=\": op(7).code((a, b) => a >= b),\n    \">\": op(7).code((a, b) => a > b),\n    \"<=\": op(7).code((a, b) => a <= b),\n    \"<\": op(7).code((a, b) => a < b),\n    \"!=\": op(7).code((a, b) => a != b),\n    // pipe\n    \"|>\": op(8),\n    // conditional in 2 parts (treated as binary and postprocessed for simplicity)\n    // colon is also used for keyword arguments\n    \":\": op(9),\n    \"?\": op(10),\n    // assignment operator (no overloads and handles specially, just here so it can be parsed in the right spot)\n    \"=\": op(11),\n    // mapping operator (for inside lists)\n    \"=>\": op(12),\n    // define operator (handled specially)\n    \":-\": op(12),\n    // statement separator\n    \",\": op(13).code((_, b) => b),\n    \";\": op(13),\n};\n\nexport const OP_REGEX = new RegExp(`^(${Object.keys(OPERATORS).sort((a, b) => b.length - a.length).map(e => e.replaceAll(/([()[\\]{}*+?|^$\\\\.])/g, \"\\\\$1\")).join(\"|\")})`);\n\nexport function getPrecedence(token: string, unary: boolean): number {\n    return OPERATORS[token]![unary ? \"u\" : \"b\"] ?? INVALID;\n}\n\nexport function getPrecedenceAndCheckValidity(token: Token, isUnary: boolean): number {\n    const keyOperator = token.a ? \"=\" : token.t;\n    const realOperator = token.t + (token.a ? \"=\" : \"\")\n    const mePrecedence = getPrecedence(keyOperator, isUnary);\n    if (mePrecedence === INVALID) {\n        throw new ParseError(`${str(realOperator)} is not valid as a ${[\"binary\", \"unary\"][+isUnary]} operator`, token.s);\n    }\n    return mePrecedence;\n}\n\nexport function isRightAssociative(token: string): boolean {\n    return OPERATORS[token]!.r;\n}\n", "import { AutomatedValueMethod } from \"../runtime/automation\";\n\nexport enum Opcode {\n    /** next is the constant */\n    PUSH_CONSTANT,\n    PUSH_INPUT_SAMPLES,\n    PUSH_PITCH,\n    PUSH_EXPRESSION,\n    PUSH_GATE,\n    MARK_STILL_ALIVE,\n    DROP_TOP,\n    PUSH_FRESH_EMPTY_LIST,\n    APPEND_TO_LIST,\n    EXTEND_TO_LIST,\n    /** next is opcode */\n    DO_BINARY_OP,\n    DO_BINARY_OP_STEREO,\n    /** next is opcode */\n    DO_UNARY_OP,\n    DO_UNARY_OP_STEREO,\n    /** next is register no. */\n    GET_REGISTER,\n    /** next is register no. */\n    TAP_REGISTER,\n    CONDITIONAL_SELECT,\n    /** doubles the sample into a [sample, sample] left right pair */\n    STEREO_DOUBLE_WIDEN,\n    /** next 2 is node no, argc */\n    APPLY_NODE,\n    /** next 3 is node no A and B, argc */\n    APPLY_DOUBLE_NODE_STEREO,\n    /** next is input number, returns 0 if doesn't exist */\n    GET_MOD,\n}\n\ntype Command = [Opcode, a?: number | string | [number, number], b?: number, c?: number];\nexport type Program = Command[];\n\nexport interface CompiledVoiceData {\n    p: Program;\n    r: string[];\n    nn: string[];\n    tosStereo: boolean;\n    mods: [name: string, initial: number, mode: AutomatedValueMethod][]\n}\n\nexport function allocRegister(name: string, state: CompiledVoiceData): number {\n    const i = state.r.indexOf(name);\n    if (i === -1) return state.r.push(name) - 1;\n    return i;\n}\nexport function allocNode(name: string, state: CompiledVoiceData): number {\n    return state.nn.push(name) - 1;\n}\n\nexport function allocMod(name: string, state: CompiledVoiceData, initial: number, mode: AutomatedValueMethod): number {\n    return state.mods.push([name, initial, mode]) - 1;\n}\n", "import { str } from \"../utils\";\nimport { LocationTrace, ParseError } from \"./errors\";\nimport { OP_REGEX } from \"./operator\";\n\nexport enum TokenType {\n    NAME,\n    NUMBER,\n    PAREN,\n    OPERATOR,\n    PIPE_PLACEHOLDER,\n    STRING_BEGIN,\n    STRING_END,\n    STRING_BODY,\n    STRING_ESC,\n    INVALID_STRING_ESCAPE,\n}\n\nexport class Token {\n    constructor(public t: string,\n        public s: LocationTrace,\n        public k: TokenType,\n        public a?: LocationTrace) { }\n}\n\ntype Rule = [State[], RegExp, keepType?: TokenType | undefined, stateOp?: State | undefined];\n\nenum State {\n    INITIAL,\n    BLOCK_COMMENT,\n    STRING,\n    RAW_STRING,\n    POP,\n}\n\nconst TOKENIZE_RULES: Rule[] = [\n    // comments\n    [[State.INITIAL], /^\\/\\/[^\\n]*/],\n    [[State.INITIAL, State.BLOCK_COMMENT], /^\\/\\*/, , State.BLOCK_COMMENT],\n    [[State.BLOCK_COMMENT], /^\\*\\//, , State.POP],\n    [[State.BLOCK_COMMENT], /^((?!(\\*\\/)|(\\/\\*)).)+/],\n    // strings with escapes\n    [[State.INITIAL], /^\"/, TokenType.STRING_BEGIN, State.STRING],\n    [[State.STRING], /^\"/, TokenType.STRING_END, State.POP],\n    [[State.STRING], /^\\\\[abefnrtvz'\"\\\\]/, TokenType.STRING_ESC],\n    [[State.STRING], /^\\\\(x[0-9a-f]{2}|u[0-9a-f]{4}|u\\{[0-9a-f]+\\})/i, TokenType.STRING_ESC],\n    [[State.STRING], /^\\\\./, TokenType.INVALID_STRING_ESCAPE],\n    [[State.STRING], /^[^\\\\\"]+/, TokenType.STRING_BODY],\n    // strings without escapes\n    [[State.INITIAL], /^'/, TokenType.STRING_BEGIN, State.RAW_STRING],\n    [[State.RAW_STRING], /^'/, TokenType.STRING_END, State.POP],\n    [[State.RAW_STRING], /^\\\\'/, TokenType.STRING_ESC],\n    [[State.RAW_STRING], /^\\\\./, TokenType.STRING_BODY],\n    [[State.RAW_STRING], /^[^\\\\']+/, TokenType.STRING_BODY],\n    // number\n    [[State.INITIAL], /^-?(\\.\\d+|\\d+\\.?\\d*)(e[+-]?\\d+)?/i, TokenType.NUMBER],\n    // operators\n    [[State.INITIAL], OP_REGEX, TokenType.OPERATOR],\n    // parens\n    [[State.INITIAL], /^[()[\\]{}]/, TokenType.PAREN],\n    // names\n    [[State.INITIAL], /^\\w+/, TokenType.NAME],\n    // discard whitespace elsewhere\n    [[State.INITIAL, State.BLOCK_COMMENT], /^[\\s\\n]+/],\n];\n\nexport function tokenize(source: string, filename: string) {\n    var line = 0, col = 0;\n    const out: Token[] = [];\n    const stateStack: State[] = [State.INITIAL];\n    tokens: while (source.length > 0) {\n        for (var [curStates, regex, type, newState] of TOKENIZE_RULES) {\n            if (curStates.every(s => stateStack.at(-1) !== s)) continue;\n            const match = regex.exec(source);\n            if (match) {\n                const chunk = match[0];\n                if (type !== undefined) out.push(new Token(chunk, new LocationTrace(line, col, filename), type));\n                const interlines = chunk.split(\"\\n\");\n                if (interlines.length > 1) {\n                    col = interlines.at(-1)!.length;\n                    line += interlines.length - 1;\n                } else {\n                    col += chunk.length;\n                }\n                source = source.slice(chunk.length);\n                if (newState !== undefined) {\n                    if (newState === State.POP) stateStack.pop();\n                    else stateStack.push(newState);\n                }\n                continue tokens;\n            }\n        }\n        throw new ParseError(`unexpected ${str(source[0])}`, new LocationTrace(line, col, filename));\n    }\n    return out;\n}\n", "import { isinstance } from \"../utils\";\nimport * as AST from \"./ast\";\nimport { LocationTrace, ParseError } from \"./errors\";\nimport { getPrecedenceAndCheckValidity, isRightAssociative } from \"./operator\";\nimport { Token, TokenType } from \"./tokenizer\";\n\nexport function treeifyExpression(tokens: (AST.Node | Token)[], lift: boolean = false): AST.Node {\n    var i: number;\n    attributesHack(tokens);\n    pipePlaceholdersHack(tokens);\n    commaAndAssignHack(tokens);\n    const firstToken = tokens.find(t => isinstance(t, Token));\n    // The algorithm is 'recursive lifting':\n    // first try to find the highest precedence unary operator with no higher binary after its atom, and lift it into an atom\n    // if no such unary exists find the highest precedence binary and lift it ito an atom\n    // then repeat until there is only one atom\n    while (tokens.length > 1) {\n        // 'highest precedence' == lowest numerically\n        var bestBinaryPrecedence = Infinity, bestBinaryIndex = -1;\n        var bestUnaryPrecedence = Infinity, bestUnaryIndex = -1;\n        var prevWasAtom = false;\n        const lastAtomIndex = tokens.findLastIndex(e => isinstance(e, AST.Node));\n        for (i = 0; i < tokens.length; i++) {\n            const token = tokens[i]!;\n            if (isinstance(token, AST.Node)) prevWasAtom = true;\n            else {\n                if (i > lastAtomIndex) {\n                    throw new ParseError(\"expected a value after operator\", token.s);\n                }\n                if (prevWasAtom) {\n                    const precedence = getPrecedenceAndCheckValidity(token, false);\n                    if (bestBinaryPrecedence > precedence || (bestBinaryPrecedence === precedence && isRightAssociative(token.t))) {\n                        bestBinaryPrecedence = precedence;\n                        bestBinaryIndex = i;\n                    }\n                } else {\n                    // possible unary operator to lift\n                    if (!(isinstance(tokens[i + 1]!, AST.Node))) continue; // not innermost unary\n                    const mePrecedence = getPrecedenceAndCheckValidity(token, true);\n                    const opAfter = tokens[i + 2] as Token | undefined;\n                    if (opAfter) {\n                        const opAfterPrecedence = getPrecedenceAndCheckValidity(opAfter, false);\n                        if (opAfterPrecedence < mePrecedence) continue; // don't lift yet\n                    }\n                    // we can lift this\n                    if (bestUnaryPrecedence > mePrecedence) {\n                        bestUnaryPrecedence = mePrecedence;\n                        bestUnaryIndex = i;\n                    }\n                }\n                prevWasAtom = false;\n            }\n        }\n        if (bestUnaryIndex >= 0) {\n            const [op, val] = tokens.splice(bestUnaryIndex, 2) as [Token, AST.Node];\n            tokens.splice(bestUnaryIndex, 0, new AST.UnaryOp(op.s, op.t, val));\n        } else if (bestBinaryIndex >= 0) {\n            const [left, op, right] = tokens.splice(bestBinaryIndex - 1, 3) as [AST.Node, Token, AST.Node];\n            const math = new AST.BinaryOp(op.s, op.t, left, right, false, op.a);\n            tokens.splice(bestBinaryIndex - 1, 0, math);\n        } else {\n            throw new ParseError(\"unknown error in expression parsing\", firstToken?.s);\n        }\n    }\n    const result = tokens[0];\n    if (lift && isinstance(result, AST.BinaryOp)) result.noLift = true;\n    return result as AST.Node;\n}\n\nfunction attributesHack(tokens: (AST.Node | Token)[]) {\n    var attrs: AST.Node[] = [];\n    for (var i = 0; i < tokens.length; i++) {\n        const here = tokens[i]!;\n        if (isinstance(here, Token)) {\n            if (here.t === \"#!\") {\n                const value = tokens.splice(i, 2)[1];\n                if (!(isinstance(value, AST.Name) || isinstance(value, AST.Call))) {\n                    throw new ParseError(\"expected attribute after '#!'\", here.s);\n                }\n                attrs.push(value);\n                i--;\n            } else if (attrs.length > 0) {\n                tokens.splice(i, 0, new AST.AnnotatedValue(here.s, attrs, null))\n                attrs = [];\n            }\n        } else if (attrs.length > 0) {\n            tokens[i] = new AST.AnnotatedValue(here.loc, attrs, here);\n            attrs = [];\n        }\n    }\n    if (attrs.length > 0) {\n        tokens.push(new AST.AnnotatedValue(attrs.at(-1)!.loc, attrs, null));\n    }\n}\n\nfunction pipePlaceholdersHack(tokens: (AST.Node | Token)[]) {\n    for (var i = 0; i < tokens.length; i++) {\n        const before = tokens[i - 1];\n        const here = tokens[i];\n        const after = tokens[i + 1];\n        if (isinstance(here, Token) && here.t === \"#\" && !(isinstance(before, AST.Node) || isinstance(after, AST.Node))) {\n            tokens[i] = new AST.PipePlaceholder(here.s);\n        }\n    }\n}\n\nfunction commaAndAssignHack(tokens: (AST.Node | Token)[]) {\n    for (var i = -1; i < tokens.length; i++) {\n        const here = tokens[i];\n        const next = tokens[i + 1];\n        if (commaIsh(here) && commaIsh(next)) {\n            // insert default sentinels in between consecutive commas or colons\n            tokens.splice(i + 1, 0, new AST.DefaultPlaceholder(next?.s ?? here?.s ?? LocationTrace.nowhere));\n        } else if (tokenLike(here) && tokenLike(next) && here.k === TokenType.OPERATOR && next.k === TokenType.OPERATOR && next.t === \"=\") {\n            tokens.splice(i, 2, new Token(here.t, here.s, here.k, next.s));\n        } else if (isinstance(here, AST.Node) && isinstance(next, AST.Node)) {\n            throw new ParseError(\"expected operator before value\", next.edgemost(false).loc);\n        }\n    }\n}\n\nfunction commaIsh(x: Token | AST.Node | undefined): x is Token | undefined {\n    return !x || (tokenLike(x) && /^[,:;]$/.test(x.t));\n}\n\nfunction tokenLike(x: Token | AST.Node | undefined) {\n    return isinstance(x, Token);\n}\n", "import { isinstance, str } from \"../utils\";\nimport * as AST from \"./ast\";\nimport { ErrorNote, ParseError } from \"./errors\";\nimport { treeifyExpression } from \"./expression\";\nimport { Token, TokenType } from \"./tokenizer\";\n\n\nexport function liftCommas(expr: AST.Node, force = false): AST.Node[] {\n    return isinstance(expr, AST.BinaryOp) && /^[,;]$/.test(expr.op) && (force || !expr.noLift) ? [...liftCommas(expr.left), ...liftCommas(expr.right)] : [expr];\n}\n\n// string string string\nfunction unescape(string: string): string {\n    return ({\n        a: \"\\a\", b: \"\\b\", e: \"\\e\", f: \"\\f\", n: \"\\n\", r: \"\\r\", t: \"\\t\", v: \"\\v\", z: \"\\0\", \"'\": \"'\", \"\\\"\": \"\\\"\", \"\\\\\": \"\\\\\",\n        x: false as const,\n        u: false as const\n    }[string.toLowerCase()[0]!] ?? string) || String.fromCodePoint(parseInt(/[0-9a-f]+/i.exec(string)![0], 16));\n}\n\nexport function parseTokens(tokens: Token[]): AST.Node {\n    var pos = 0;\n    const nextToken = <T extends boolean>(expect: T, beginParen?: Token): T extends true ? Token : Token | undefined => {\n        if (expect && pos >= tokens.length) {\n            if (beginParen) {\n                throw new ParseError(`${str(beginParen.t)} was never closed`, beginParen.s);\n            }\n            const last = tokens.at(-1);\n            throw new ParseError(\"unexpected EOF\", last?.s);\n        }\n        return tokens[pos++]!;\n    };\n    const parseString = (start: Token): AST.Value => {\n        var out = \"\";\n        str: for (; ;) {\n            const token = nextToken(true, start);\n            switch (token.k) {\n                case TokenType.STRING_END:\n                    break str;\n                case TokenType.STRING_BODY:\n                    out += token.t;\n                    break;\n                case TokenType.STRING_ESC:\n                    out += unescape(token.t.slice(1));\n                    break;\n                case TokenType.INVALID_STRING_ESCAPE:\n                    throw new ParseError(\"illegal escape sequence\", token.s);\n            }\n        }\n        return new AST.Value(start.s, out);\n    }\n    const parseThing = (requireNext: boolean, beginParen?: Token): AST.Node | undefined => {\n        const token = nextToken(requireNext, beginParen);\n        if (token === undefined) return undefined;\n        switch (token.k) {\n            case TokenType.NUMBER:\n                return new AST.Value(token.s, parseFloat(token.t));\n            case TokenType.STRING_BEGIN:\n                return parseString(token);\n            case TokenType.NAME:\n                const after = nextToken(false);\n                if (after && after.t === \"(\") {\n                    return new AST.Call(token.s, token.t, liftCommas(parseExpression(\")\", after), true));\n                }\n                pos--; // make it a peek\n                return new AST.Name(token.s, token.t);\n            // @ts-expect-error\n            // fallthrough is intentional!\n            case TokenType.PAREN:\n                switch (token.t) {\n                    case \"{\":\n                        return new AST.Template(token.s, parseExpression(\"}\", token));\n                    case \"[\":\n                        return new AST.List(token.s, liftCommas(parseExpression(\"]\", token), true));\n                    case \"(\":\n                        return parseExpression(\")\", token, true);\n                    case \")\":\n                    case \"]\":\n                    case \"}\":\n                        throw new ParseError(beginParen ? `expected ${str({ \"(\": \")\", \"[\": \"]\", \"{\": \"}\" }[beginParen.t])}` : \"stray close paren\", token.s, beginParen ? [new ErrorNote(\"note: to match this \" + str(beginParen.t), beginParen.s)] : []);\n                }\n            case TokenType.OPERATOR:\n                if (!requireNext && /^[,;)]$/.test(token.t)) {\n                    pos--;\n                    return;\n                }\n        }\n        throw new ParseError(`unexpected ${{ [TokenType.NAME]: \"name\", [TokenType.OPERATOR]: \"operator\" }[token.t] ?? str(token.t)}`, token.s);\n    };\n    const parseExpression = (end: string | false, beginParen?: Token, lift = false): AST.Node => {\n        const exprItems: (AST.Node | Token)[] = [];\n        for (; ;) {\n            var tok = nextToken(!!end, beginParen);\n            if (!end && tok === undefined) break;\n            if (tok!.t === end) break;\n            switch (tok!.k) {\n                case TokenType.OPERATOR:\n                    exprItems.push(tok!);\n                    break;\n                default:\n                    pos--;\n                    const thing = parseThing(false, beginParen);\n                    if (thing !== undefined) exprItems.push(thing);\n            }\n        }\n        return treeifyExpression(exprItems, lift);\n    };\n    return parseExpression(false);\n}\n", "import { isinstance } from \"../utils\";\nimport * as AST from \"./ast\";\n\nexport function isPipe(a: AST.Node): a is AST.BinaryOp {\n    return isinstance(a, AST.BinaryOp) && a.op === \"|>\";\n}\n\nexport async function countPlaceholdersIn(expr: AST.Node): Promise<number> {\n    var numPlaceholders = 0;\n    const count = async (ast: AST.Node) => {\n        if (isinstance(ast, AST.PipePlaceholder)) numPlaceholders++;\n        if (isPipe(ast)) {\n            await ast.left.pipe(count);\n        } else {\n            await ast.pipe(count);\n        }\n        return ast;\n    }\n    await count(expr);\n    return numPlaceholders;\n}\n\nexport async function replacePlaceholdersWith(ast: AST.Node, with_: AST.Node): Promise<AST.Node> {\n    if (isinstance(ast, AST.PipePlaceholder)) {\n        return with_;\n    } else if (isPipe(ast)) {\n        return await ast.pipe(async a => a === ast.left ? a : await replacePlaceholdersWith(a, with_));\n    } else {\n        return await ast.pipe(async a => await replacePlaceholdersWith(a, with_))\n    }\n}\n", "import { isinstance, str } from \"../utils\";\nimport * as AST from \"./ast\";\nimport { liftCommas } from \"./core\";\nimport { ErrorNote, ParseError } from \"./errors\";\nimport { countPlaceholdersIn, isPipe, replacePlaceholdersWith } from \"./pipe\";\n\nconst TRANSFORM_PASSES = [\n\n    async function expandSymbols(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.UnaryOp) || ast.op !== \".\") return ast.pipe(expandSymbols);\n        if (!isinstance(ast.value, AST.Name)) {\n            throw new ParseError('unexpected \".\"', ast.loc);\n        }\n        return new AST.Symbol(ast.value.loc, ast.value.name);\n    },\n\n    async function expandInterpolations(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandInterpolations);\n        if (isinstance(ast, AST.UnaryOp) && ast.op === \"&\") ast = new AST.InterpolatedValue(ast.loc, ast.value);\n        return ast;\n    },\n\n    async function expandMapping(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandMapping);\n        if (!isinstance(ast, AST.List)) return ast;\n        const elements = ast.values;\n        const firstKVIndex = elements.findIndex(e => (isinstance(e, AST.BinaryOp) && e.op === \"=>\"));\n        if (firstKVIndex < 0) {\n            const firstColon = elements.find(e => (isinstance(e, AST.BinaryOp) && e.op === \":\"));\n            if (firstColon) {\n                throw new ParseError('mappings use \"=>\", not \":\"', firstColon.loc);\n            }\n            return ast;\n        }\n        const kvPairs: { key: AST.Node, val: AST.Node }[] = [];\n        for (var i = 0; i < elements.length; i++) {\n            const el = elements[i]!;\n            if (!isinstance(el, AST.BinaryOp) || el.op !== \"=>\") {\n                throw new ParseError(isinstance(el, AST.DefaultPlaceholder) ? \"illegal trailing comma in mapping\" : 'expected \"=>\" after key value', el.edgemost(false).loc, i < firstKVIndex ? [new ErrorNote('hint: the \"=>\" first used here makes this a mapping, not a list', elements[firstKVIndex]!.loc)] : []);\n            }\n            kvPairs.push({ key: el.left, val: el.right });\n        }\n        return new AST.Mapping(ast.edgemost(true).loc, kvPairs);\n    },\n\n    async function commasToBlocks(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || (ast.op !== \",\" && ast.op !== \";\")) return ast.pipe(commasToBlocks);\n        return new AST.Block(ast.edgemost(true).loc, await Promise.all(liftCommas(ast, true).map(commasToBlocks)));\n    },\n\n    async function trimDefaultSentinelsInCallExpression(ast: any): Promise<AST.Node> {\n        ast = await ast.pipe(trimDefaultSentinelsInCallExpression);\n        if (isinstance(ast, AST.Call))\n            while (isinstance(ast.args.at(-1), AST.DefaultPlaceholder)) ast.args.pop();\n        return ast;\n    },\n\n    async function trimDefaultSentinelsInBlock(ast: any): Promise<AST.Node> {\n        ast = await ast.pipe(trimDefaultSentinelsInBlock);\n        if (isinstance(ast, AST.Block)) {\n            for (var i = 0; i < ast.body.length; i++) {\n                if (isinstance(ast.body[i], AST.DefaultPlaceholder)) {\n                    ast.body.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        return ast;\n    },\n\n    async function expandDefinitions(ast: AST.Node, alreadyExpanded = false): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \":-\") return ast.pipe(expandDefinitions);\n        var header = alreadyExpanded ? ast.left : await ast.left.pipe(expandDefinitions);\n        const body = alreadyExpanded ? ast.right : await ast.right.pipe(expandDefinitions);\n        var isMacro = false;\n        if (isinstance(header, AST.UnaryOp) && header.op === \"@\") {\n            header = header.value;\n            isMacro = true;\n        }\n        if (!isinstance(header, AST.Call)) {\n            if (isinstance(header, AST.AnnotatedValue) && header.value !== null) {\n                ast.left = header.value;\n                return new AST.AnnotatedValue(header.loc, header.attributes, await expandDefinitions(ast, true));\n            }\n            throw new ParseError(\"illegal header\", header.edgemost(true).loc, [new ErrorNote(\"note: definition operator is here\", ast.loc)]);\n        }\n        const params = header.args;\n        var firstOptional: AST.Node | undefined;\n        const realParams: AST.Node[] = [];\n        for (var i = 0; i < params.length; i++) {\n            var param = params[i]!;\n            var lazy = false;\n            if (isinstance(param, AST.UnaryOp) && param.op === \"@\") {\n                param = param.value;\n                lazy = true;\n            }\n            if (isinstance(param, AST.Name)) {\n                if (firstOptional) {\n                    throw new ParseError(\"required parameter follows optional parameter\", param.loc, [new ErrorNote(\"note: first optional parameter is here\", firstOptional.loc)]);\n                }\n                realParams.push(lazy ? new AST.ParameterDescriptor(param.loc, param.name, new AST.Mapping(param.loc, []), new AST.DefaultPlaceholder(param.loc), true) : param);\n                continue;\n            }\n            if (!isinstance(param, AST.BinaryOp) || (param.op !== \":\" && param.op !== \"=\")) {\n                throw new ParseError(\"illegal parameter\", param.edgemost(true).loc);\n            }\n            var name = param.left, enums: AST.Mapping, default_: AST.Node | undefined;\n            switch (param.op) {\n                case \":\":\n                    default_ = undefined;\n                    if (!isinstance(param.right, AST.Mapping)) {\n                        throw new ParseError(\"expected a mapping\", param.right.loc);\n                    }\n                    enums = param.right;\n                    for (var { key } of enums.mapping) {\n                        if (!isinstance(key, AST.Symbol)) {\n                            throw new ParseError(\"expected a symbol here\", key.edgemost(false).loc, [new ErrorNote(`note: while defining enum options for parameter`, name.loc), ...(isinstance(key, AST.Name) ? [new ErrorNote(`hint: put a \".\" before the ${str(key.name)} to make it a static symbol instead of a variable`, key.loc)] : [])]);\n                        }\n                    }\n                    break;\n                case \"=\":\n                    enums = new AST.Mapping(param.loc, []);\n                    if (isinstance(name, AST.BinaryOp) && name.op === \":\") {\n                        if (!isinstance(name.right, AST.Mapping)) {\n                            throw new ParseError(\"expected a mapping\", name.right.loc);\n                        }\n                        enums = name.right;\n                        name = name.left;\n                    }\n                    default_ = param.right;\n                    break;\n                default:\n                    throw \"unreachable\";\n            }\n            if (default_ === undefined) {\n                default_ = new AST.DefaultPlaceholder(name.loc);\n            } else {\n                if (!firstOptional) firstOptional = name;\n            }\n            if (isinstance(name, AST.UnaryOp) && name.op === \"@\") {\n                param = name.value;\n                lazy = true;\n            }\n            if (!isinstance(name, AST.Name)) {\n                throw new ParseError(\"illegal parameter name for optional parameter\", name.edgemost(false).loc);\n            }\n            realParams.push(new AST.ParameterDescriptor(name.loc, name.name, enums, default_, lazy));\n        }\n        return new AST.Definition(header.loc, header.name, isMacro, realParams, body);\n    },\n\n    async function expandAssignments(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || (ast.op !== \"=\" && !ast.assign)) return ast.pipe(expandAssignments);\n        const target = await ast.left.pipe(expandAssignments);\n        var body = await ast.right.pipe(expandAssignments);\n        if (ast.assign) {\n            body = new AST.BinaryOp(ast.loc, ast.op, target, body);\n        }\n        return new AST.Assignment(target.loc, target, body);\n    },\n\n    async function expandTernaryOperators(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \"?\") return ast.pipe(expandTernaryOperators);\n        const condition = await ast.left.pipe(expandTernaryOperators);\n        const choices = await ast.right.pipe(expandTernaryOperators);\n        if (!isinstance(choices, AST.BinaryOp) || choices.op !== \":\") {\n            throw new ParseError('expected \":\" after expression', (isinstance(choices, AST.BinaryOp) ? choices : choices.edgemost(false)).loc, [new ErrorNote('note: \"?\" is here:', ast.loc)]);\n        }\n        return new AST.Conditional(ast.loc, condition, choices.left, choices.right);\n    },\n\n    async function createKeywordArguments(ast: AST.Node, parent: AST.Node | null = null): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \":\") return ast.pipe(e => createKeywordArguments(e, ast));\n        const name = await ast.left.pipe(e => createKeywordArguments(e));\n        const value = await ast.right.pipe(e => createKeywordArguments(e));\n        if (!isinstance(name, AST.Name)) {\n            throw (isinstance(parent, AST.Call)\n                ? new ParseError('expected name before \":\"', name.edgemost(false).loc)\n                : new ParseError('unexpected \":\"', ast.loc));\n        }\n        if (!isinstance(parent, AST.Call) && !isinstance(parent, AST.Definition)) {\n            throw new ParseError(\"named parameter not directly inside a callsite\", name.loc);\n        }\n        return new AST.KeywordArgument(name.loc, name.name, value);\n    },\n\n    async function fixAndValidateListDefaultSentinels(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.List)) return ast.pipe(fixAndValidateListDefaultSentinels);\n        const args = await Promise.all(ast.values.map(fixAndValidateListDefaultSentinels));\n        // Special case for empty list\n        if (args.length === 1 && isinstance(args[0], AST.DefaultPlaceholder)) {\n            return new AST.List(ast.loc, []);\n        }\n        for (var i = 0; i < args.length; i++) {\n            const el = args[i]!;\n            if (isinstance(el, AST.DefaultPlaceholder)) {\n                throw new ParseError((i + 1) === args.length ? \"illegal trailing comma in list\" : \"empty elements not allowed in list\", el.loc, [new ErrorNote(\"note: list starts here\", ast.loc)]);\n            }\n        }\n        return new AST.List(ast.loc, args);\n    },\n\n    async function transformUnarySplatOperators(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.UnaryOp) || ast.op !== \"*\") return ast.pipe(transformUnarySplatOperators);\n        return new AST.SplatValue(ast.loc, await ast.value.pipe(transformUnarySplatOperators));\n    },\n\n    async function expandPipeOperators(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandPipeOperators);\n        if (!isPipe(ast)) return ast;\n        const sym = new AST.Name(ast.loc, [\"_pipe\", ast.loc.file.replace(/[^a-z]/ig, \"\"), ast.loc.line, ast.loc.col].join(\"_\"));\n        const arg = ast.left;\n        const expr = ast.right;\n        const numPlaceholders = await countPlaceholdersIn(expr);\n        if (numPlaceholders === 0) {\n            throw new ParseError(\"missing '#' placeholder in pipe expression\", expr.loc, [new ErrorNote(\"note: required by this pipe operator\", ast.loc)]);\n        } else if (numPlaceholders > 1 && !isinstance(arg, AST.Value)) {\n            return new AST.Block(ast.loc, [new AST.Assignment(ast.loc, sym, arg), await replacePlaceholdersWith(expr, sym)]);\n        } else {\n            return replacePlaceholdersWith(expr, arg);\n        }\n    }\n\n];\n\nexport async function transformAST(ast: AST.Node): Promise<AST.Node> {\n    for (var transformer of TRANSFORM_PASSES) {\n        ast = await transformer(ast);\n    }\n    return ast;\n}\n", "import * as AST from \"./ast\";\nimport { parseTokens } from \"./core\";\nimport { tokenize } from \"./tokenizer\";\nimport { transformAST } from \"./transformers\";\n\nexport function parse(src: string, filename: string): Promise<AST.Node> {\n    return transformAST(parseTokens(tokenize(src, filename)));\n}\n"],
  "mappings": "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",
  "names": ["Symbol", "Symbol", "value", "Opcode", "Symbol", "op", "op", "Symbol"]
}
