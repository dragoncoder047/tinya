{
  "version": 3,
  "sources": ["../src/compiler/call.ts", "../src/compiler/codemacro.ts", "../src/compiler/ast.ts", "../src/compiler/tokenizer.ts", "../src/compiler/expression.ts", "../src/compiler/core.ts", "../src/compiler/pipe.ts", "../src/compiler/transformers.ts", "../src/compiler/index.ts"],
  "sourcesContent": ["import { isinstance, str } from \"../utils\";\nimport { AST } from \"./ast\";\nimport { EvalState, NodeDef } from \"./evalState\";\nimport { RuntimeError, ErrorNote, LocationTrace } from \"./errors\";\n\nexport async function processArgsInCall(state: EvalState, doEvalArgs: boolean, site: LocationTrace, args: AST.Node[], nodeImpl: NodeDef) {\n    const newArgs: AST.Node[] = [];\n    const seenArgs: Record<string, AST.Node> = {};\n    var firstKW: AST.Node | undefined;\n    for (var i = 0; i < args.length; i++) {\n        const arg = args[i]!;\n        var argIndex = i;\n        if (isinstance(arg, AST.KeywordArgument)) {\n            if (seenArgs[arg.name]) {\n                throw new RuntimeError(`argument ${str(arg.name)} already provided`, arg.loc, [new ErrorNote(\"note: first occurrance was here:\", seenArgs[arg.name]!.edgemost(true).loc), ...AST.stackToNotes(state.callstack)]);\n            }\n            if (!firstKW) firstKW = arg;\n            argIndex = nodeImpl[1].findIndex(a => a[0] === arg.name);\n            if (argIndex === -1) {\n                throw new RuntimeError(`no such keyword argument ${str(arg.name)} on node ${nodeImpl[0]}`, arg.loc, AST.stackToNotes(state.callstack));\n            }\n        } else {\n            if (firstKW) throw new RuntimeError(\"positional argument can't come after keyword argument\", arg.loc, [new ErrorNote(\"note: first keyword argument was here:\", firstKW.loc), ...AST.stackToNotes(state.callstack)]);\n            if (i >= nodeImpl[1].length) throw new RuntimeError(\"too many arguments to \" + nodeImpl[0], arg.edgemost(true).loc, AST.stackToNotes(state.callstack));\n        }\n        const argEntry = nodeImpl[1][argIndex]!;\n        seenArgs[argEntry[0]] = arg;\n        const defaultValue = argEntry[1];\n        const enumChoices = nodeImpl[3][argIndex] ?? null;\n        const walkAndReplaceSymbols = async (ast: AST.Node): Promise<AST.Node> => {\n                if (isinstance(ast, AST.Call)) return ast; // Don't walk into another call's symbols\n                if (isinstance(ast, AST.Symbol)) {\n                    var value: any = enumChoices?.[ast.value];\n                    if ((value ?? undefined) === undefined) {\n                        throw new RuntimeError(enumChoices ? `unknown symbol name ${str(ast.value)} for parameter` : \"symbol constant not valid here\", ast.loc, enumChoices ? [new ErrorNote(\"note: valid options are: \" + Object.keys(enumChoices).join(\", \"), ast.loc)] : []);\n                    }\n                    if (!isinstance(value, AST.Value)) {\n                        value = new AST.Value(ast.loc, value);\n                    }\n                    return value;\n                }\n                return ast.pipe(walkAndReplaceSymbols);\n            };\n        var value = await walkAndReplaceSymbols(arg);\n        if (isinstance(arg, AST.DefaultPlaceholder)) {\n            if ((defaultValue ?? null) === null) {\n                throw new RuntimeError(`missing value for argument ${argEntry[0]}`, arg.loc, AST.stackToNotes(state.callstack));\n            }\n            value = new AST.Value(arg.loc, defaultValue);\n        } else if (isinstance(arg, AST.SplatValue)) {\n            throw new RuntimeError(\"splats are only valid in a list\", arg.loc, AST.stackToNotes(state.callstack));\n        } else if (doEvalArgs) {\n            value = await value.eval(state);\n        }\n        newArgs[argIndex] = value;\n    }\n    for (var i = 0; i < nodeImpl[1].length; i++) {\n        if (newArgs[i] === undefined) {\n            const argEntry = nodeImpl[1][i]!;\n            const defaultValue = argEntry[1];\n            if ((defaultValue ?? null) === null) {\n                throw new RuntimeError(`missing value for argument ${argEntry[0]}`, site, AST.stackToNotes(state.callstack));\n            }\n            newArgs[i] = new AST.Value(site, defaultValue);\n        }\n    }\n    return newArgs;\n}\n", "import { isinstance } from \"../utils\";\nimport { AST } from \"./ast\";\nimport { processArgsInCall } from \"./call\";\nimport { EvalState, NodeDef, NodeValueType } from \"./evalState\";\nimport { RuntimeError } from \"./errors\";\n\nexport function makeCodeMacroExpander(name: string, finalMacro: boolean, params: AST.Node[], body: AST.Node): ((args: AST.Node[], state: EvalState) => Promise<AST.Node>) & { body: AST.Node } {\n    const fakeNodeDef: NodeDef = [name, [], NodeValueType.NORMAL_OR_MONO, [], null as any];\n    const shouldEvalParam: boolean[] = [];\n    var built = false;\n    const f = async (args: AST.Node[], state: EvalState): Promise<AST.Node> => {\n        if (!built) await build(state);\n        if (state.callstack.length > state.recursionLimit) throw new RuntimeError(\"too much recursion\", state.callstack.at(-1)!.loc, AST.stackToNotes(state.callstack));\n        const givenArgs = await processArgsInCall(state, false, state.callstack.at(-1)!.loc, args, fakeNodeDef);\n        const newState = { ...state, env: Object.create(state.globalEnv) };\n        for (var i = 0; i < fakeNodeDef[1].length; i++) {\n            const param = givenArgs[i]!;\n            newState.env[fakeNodeDef[1][i]![0]] = shouldEvalParam[i] ? await param.eval(state) : param;\n        }\n        const result = await body.eval(newState);\n        return finalMacro ? result.eval(state) : result;\n    };\n    f.body = body;\n    return f;\n    async function build(state: EvalState) {\n        await validate(state);\n        built = true;\n        for (var i = 0; i < params.length; i++) {\n            var param = params[i]!;\n            if (isinstance(param, AST.Name)) {\n                fakeNodeDef[1].push([param.name, null]);\n                fakeNodeDef[3].push(undefined);\n                shouldEvalParam.push(true);\n            } else if (isinstance(param, AST.ParameterDescriptor)) {\n                var v: any = param.defaultValue;\n                if (isinstance(v, AST.DefaultPlaceholder)) v = null;\n                fakeNodeDef[1].push([param.name, v]);\n                fakeNodeDef[3].push(await param.enumOptions.toJS(state) as any);\n                shouldEvalParam.push(!param.lazy);\n            } else throw new RuntimeError(\"unreachable\", param.loc, AST.stackToNotes(state.callstack));\n        }\n    }\n    async function validate(state: EvalState) {\n        // TODO: check for possible infinite recursion and throw an error\n    }\n}\n", "import { isinstance, str } from \"../utils\";\nimport { processArgsInCall } from \"./call\";\nimport { makeCodeMacroExpander } from \"./codemacro\";\nimport { CompileError, ErrorNote, LocationTrace, RuntimeError } from \"./errors\";\nimport { EvalState, NodeDef, NodeValueType } from \"./evalState\";\nimport { OPERATORS } from \"./operator\";\nimport { allocNode, allocRegister, CompileState, Opcode, Program } from \"./prog\";\n\nexport namespace AST {\n\n    export abstract class Node {\n        constructor(public loc: LocationTrace) { }\n        abstract edgemost(left: boolean): Node;\n        abstract pipe(fn: (node: Node) => Promise<Node>): Promise<Node>;\n        abstract eval(state: EvalState): Promise<Node>;\n        abstract compile(state: CompileState, ni: NodeDef[]): CompileState;\n    }\n\n    export abstract class NotCodeNode extends Node {\n        compile(state: CompileState): CompileState {\n            throw new CompileError(\"how did we get here ?!?\", this.loc);\n        }\n    }\n\n    export abstract class Leaf extends NotCodeNode {\n        edgemost() { return this; }\n        async pipe() { return this; }\n        async eval(_: EvalState): Promise<AST.Node> { return this; }\n    }\n\n    export class AnnotatedValue extends NotCodeNode {\n        constructor(trace: LocationTrace, public attributes: Node[], public value: Node | null = null) { super(trace); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new AnnotatedValue(this.loc, await asyncNodePipe(this.attributes, fn), this.value ? await fn(this.value) : null); }\n        edgemost(left: boolean): Node { return left ? (this.attributes.length > 0 ? this.attributes[0]!.edgemost(left) : this) : (this.value ?? this); }\n        async eval(state: EvalState) {\n            var v = this.value;\n            for (var attr of this.attributes) {\n                var args: Node[] | null = null;\n                var name: string;\n                if (isinstance(attr, Call) || isinstance(attr, Name)) {\n                    name = attr.name;\n                    const impl = state.annotators[name];\n                    if (!impl) {\n                        throw new RuntimeError(\"unknown annotation \" + str(name), attr.loc, stackToNotes(state.callstack));\n                    }\n                    if (isinstance(attr, Call)) {\n                        args = attr.args;\n                    }\n                    v = await impl(v, args, state);\n                } else {\n                    throw new RuntimeError(\"illegal annotation\", attr.loc, stackToNotes(state.callstack));\n                }\n            }\n            return v!;\n        }\n    }\n\n    export class Value extends Leaf {\n        constructor(trace: LocationTrace, public value: any) { super(trace); };\n        async eval(state: EvalState): Promise<Node> {\n            if (isinstance(this.value, Node)) return this.value;\n            return this;\n        }\n        compile(state: CompileState) {\n            state.p.push(Opcode.PUSH_CONSTANT, this.value);\n            state.tosStereo = false;\n            return state;\n        }\n    }\n\n    export class Symbol extends Leaf {\n        constructor(trace: LocationTrace, public value: string) { super(trace); };\n        async eval(state: EvalState): Promise<Symbol> {\n            return this;\n        }\n    }\n\n    export class Assignment extends Node {\n        constructor(trace: LocationTrace, public target: Node, public value: Node) { super(trace); };\n        edgemost(left: boolean): Node { return left ? this.target.edgemost(left) : this.value.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Assignment(this.loc, await fn(this.target), await fn(this.value)); }\n        async eval(state: EvalState) {\n            if (!isinstance(this.target, Name)) {\n                throw new RuntimeError(\"cannot assign to this\", this.target.loc);\n            }\n            const name = this.target.name;\n            const scope = Object.hasOwn(state.env, name) ? state.env : Object.hasOwn(state.globalEnv, name) ? state.globalEnv : state.env;\n            return scope[name] = await this.value.eval(state);\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            this.value.compile(state, ni);\n            state.p.push(Opcode.TAP_REGISTER, allocRegister((this.target as any).name, state));\n            return state;\n        }\n    }\n\n    export class Name extends Leaf {\n        constructor(trace: LocationTrace, public name: string) { super(trace); };\n        async eval(state: EvalState) {\n            const val = state.env[this.name];\n            if (!val) {\n                throw new RuntimeError(\"undefined: \" + this.name, this.loc, stackToNotes(state.callstack));\n            }\n            return val;\n        }\n        compile(state: CompileState) {\n            state.p.push(Opcode.GET_REGISTER, allocRegister(this.name, state));\n            return state;\n        }\n    }\n\n    export class Call extends Node {\n        constructor(trace: LocationTrace, public name: string, public args: Node[]) { super(trace); };\n        edgemost(left: boolean): Node { return left ? this : this.args.at(-1)?.edgemost(left) ?? this; }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Call(this.loc, this.name, await asyncNodePipe(this.args, fn)); }\n        async eval(state: EvalState) {\n            const funcImpl = state.functions.find(f => f[0] === this.name);\n            if (funcImpl) {\n                const [name, argc, impl] = funcImpl;\n                const newState: EvalState = { ...state, callstack: state.callstack.concat(this) };\n                return impl(this.args, newState);\n            }\n            const nodeImpl = state.nodes.find(n => n[0] === this.name);\n            if (!nodeImpl) {\n                throw new RuntimeError(\"undefined node or function \" + this.name, this.loc, stackToNotes(state.callstack));\n            }\n            var x: List;\n            if (nodeImpl[2] === NodeValueType.DECOUPLED_MATH && (x = new List(this.loc, this.args)).isImmediate()) {\n                return new Value(this.loc, nodeImpl[4]!(null as any)(null!, x.toImmediate()!));\n            }\n            return new Call(this.loc, nodeImpl[0], await processArgsInCall(state, true, this.loc, this.args, nodeImpl));\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            var i: number;\n            const nodeImpl = ni.find(n => n[0] === this.name);\n            if (!nodeImpl) {\n                throw new CompileError(`cannot find node ${this.name} (should be unreachable!!)`, this.loc);\n            }\n            const argProgs: [argProg: Program, isStereo: NodeValueType][] = [];\n            const existingProg: Program = state.p;\n            for (i = 0; i < this.args.length; i++) {\n                state.p = [];\n                this.args[i]!.compile(state, ni);\n                argProgs.push([state.p, state.tosStereo ? NodeValueType.STEREO : NodeValueType.NORMAL_OR_MONO]);\n            }\n            state.p = existingProg;\n            const callProg: Program = [Opcode.APPLY_NODE, allocNode(this.name, state)];\n            // logic for stereo/mono nodes:\n            // if the node is x -> stereo, the inputs must all be the right type (mono to stereo can be widened; stereo to mono can't be narrowed, error)\n            // if the node is mono -> mono, the node itself is duplicated if any inputs are stereo and the output is stereo, else mono\n            // if the node is stereo -> mono, normal with the inputs also being widened if needed\n            // We assume our arguments are correct and line up positionally already\n            // (this should have been handled by the eval() stage)\n            state.tosStereo = nodeImpl[2] === NodeValueType.STEREO;\n            if (nodeImpl[1].every(a => a[2] !== NodeValueType.STEREO) && argProgs.some(s => s[1] === NodeValueType.STEREO)) {\n                // Can stereo widen\n                for (i = 0; i < nodeImpl[1].length; i++) {\n                    const gottenArgType = argProgs[i]![1];\n                    if (gottenArgType !== NodeValueType.STEREO) {\n                        argProgs[i]![0].push(Opcode.STEREO_DOUBLE_WIDEN);\n                    }\n                }\n                state.tosStereo = true;\n                callProg[0] = Opcode.APPLY_DOUBLE_NODE_STEREO;\n                callProg.push(allocNode(this.name, state)); // 2nd node\n            }\n            else {\n                for (i = 0; i < nodeImpl[1].length; i++) {\n                    const neededArgType = nodeImpl[1][i]![2]! ?? NodeValueType.NORMAL_OR_MONO;\n                    const gottenArgType = argProgs[i]![1];\n                    if (neededArgType !== NodeValueType.STEREO && gottenArgType === NodeValueType.STEREO) {\n                        throw new CompileError(\"cannot implicitly convert stereo output to mono\", this.args[i]!.loc);\n                    } else if (neededArgType === NodeValueType.STEREO && gottenArgType !== NodeValueType.STEREO) {\n                        argProgs[i]![0].push(Opcode.STEREO_DOUBLE_WIDEN);\n                    }\n                }\n                state.tosStereo = nodeImpl[2] === NodeValueType.STEREO;\n            }\n            for (i = 0; i < this.args.length; i++) {\n                state.p.push(...argProgs[i]![0]);\n            }\n            state.p.push(...callProg);\n            return state;\n        }\n    }\n\n    export class List extends Node {\n        constructor(trace: LocationTrace, public values: Node[]) { super(trace); };\n        edgemost(left: boolean): Node { return this.values.length > 0 ? left ? this.values[0]!.edgemost(left) : this.values.at(-1)!.edgemost(left) : this; }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new List(this.loc, await asyncNodePipe(this.values, fn)); }\n        async eval(state: EvalState) {\n            const values: Node[] = [];\n            for (var v of this.values) {\n                const v2 = await v.eval(state);\n                if (isinstance(v2, SplatValue) && isinstance(v2.value, List)) {\n                    values.push(...v2.value.values);\n                } else {\n                    values.push(v2);\n                }\n            }\n            return new List(this.loc, values);\n        }\n        hasSplats() {\n            return this.values.some(v => isinstance(v, SplatValue));\n        }\n        isImmediate(): boolean {\n            return this.values.every(v => isinstance(v, Value) || (isinstance(v, List) && v.isImmediate()));\n        }\n        toImmediate(): any[] | undefined {\n            if (this.isImmediate()) {\n                return this.values.map(v => isinstance(v, Value) ? v.value : (v as List).toImmediate());\n            }\n        }\n        static fromImmediate(trace: LocationTrace, m: any[]): List | Value {\n            return Array.isArray(m) ? new List(trace, m.map(r => List.fromImmediate(trace, r))) : new Value(trace, m);\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            if (this.isImmediate()) {\n                const imm = this.toImmediate() as any;\n                state.p.push(Opcode.PUSH_CONSTANT, imm);\n            } else {\n                state.p.push(Opcode.PUSH_FRESH_EMPTY_LIST);\n                for (var arg of this.values) {\n                    if (isinstance(arg, SplatValue)) {\n                        arg.value.compile(state, ni);\n                        state.p.push(Opcode.EXTEND_TO_LIST);\n                    } else {\n                        arg.compile(state, ni);\n                        state.p.push(Opcode.APPEND_TO_LIST);\n                    }\n                }\n            }\n            state.tosStereo = this.values.length === 2;\n            return state;\n        }\n    }\n\n    export class Definition extends NotCodeNode {\n        constructor(trace: LocationTrace, public name: string, public outMacro: boolean, public parameters: Node[], public body: Node) { super(trace); };\n        edgemost(left: boolean): Node { return left ? this.parameters.length > 0 ? this.parameters[0]!.edgemost(left) : this : this.body.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Definition(this.loc, this.name, this.outMacro, await asyncNodePipe(this.parameters, fn), await fn(this.body)); }\n        async eval(state: EvalState) {\n            state.functions.push([this.name, this.parameters.length, makeCodeMacroExpander(this.name, this.outMacro, this.parameters, this.body)]);\n            return new Value(this.loc, undefined);\n        }\n    }\n\n    export class ParameterDescriptor extends NotCodeNode {\n        constructor(trace: LocationTrace, public name: string, public enumOptions: Mapping, public defaultValue: Node, public lazy: boolean) { super(trace) }\n        edgemost(left: boolean): Node { return left ? this : this.defaultValue.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new ParameterDescriptor(this.loc, this.name, await fn(this.enumOptions) as Mapping, await fn(this.defaultValue), this.lazy) }\n        async eval(state: EvalState): Promise<never> {\n            throw new RuntimeError(\"cannot evaluate\", this.loc, stackToNotes(state.callstack));\n        }\n    }\n\n    export class Template extends NotCodeNode {\n        constructor(trace: LocationTrace, public result: Node) { super(trace); };\n        edgemost(left: boolean): Node { return this.result.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Template(this.loc, await fn(this.result)); }\n        async eval(state: EvalState) {\n            const replaceTrace = async (arg: Node): Promise<Node> => {\n                const val = await arg.pipe(replaceTrace);\n                val.loc = new LocationTrace(arg.loc.line, arg.loc.col, arg.loc.file, [\"note: expanded from template:\", this.loc]);\n                return val;\n            }\n            const recur = async (arg: Node, depth: number): Promise<Node> => {\n                if (isinstance(arg, Template)) return arg.pipe(n => recur(n, depth + 1));\n                if (isinstance(arg, InterpolatedValue)) {\n                    if (depth <= 1) {\n                        return replaceTrace(await arg.value.eval(state));\n                    } else {\n                        const val = await arg.pipe(n => recur(n, depth - 1));\n                        if (isinstance(val, InterpolatedValue) && isinstance(val.value, Value)) return val.value;\n                        return val;\n                    }\n                }\n                return arg.pipe(n => recur(n, depth));\n            }\n            return recur(await replaceTrace(this.result), 1);\n        }\n    }\n\n    export class BinaryOp extends Node {\n        constructor(trace: LocationTrace, public op: string, public left: Node, public right: Node, public noLift: boolean = false, public assign?: LocationTrace | undefined) { super(trace); };\n        edgemost(left: boolean): Node { return this[left ? \"left\" : \"right\"].edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new BinaryOp(this.loc, this.op, await fn(this.left), await fn(this.right), this.noLift, this.assign); }\n        async eval(state: EvalState) {\n            return this._applied(await this.left.eval(state), await this.right.eval(state));\n        }\n        private _applied(left: Node, right: Node) {\n            var fn: (typeof OPERATORS)[keyof typeof OPERATORS][\"cb\"] | undefined;\n            var imm = true, a, b;\n            if (isinstance(left, Value)) {\n                a = left.value;\n            } else if (isinstance(left, List) && left.isImmediate()) {\n                a = left.toImmediate();\n            } else {\n                imm = false;\n            }\n            if (isinstance(right, Value)) {\n                b = right.value;\n            } else if (isinstance(right, List) && right.isImmediate()) {\n                b = right.toImmediate();\n            } else {\n                imm = false;\n            }\n            if ((fn = OPERATORS[this.op]?.cb) && imm) {\n                return List.fromImmediate(this.loc, fn(a, b))\n            }\n            // Special case for comparing in/equality of 2 symbols\n            if (isinstance(left, Symbol) && isinstance(right, Symbol) && /^[!=]=$/.test(this.op)) {\n                return List.fromImmediate(this.loc, fn!(left.value, b.value));\n            }\n            return new BinaryOp(this.loc, this.op, left, right);\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            this.left.compile(state, ni);\n            this.right.compile(state, ni);\n            state.p.push(Opcode.DO_BINARY_OP, this.op);\n            return state;\n        }\n    }\n\n    export class UnaryOp extends Node {\n        constructor(trace: LocationTrace, public op: string, public value: Node) { super(trace); };\n        edgemost(left: boolean): Node { return left ? this : this.value.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new UnaryOp(this.loc, this.op, await fn(this.value)); }\n        async eval(state: EvalState) {\n            return this._applied(await this.value.eval(state));\n        }\n        private _applied(val: Node): Node {\n            var fn: (typeof OPERATORS)[keyof typeof OPERATORS][\"cu\"] | undefined;\n            var imm = true, value;\n            if (isinstance(val, Value)) {\n                value = val.value;\n            } else if (isinstance(val, List) && val.isImmediate()) {\n                value = val.toImmediate();\n            } else {\n                imm = false;\n            }\n            if (imm && (fn = OPERATORS[this.op]?.cu)) {\n                return List.fromImmediate(this.loc, fn(value));\n            }\n            return new UnaryOp(this.loc, this.op, val);\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            this.value.compile(state, ni);\n            state.p.push(Opcode.DO_UNARY_OP, this.op);\n            return state;\n        }\n    }\n\n    export class DefaultPlaceholder extends Leaf {\n        async eval(state: EvalState): Promise<never> {\n            throw new RuntimeError(\"cannot evaluate\", this.loc, stackToNotes(state.callstack));\n        }\n    }\n\n    export class KeywordArgument extends NotCodeNode {\n        constructor(trace: LocationTrace, public name: string, public arg: Node) { super(trace); }\n        edgemost(left: boolean): Node { return left ? this : this.arg.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new KeywordArgument(this.loc, this.name, await fn(this.arg)); }\n        async eval(state: EvalState) {\n            return new KeywordArgument(this.loc, this.name, await this.arg.eval(state));\n        }\n    }\n\n    export class Mapping extends NotCodeNode {\n        constructor(trace: LocationTrace, public mapping: { key: Node, val: Node }[]) { super(trace); }\n        edgemost(left: boolean): Node { return this.mapping.length > 0 ? left ? this.mapping[0]!.key.edgemost(left) : this.mapping.at(-1)!.val.edgemost(left) : this; }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Mapping(this.loc, await asyncNodePipe(this.mapping, async ({ key, val }) => ({ key: await fn(key), val: await fn(val) }))); }\n        async eval(state: EvalState) { return new Mapping(this.loc, await Promise.all(this.mapping.map(async ({ key, val }) => ({ key: await key.eval(state), val: await val.eval(state) })))); }\n        async toJS(state: EvalState): Promise<Record<string, Node>> {\n            const out: Record<string, Node> = {};\n            for (var { key, val } of this.mapping) {\n                if (!isinstance(key, Symbol)) {\n                    throw new Error(\"unreachable\");\n                }\n                out[key.value] = await val.eval(state);\n            }\n            return out;\n        }\n    }\n\n    export class Conditional extends Node {\n        constructor(trace: LocationTrace, public cond: Node, public caseTrue: Node, public caseFalse: Node) { super(trace); }\n        edgemost(left: boolean): Node { return (left ? this.cond : this.caseFalse).edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Conditional(this.loc, await fn(this.cond), await fn(this.caseTrue), await fn(this.caseFalse)); }\n        async eval(state: EvalState): Promise<Node> {\n            const cond = await this.cond.eval(state);\n            if (isinstance(cond, Value)) {\n                return (!cond.value ? this.caseFalse : this.caseTrue).eval(state);\n            }\n            return new Conditional(this.loc, cond, await this.caseTrue.eval(state), await this.caseFalse.eval(state));\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            this.caseFalse.compile(state, ni);\n            this.caseTrue.compile(state, ni);\n            this.cond.compile(state, ni);\n            state.p.push(Opcode.CONDITIONAL_SELECT);\n            return state;\n        }\n    }\n\n    export class InterpolatedValue extends NotCodeNode {\n        constructor(trace: LocationTrace, public value: Node) { super(trace); }\n        edgemost(left: boolean): Node { return this.value.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new InterpolatedValue(this.loc, await fn(this.value)); }\n        async eval(state: EvalState): Promise<never> {\n            throw new RuntimeError(\"too many &'s\", this.loc, stackToNotes(state.callstack));\n        }\n    }\n\n    export class SplatValue extends NotCodeNode {\n        constructor(trace: LocationTrace, public value: Node) { super(trace); }\n        edgemost(left: boolean): Node { return this.value.edgemost(left); }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new SplatValue(this.loc, await fn(this.value)); }\n        async eval(state: EvalState) {\n            return new SplatValue(this.loc, await this.value.eval(state));\n        }\n    }\n\n    export class PipePlaceholder extends Leaf {\n        async eval(state: EvalState): Promise<never> {\n            throw new RuntimeError(\"not valid outside of a pipe expression\", this.loc, stackToNotes(state.callstack));\n        }\n    }\n\n    export class Block extends Node {\n        constructor(trace: LocationTrace, public body: Node[]) { super(trace); }\n        edgemost(left: boolean): Node { return this.body.length > 0 ? left ? this.body[0]!.edgemost(left) : this.body.at(-1)!.edgemost(left) : this; }\n        async pipe(fn: (node: Node) => Promise<Node>): Promise<Node> { return new Block(this.loc, await asyncNodePipe(this.body, fn)); }\n        async eval(state: EvalState) {\n            var last: Node = new Value(this.loc, undefined);\n            for (var v of this.body) {\n                if (isinstance(v, DefaultPlaceholder)) last = new Value(v.loc, undefined);\n                else last = await v.eval(state);\n            }\n            return last;\n        }\n        compile(state: CompileState, ni: NodeDef[]) {\n            for (var arg of this.body) {\n                arg.compile(state, ni);\n                state.p.push(Opcode.DROP_TOP);\n            }\n            // *Don't* drop the last value\n            state.p.pop();\n            return state;\n        }\n    }\n\n    async function asyncNodePipe<T>(nodes: T[], fn: (node: T) => Promise<T>): Promise<T[]> {\n        return await Promise.all(nodes.map(fn));\n    }\n\n    export function stackToNotes(stack: Call[]): ErrorNote[] {\n        const out: ErrorNote[] = [];\n        for (var s of stack) {\n            out.push(new ErrorNote(`note: while evaluating function ${str(s.name)}`, s.loc));\n        }\n        return out.reverse();\n    }\n\n}\n", "import { str } from \"../utils\";\nimport { LocationTrace, ParseError } from \"./errors\";\nimport { OP_REGEX } from \"./operator\";\n\nexport enum TokenType {\n    NAME,\n    NUMBER,\n    PAREN,\n    OPERATOR,\n    PIPE_PLACEHOLDER,\n    STRING_BEGIN,\n    STRING_END,\n    STRING_BODY,\n    STRING_ESC,\n    INVALID_STRING_ESCAPE,\n}\n\nexport class Token {\n    constructor(public t: string,\n        public s: LocationTrace,\n        public k: TokenType,\n        public a?: LocationTrace) { }\n}\n\ntype Rule = [State[], RegExp, keepType?: TokenType | undefined, stateOp?: State | undefined];\n\nenum State {\n    INITIAL,\n    BLOCK_COMMENT,\n    STRING,\n    RAW_STRING,\n    POP,\n}\n\nconst TOKENIZE_RULES: Rule[] = [\n    // comments\n    [[State.INITIAL], /^\\/\\/[^\\n]*/],\n    [[State.INITIAL, State.BLOCK_COMMENT], /^\\/\\*/, , State.BLOCK_COMMENT],\n    [[State.BLOCK_COMMENT], /^\\*\\//, , State.POP],\n    [[State.BLOCK_COMMENT], /^((?!(\\*\\/)|(\\/\\*)).)+/],\n    // strings with escapes\n    [[State.INITIAL], /^\"/, TokenType.STRING_BEGIN, State.STRING],\n    [[State.STRING], /^\"/, TokenType.STRING_END, State.POP],\n    [[State.STRING], /^\\\\[abefnrtvz'\"\\\\]/, TokenType.STRING_ESC],\n    [[State.STRING], /^\\\\(x[0-9a-f]{2}|u[0-9a-f]{4}|u\\{[0-9a-f]+\\})/i, TokenType.STRING_ESC],\n    [[State.STRING], /^\\\\./, TokenType.INVALID_STRING_ESCAPE],\n    [[State.STRING], /^[^\\\\\"]+/, TokenType.STRING_BODY],\n    // strings without escapes\n    [[State.INITIAL], /^'/, TokenType.STRING_BEGIN, State.RAW_STRING],\n    [[State.RAW_STRING], /^'/, TokenType.STRING_END, State.POP],\n    [[State.RAW_STRING], /^\\\\'/, TokenType.STRING_ESC],\n    [[State.RAW_STRING], /^\\\\./, TokenType.STRING_BODY],\n    [[State.RAW_STRING], /^[^\\\\']+/, TokenType.STRING_BODY],\n    // number\n    [[State.INITIAL], /^-?(\\.\\d+|\\d+\\.?\\d*)(e[+-]?\\d+)?/i, TokenType.NUMBER],\n    // operators\n    [[State.INITIAL], OP_REGEX, TokenType.OPERATOR],\n    // parens\n    [[State.INITIAL], /^[()[\\]{}]/, TokenType.PAREN],\n    // names\n    [[State.INITIAL], /^\\w+/, TokenType.NAME],\n    // discard whitespace elsewhere\n    [[State.INITIAL, State.BLOCK_COMMENT], /^[\\s\\n]+/],\n];\n\nexport function tokenize(source: string, filename: string) {\n    var line = 0, col = 0;\n    const out: Token[] = [];\n    const stateStack: State[] = [State.INITIAL];\n    tokens: while (source.length > 0) {\n        for (var [curStates, regex, type, newState] of TOKENIZE_RULES) {\n            if (curStates.every(s => stateStack.at(-1) !== s)) continue;\n            const match = regex.exec(source);\n            if (match) {\n                const chunk = match[0];\n                if (type !== undefined) out.push(new Token(chunk, new LocationTrace(line, col, filename), type));\n                const interlines = chunk.split(\"\\n\");\n                if (interlines.length > 1) {\n                    col = interlines.at(-1)!.length;\n                    line += interlines.length - 1;\n                } else {\n                    col += chunk.length;\n                }\n                source = source.slice(chunk.length);\n                if (newState !== undefined) {\n                    if (newState === State.POP) stateStack.pop();\n                    else stateStack.push(newState);\n                }\n                continue tokens;\n            }\n        }\n        throw new ParseError(`unexpected ${str(source[0])}`, new LocationTrace(line, col, filename));\n    }\n    return out;\n}\n", "import { isinstance } from \"../utils\";\nimport { AST } from \"./ast\";\nimport { LocationTrace, ParseError } from \"./errors\";\nimport { getPrecedenceAndCheckValidity, isRightAssociative } from \"./operator\";\nimport { Token, TokenType } from \"./tokenizer\";\n\nexport function treeifyExpression(tokens: (AST.Node | Token)[], lift: boolean = false): AST.Node {\n    var i: number;\n    attributesHack(tokens);\n    pipePlaceholdersHack(tokens);\n    commaAndAssignHack(tokens);\n    const firstToken = tokens.find(t => isinstance(t, Token));\n    // The algorithm is 'recursive lifting':\n    // first try to find the highest precedence unary operator with no higher binary after its atom, and lift it into an atom\n    // if no such unary exists find the highest precedence binary and lift it ito an atom\n    // then repeat until there is only one atom\n    while (tokens.length > 1) {\n        // 'highest precedence' == lowest numerically\n        var bestBinaryPrecedence = Infinity, bestBinaryIndex = -1;\n        var bestUnaryPrecedence = Infinity, bestUnaryIndex = -1;\n        var prevWasAtom = false;\n        const lastAtomIndex = tokens.findLastIndex(e => isinstance(e, AST.Node));\n        for (i = 0; i < tokens.length; i++) {\n            const token = tokens[i]!;\n            if (isinstance(token, AST.Node)) prevWasAtom = true;\n            else {\n                if (i > lastAtomIndex) {\n                    throw new ParseError(\"expected a value after operator\", token.s);\n                }\n                if (prevWasAtom) {\n                    const precedence = getPrecedenceAndCheckValidity(token, false);\n                    if (bestBinaryPrecedence > precedence || (bestBinaryPrecedence === precedence && isRightAssociative(token.t))) {\n                        bestBinaryPrecedence = precedence;\n                        bestBinaryIndex = i;\n                    }\n                } else {\n                    // possible unary operator to lift\n                    if (!(isinstance(tokens[i + 1]!, AST.Node))) continue; // not innermost unary\n                    const mePrecedence = getPrecedenceAndCheckValidity(token, true);\n                    const opAfter = tokens[i + 2] as Token | undefined;\n                    if (opAfter) {\n                        const opAfterPrecedence = getPrecedenceAndCheckValidity(opAfter, false);\n                        if (opAfterPrecedence < mePrecedence) continue; // don't lift yet\n                    }\n                    // we can lift this\n                    if (bestUnaryPrecedence > mePrecedence) {\n                        bestUnaryPrecedence = mePrecedence;\n                        bestUnaryIndex = i;\n                    }\n                }\n                prevWasAtom = false;\n            }\n        }\n        if (bestUnaryIndex >= 0) {\n            const [op, val] = tokens.splice(bestUnaryIndex, 2) as [Token, AST.Node];\n            tokens.splice(bestUnaryIndex, 0, new AST.UnaryOp(op.s, op.t, val));\n        } else if (bestBinaryIndex >= 0) {\n            const [left, op, right] = tokens.splice(bestBinaryIndex - 1, 3) as [AST.Node, Token, AST.Node];\n            const math = new AST.BinaryOp(op.s, op.t, left, right, false, op.a);\n            tokens.splice(bestBinaryIndex - 1, 0, math);\n        } else {\n            throw new ParseError(\"unknown error in expression parsing\", firstToken?.s);\n        }\n    }\n    const result = tokens[0];\n    if (lift && isinstance(result, AST.BinaryOp)) result.noLift = true;\n    return result as AST.Node;\n}\n\nfunction attributesHack(tokens: (AST.Node | Token)[]) {\n    var attrs: AST.Node[] = [];\n    for (var i = 0; i < tokens.length; i++) {\n        const here = tokens[i]!;\n        if (isinstance(here, Token)) {\n            if (here.t === \"#!\") {\n                const value = tokens.splice(i, 2)[1];\n                if (!(isinstance(value, AST.Name) || isinstance(value, AST.Call))) {\n                    throw new ParseError(\"expected attribute after '#!'\", here.s);\n                }\n                attrs.push(value);\n                i--;\n            } else if (attrs.length > 0) {\n                tokens.splice(i, 0, new AST.AnnotatedValue(here.s, attrs, null))\n                attrs = [];\n            }\n        } else if (attrs.length > 0) {\n            tokens[i] = new AST.AnnotatedValue(here.loc, attrs, here);\n            attrs = [];\n        }\n    }\n    if (attrs.length > 0) {\n        tokens.push(new AST.AnnotatedValue(attrs.at(-1)!.loc, attrs, null));\n    }\n}\n\nfunction pipePlaceholdersHack(tokens: (AST.Node | Token)[]) {\n    for (var i = 0; i < tokens.length; i++) {\n        const before = tokens[i - 1];\n        const here = tokens[i];\n        const after = tokens[i + 1];\n        if (isinstance(here, Token) && here.t === \"#\" && !(isinstance(before, AST.Node) || isinstance(after, AST.Node))) {\n            tokens[i] = new AST.PipePlaceholder(here.s);\n        }\n    }\n}\n\nfunction commaAndAssignHack(tokens: (AST.Node | Token)[]) {\n    for (var i = -1; i < tokens.length; i++) {\n        const here = tokens[i];\n        const next = tokens[i + 1];\n        if (commaIsh(here) && commaIsh(next)) {\n            // insert default sentinels in between consecutive commas or colons\n            tokens.splice(i + 1, 0, new AST.DefaultPlaceholder(next?.s ?? here?.s ?? LocationTrace.nowhere));\n        } else if (tokenLike(here) && tokenLike(next) && here.k === TokenType.OPERATOR && next.k === TokenType.OPERATOR && next.t === \"=\") {\n            tokens.splice(i, 2, new Token(here.t, here.s, here.k, next.s));\n        } else if (isinstance(here, AST.Node) && isinstance(next, AST.Node)) {\n            throw new ParseError(\"expected operator before value\", next.edgemost(false).loc);\n        }\n    }\n}\n\nfunction commaIsh(x: Token | AST.Node | undefined): x is Token | undefined {\n    return !x || (tokenLike(x) && /^[,:;]$/.test(x.t));\n}\n\nfunction tokenLike(x: Token | AST.Node | undefined) {\n    return isinstance(x, Token);\n}\n", "import { isinstance, str } from \"../utils\";\nimport { AST } from \"./ast\";\nimport { ErrorNote, ParseError } from \"./errors\";\nimport { treeifyExpression } from \"./expression\";\nimport { Token, TokenType } from \"./tokenizer\";\n\n\nexport function liftCommas(expr: AST.Node, force = false): AST.Node[] {\n    return isinstance(expr, AST.BinaryOp) && /^[,;]$/.test(expr.op) && (force || !expr.noLift) ? [...liftCommas(expr.left), ...liftCommas(expr.right)] : [expr];\n}\n\n// string string string\nfunction unescape(string: string): string {\n    return ({\n        a: \"\\a\", b: \"\\b\", e: \"\\e\", f: \"\\f\", n: \"\\n\", r: \"\\r\", t: \"\\t\", v: \"\\v\", z: \"\\0\", \"'\": \"'\", \"\\\"\": \"\\\"\", \"\\\\\": \"\\\\\",\n        x: false as const,\n        u: false as const\n    }[string.toLowerCase()[0]!] ?? string) || String.fromCodePoint(parseInt(/[0-9a-f]+/i.exec(string)![0], 16));\n}\n\nexport function parseTokens(tokens: Token[]): AST.Node {\n    var pos = 0;\n    const nextToken = <T extends boolean>(expect: T, beginParen?: Token): T extends true ? Token : Token | undefined => {\n        if (expect && pos >= tokens.length) {\n            if (beginParen) {\n                throw new ParseError(`${str(beginParen.t)} was never closed`, beginParen.s);\n            }\n            const last = tokens.at(-1);\n            throw new ParseError(\"unexpected EOF\", last?.s);\n        }\n        return tokens[pos++]!;\n    };\n    const parseString = (start: Token): AST.Value => {\n        var out = \"\";\n        str: for (; ;) {\n            const token = nextToken(true, start);\n            switch (token.k) {\n                case TokenType.STRING_END:\n                    break str;\n                case TokenType.STRING_BODY:\n                    out += token.t;\n                    break;\n                case TokenType.STRING_ESC:\n                    out += unescape(token.t.slice(1));\n                    break;\n                case TokenType.INVALID_STRING_ESCAPE:\n                    throw new ParseError(\"illegal escape sequence\", token.s);\n            }\n        }\n        return new AST.Value(start.s, out);\n    }\n    const parseThing = (requireNext: boolean, beginParen?: Token): AST.Node | undefined => {\n        const token = nextToken(requireNext, beginParen);\n        if (token === undefined) return undefined;\n        switch (token.k) {\n            case TokenType.NUMBER:\n                return new AST.Value(token.s, parseFloat(token.t));\n            case TokenType.STRING_BEGIN:\n                return parseString(token);\n            case TokenType.NAME:\n                const after = nextToken(false);\n                if (after && after.t === \"(\") {\n                    return new AST.Call(token.s, token.t, liftCommas(parseExpression(\")\", after), true));\n                }\n                pos--; // make it a peek\n                return new AST.Name(token.s, token.t);\n            // @ts-expect-error\n            // fallthrough is intentional!\n            case TokenType.PAREN:\n                switch (token.t) {\n                    case \"{\":\n                        return new AST.Template(token.s, parseExpression(\"}\", token));\n                    case \"[\":\n                        return new AST.List(token.s, liftCommas(parseExpression(\"]\", token), true));\n                    case \"(\":\n                        return parseExpression(\")\", token, true);\n                    case \")\":\n                    case \"]\":\n                    case \"}\":\n                        throw new ParseError(beginParen ? `expected ${str({ \"(\": \")\", \"[\": \"]\", \"{\": \"}\" }[beginParen.t])}` : \"stray close paren\", token.s, beginParen ? [new ErrorNote(\"note: to match this \" + str(beginParen.t), beginParen.s)] : []);\n                }\n            case TokenType.OPERATOR:\n                if (!requireNext && /^[,;)]$/.test(token.t)) {\n                    pos--;\n                    return;\n                }\n        }\n        throw new ParseError(`unexpected ${{ [TokenType.NAME]: \"name\", [TokenType.OPERATOR]: \"operator\" }[token.t] ?? str(token.t)}`, token.s);\n    };\n    const parseExpression = (end: string | false, beginParen?: Token, lift = false): AST.Node => {\n        const exprItems: (AST.Node | Token)[] = [];\n        for (; ;) {\n            var tok = nextToken(!!end, beginParen);\n            if (!end && tok === undefined) break;\n            if (tok!.t === end) break;\n            switch (tok!.k) {\n                case TokenType.OPERATOR:\n                    exprItems.push(tok!);\n                    break;\n                default:\n                    pos--;\n                    const thing = parseThing(false, beginParen);\n                    if (thing !== undefined) exprItems.push(thing);\n            }\n        }\n        return treeifyExpression(exprItems, lift);\n    };\n    return parseExpression(false);\n}\n", "import { isinstance } from \"../utils\";\nimport { AST } from \"./ast\";\n\nexport function isPipe(a: AST.Node): a is AST.BinaryOp {\n    return isinstance(a, AST.BinaryOp) && a.op === \"|>\";\n}\n\nexport async function countPlaceholdersIn(expr: AST.Node): Promise<number> {\n    var numPlaceholders = 0;\n    const count = async (ast: AST.Node) => {\n        if (isinstance(ast, AST.PipePlaceholder)) numPlaceholders++;\n        if (isPipe(ast)) {\n            await ast.left.pipe(count);\n        } else {\n            await ast.pipe(count);\n        }\n        return ast;\n    }\n    await count(expr);\n    return numPlaceholders;\n}\n\nexport async function replacePlaceholdersWith(ast: AST.Node, with_: AST.Node): Promise<AST.Node> {\n    if (isinstance(ast, AST.PipePlaceholder)) {\n        return with_;\n    } else if (isPipe(ast)) {\n        return await ast.pipe(async a => a === ast.left ? a : await replacePlaceholdersWith(a, with_));\n    } else {\n        return await ast.pipe(async a => await replacePlaceholdersWith(a, with_))\n    }\n}\n", "import { isinstance, str } from \"../utils\";\nimport { AST } from \"./ast\";\nimport { liftCommas } from \"./core\";\nimport { ErrorNote, ParseError } from \"./errors\";\nimport { countPlaceholdersIn, isPipe, replacePlaceholdersWith } from \"./pipe\";\n\nconst TRANSFORM_PASSES = [\n\n    async function expandSymbols(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.UnaryOp) || ast.op !== \".\") return ast.pipe(expandSymbols);\n        if (!isinstance(ast.value, AST.Name)) {\n            throw new ParseError('unexpected \".\"', ast.loc);\n        }\n        return new AST.Symbol(ast.value.loc, ast.value.name);\n    },\n\n    async function expandInterpolations(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandInterpolations);\n        if (isinstance(ast, AST.UnaryOp) && ast.op === \"&\") ast = new AST.InterpolatedValue(ast.loc, ast.value);\n        return ast;\n    },\n\n    async function expandMapping(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandMapping);\n        if (!isinstance(ast, AST.List)) return ast;\n        const elements = ast.values;\n        const firstKVIndex = elements.findIndex(e => (isinstance(e, AST.BinaryOp) && e.op === \"=>\"));\n        if (firstKVIndex < 0) {\n            const firstColon = elements.find(e => (isinstance(e, AST.BinaryOp) && e.op === \":\"));\n            if (firstColon) {\n                throw new ParseError('mappings use \"=>\", not \":\"', firstColon.loc);\n            }\n            return ast;\n        }\n        const kvPairs: { key: AST.Node, val: AST.Node }[] = [];\n        for (var i = 0; i < elements.length; i++) {\n            const el = elements[i]!;\n            if (!isinstance(el, AST.BinaryOp) || el.op !== \"=>\") {\n                throw new ParseError(isinstance(el, AST.DefaultPlaceholder) ? \"illegal trailing comma in mapping\" : 'expected \"=>\" after key value', el.edgemost(false).loc, i < firstKVIndex ? [new ErrorNote('hint: the \"=>\" first used here makes this a mapping, not a list', elements[firstKVIndex]!.loc)] : []);\n            }\n            kvPairs.push({ key: el.left, val: el.right });\n        }\n        return new AST.Mapping(ast.edgemost(true).loc, kvPairs);\n    },\n\n    async function commasToBlocks(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || (ast.op !== \",\" && ast.op !== \";\")) return ast.pipe(commasToBlocks);\n        return new AST.Block(ast.edgemost(true).loc, await Promise.all(liftCommas(ast, true).map(commasToBlocks)));\n    },\n\n    async function trimDefaultSentinelsInCallExpression(ast: any): Promise<AST.Node> {\n        ast = await ast.pipe(trimDefaultSentinelsInCallExpression);\n        if (isinstance(ast, AST.Call))\n            while (isinstance(ast.args.at(-1), AST.DefaultPlaceholder)) ast.args.pop();\n        return ast;\n    },\n\n    async function trimDefaultSentinelsInBlock(ast: any): Promise<AST.Node> {\n        ast = await ast.pipe(trimDefaultSentinelsInBlock);\n        if (isinstance(ast, AST.Block)) {\n            for (var i = 0; i < (ast.body.length - 1); i++) {\n                if (isinstance(ast.body[i], AST.DefaultPlaceholder)) {\n                    ast.body.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n        return ast;\n    },\n\n    async function expandDefinitions(ast: AST.Node, alreadyExpanded = false): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \":-\") return ast.pipe(expandDefinitions);\n        var header = alreadyExpanded ? ast.left : await ast.left.pipe(expandDefinitions);\n        const body = alreadyExpanded ? ast.right : await ast.right.pipe(expandDefinitions);\n        var isMacro = false;\n        if (isinstance(header, AST.UnaryOp) && header.op === \"@\") {\n            header = header.value;\n            isMacro = true;\n        }\n        if (!isinstance(header, AST.Call)) {\n            if (isinstance(header, AST.AnnotatedValue) && header.value !== null) {\n                ast.left = header.value;\n                return new AST.AnnotatedValue(header.loc, header.attributes, await expandDefinitions(ast, true));\n            }\n            throw new ParseError(\"illegal header\", header.edgemost(true).loc, [new ErrorNote(\"note: definition operator is here\", ast.loc)]);\n        }\n        const params = header.args;\n        var firstOptional: AST.Node | undefined;\n        const realParams: AST.Node[] = [];\n        for (var i = 0; i < params.length; i++) {\n            var param = params[i]!;\n            var lazy = false;\n            if (isinstance(param, AST.UnaryOp) && param.op === \"@\") {\n                param = param.value;\n                lazy = true;\n            }\n            if (isinstance(param, AST.Name)) {\n                if (firstOptional) {\n                    throw new ParseError(\"required parameter follows optional parameter\", param.loc, [new ErrorNote(\"note: first optional parameter is here\", firstOptional.loc)]);\n                }\n                realParams.push(lazy ? new AST.ParameterDescriptor(param.loc, param.name, new AST.Mapping(param.loc, []), new AST.DefaultPlaceholder(param.loc), true) : param);\n                continue;\n            }\n            if (!isinstance(param, AST.BinaryOp) || (param.op !== \":\" && param.op !== \"=\")) {\n                throw new ParseError(\"illegal parameter\", param.edgemost(true).loc);\n            }\n            var name = param.left, enums: AST.Mapping, default_: AST.Node | undefined;\n            switch (param.op) {\n                case \":\":\n                    default_ = undefined;\n                    if (!isinstance(param.right, AST.Mapping)) {\n                        throw new ParseError(\"expected a mapping\", param.right.loc);\n                    }\n                    enums = param.right;\n                    for (var { key } of enums.mapping) {\n                        if (!isinstance(key, AST.Symbol)) {\n                            throw new ParseError(\"expected a symbol here\", key.edgemost(false).loc, [new ErrorNote(`note: while defining enum options for parameter`, name.loc), ...(isinstance(key, AST.Name) ? [new ErrorNote(`hint: put a \".\" before the ${str(key.name)} to make it a static symbol instead of a variable`, key.loc)] : [])]);\n                        }\n                    }\n                    break;\n                case \"=\":\n                    enums = new AST.Mapping(param.loc, []);\n                    if (isinstance(name, AST.BinaryOp) && name.op === \":\") {\n                        if (!isinstance(name.right, AST.Mapping)) {\n                            throw new ParseError(\"expected a mapping\", name.right.loc);\n                        }\n                        enums = name.right;\n                        name = name.left;\n                    }\n                    default_ = param.right;\n                    break;\n                default:\n                    throw \"unreachable\";\n            }\n            if (default_ === undefined) {\n                default_ = new AST.DefaultPlaceholder(name.loc);\n            } else {\n                if (!firstOptional) firstOptional = name;\n            }\n            if (isinstance(name, AST.UnaryOp) && name.op === \"@\") {\n                param = name.value;\n                lazy = true;\n            }\n            if (!isinstance(name, AST.Name)) {\n                throw new ParseError(\"illegal parameter name for optional parameter\", name.edgemost(false).loc);\n            }\n            realParams.push(new AST.ParameterDescriptor(name.loc, name.name, enums, default_, lazy));\n        }\n        return new AST.Definition(header.loc, header.name, isMacro, realParams, body);\n    },\n\n    async function expandAssignments(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || (ast.op !== \"=\" && !ast.assign)) return ast.pipe(expandAssignments);\n        const target = await ast.left.pipe(expandAssignments);\n        var body = await ast.right.pipe(expandAssignments);\n        if (ast.assign) {\n            body = new AST.BinaryOp(ast.loc, ast.op, target, body);\n        }\n        return new AST.Assignment(target.loc, target, body);\n    },\n\n    async function expandTernaryOperators(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \"?\") return ast.pipe(expandTernaryOperators);\n        const condition = await ast.left.pipe(expandTernaryOperators);\n        const choices = await ast.right.pipe(expandTernaryOperators);\n        if (!isinstance(choices, AST.BinaryOp) || choices.op !== \":\") {\n            throw new ParseError('expected \":\" after expression', (isinstance(choices, AST.BinaryOp) ? choices : choices.edgemost(false)).loc, [new ErrorNote('note: \"?\" is here:', ast.loc)]);\n        }\n        return new AST.Conditional(ast.loc, condition, choices.left, choices.right);\n    },\n\n    async function createKeywordArguments(ast: AST.Node, parent: AST.Node | null = null): Promise<AST.Node> {\n        if (!isinstance(ast, AST.BinaryOp) || ast.op !== \":\") return ast.pipe(e => createKeywordArguments(e, ast));\n        const name = await ast.left.pipe(e => createKeywordArguments(e));\n        const value = await ast.right.pipe(e => createKeywordArguments(e));\n        if (!isinstance(name, AST.Name)) {\n            throw (isinstance(parent, AST.Call)\n                ? new ParseError('expected name before \":\"', name.edgemost(false).loc)\n                : new ParseError('unexpected \":\"', ast.loc));\n        }\n        if (!isinstance(parent, AST.Call) && !isinstance(parent, AST.Definition)) {\n            throw new ParseError(\"named parameter not directly inside a callsite\", name.loc);\n        }\n        return new AST.KeywordArgument(name.loc, name.name, value);\n    },\n\n    async function fixAndValidateListDefaultSentinels(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.List)) return ast.pipe(fixAndValidateListDefaultSentinels);\n        const args = await Promise.all(ast.values.map(fixAndValidateListDefaultSentinels));\n        // Special case for empty list\n        if (args.length === 1 && isinstance(args[0], AST.DefaultPlaceholder)) {\n            return new AST.List(ast.loc, []);\n        }\n        for (var i = 0; i < args.length; i++) {\n            const el = args[i]!;\n            if (isinstance(el, AST.DefaultPlaceholder)) {\n                throw new ParseError((i + 1) === args.length ? \"illegal trailing comma in list\" : \"empty elements not allowed in list\", el.loc, [new ErrorNote(\"note: list starts here\", ast.loc)]);\n            }\n        }\n        return new AST.List(ast.loc, args);\n    },\n\n    async function transformUnarySplatOperators(ast: AST.Node): Promise<AST.Node> {\n        if (!isinstance(ast, AST.UnaryOp) || ast.op !== \"*\") return ast.pipe(transformUnarySplatOperators);\n        return new AST.SplatValue(ast.loc, await ast.value.pipe(transformUnarySplatOperators));\n    },\n\n    async function expandPipeOperators(ast: AST.Node): Promise<AST.Node> {\n        ast = await ast.pipe(expandPipeOperators);\n        if (!isPipe(ast)) return ast;\n        const sym = new AST.Name(ast.loc, [\"_pipe\", ast.loc.file.replace(/[^a-z]/ig, \"\"), ast.loc.line, ast.loc.col].join(\"_\"));\n        const arg = ast.left;\n        const expr = ast.right;\n        const numPlaceholders = await countPlaceholdersIn(expr);\n        if (numPlaceholders === 0) {\n            throw new ParseError(\"missing '#' placeholder in pipe expression\", expr.loc, [new ErrorNote(\"note: required by this pipe operator\", ast.loc)]);\n        } else if (numPlaceholders > 1 && !isinstance(arg, AST.Value)) {\n            return new AST.Block(ast.loc, [new AST.Assignment(ast.loc, sym, arg), await replacePlaceholdersWith(expr, sym)]);\n        } else {\n            return replacePlaceholdersWith(expr, arg);\n        }\n    }\n\n];\n\nexport async function transformAST(ast: AST.Node): Promise<AST.Node> {\n    for (var transformer of TRANSFORM_PASSES) {\n        ast = await transformer(ast);\n    }\n    return ast;\n}\n", "import { AST } from \"./ast\";\nimport { parseTokens } from \"./core\";\nimport { tokenize } from \"./tokenizer\";\nimport { transformAST } from \"./transformers\";\n\nexport function parse(src: string, filename: string): Promise<AST.Node> {\n    return transformAST(parseTokens(tokenize(src, filename)));\n}\n"],
  "mappings": "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",
  "names": ["processArgsInCall", "state", "doEvalArgs", "site", "args", "nodeImpl", "newArgs", "seenArgs", "firstKW", "i", "arg", "argIndex", "isinstance", "AST", "RuntimeError", "str", "ErrorNote", "a", "argEntry", "defaultValue", "enumChoices", "walkAndReplaceSymbols", "__name", "ast", "value", "makeCodeMacroExpander", "name", "finalMacro", "params", "body", "fakeNodeDef", "shouldEvalParam", "built", "f", "__name", "args", "state", "build", "RuntimeError", "AST", "givenArgs", "processArgsInCall", "newState", "i", "param", "result", "validate", "isinstance", "v", "AST", "Node", "loc", "__name", "NotCodeNode", "state", "CompileError", "Leaf", "_", "AnnotatedValue", "trace", "attributes", "value", "fn", "asyncNodePipe", "left", "v", "attr", "args", "name", "isinstance", "Call", "Name", "impl", "RuntimeError", "str", "stackToNotes", "Value", "Symbol", "Assignment", "target", "scope", "ni", "allocRegister", "val", "funcImpl", "f", "argc", "newState", "nodeImpl", "n", "x", "List", "processArgsInCall", "i", "argProgs", "existingProg", "callProg", "allocNode", "a", "s", "neededArgType", "gottenArgType", "values", "v2", "SplatValue", "m", "r", "imm", "arg", "Definition", "outMacro", "parameters", "body", "makeCodeMacroExpander", "ParameterDescriptor", "enumOptions", "defaultValue", "lazy", "Template", "result", "replaceTrace", "LocationTrace", "recur", "depth", "InterpolatedValue", "BinaryOp", "op", "right", "noLift", "assign", "b", "OPERATORS", "UnaryOp", "DefaultPlaceholder", "KeywordArgument", "Mapping", "mapping", "key", "out", "Conditional", "cond", "caseTrue", "caseFalse", "PipePlaceholder", "Block", "last", "nodes", "stack", "ErrorNote", "Token", "t", "s", "k", "a", "__name", "TOKENIZE_RULES", "OP_REGEX", "tokenize", "source", "filename", "line", "col", "out", "stateStack", "tokens", "curStates", "regex", "type", "newState", "s", "match", "chunk", "Token", "LocationTrace", "interlines", "ParseError", "str", "__name", "treeifyExpression", "tokens", "lift", "attributesHack", "pipePlaceholdersHack", "commaAndAssignHack", "firstToken", "t", "isinstance", "Token", "bestBinaryPrecedence", "bestBinaryIndex", "bestUnaryPrecedence", "bestUnaryIndex", "prevWasAtom", "lastAtomIndex", "e", "AST", "token", "ParseError", "precedence", "getPrecedenceAndCheckValidity", "isRightAssociative", "mePrecedence", "opAfter", "op", "val", "left", "right", "math", "result", "__name", "attrs", "here", "value", "i", "before", "after", "next", "commaIsh", "LocationTrace", "tokenLike", "x", "liftCommas", "expr", "force", "isinstance", "AST", "__name", "unescape", "string", "parseTokens", "tokens", "pos", "nextToken", "expect", "beginParen", "ParseError", "str", "last", "parseString", "start", "out", "token", "parseThing", "requireNext", "after", "parseExpression", "ErrorNote", "end", "lift", "exprItems", "tok", "thing", "treeifyExpression", "isPipe", "a", "isinstance", "AST", "__name", "countPlaceholdersIn", "expr", "numPlaceholders", "count", "ast", "replacePlaceholdersWith", "with_", "TRANSFORM_PASSES", "__name", "expandSymbols", "ast", "isinstance", "AST", "ParseError", "expandInterpolations", "expandMapping", "elements", "firstKVIndex", "e", "firstColon", "kvPairs", "i", "el", "ErrorNote", "commasToBlocks", "liftCommas", "trimDefaultSentinelsInCallExpression", "trimDefaultSentinelsInBlock", "expandDefinitions", "alreadyExpanded", "header", "body", "isMacro", "params", "firstOptional", "realParams", "param", "lazy", "name", "enums", "default_", "key", "str", "expandAssignments", "target", "expandTernaryOperators", "condition", "choices", "createKeywordArguments", "parent", "value", "fixAndValidateListDefaultSentinels", "args", "transformUnarySplatOperators", "expandPipeOperators", "isPipe", "sym", "arg", "expr", "numPlaceholders", "countPlaceholdersIn", "replacePlaceholdersWith", "transformAST", "transformer", "parse", "src", "filename", "transformAST", "parseTokens", "tokenize", "__name"]
}
