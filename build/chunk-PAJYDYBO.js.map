{
  "version": 3,
  "sources": ["../src/compiler/errors.ts", "../src/utils.ts", "../src/math.ts", "../src/compiler/operator.ts", "../src/compiler/prog.ts"],
  "sourcesContent": ["export class LocationTrace {\n    constructor(\n        public line: number,\n        public col: number,\n        public file: string,\n        public source: [string, LocationTrace] | null = null) { }\n\n    static nowhere = new LocationTrace(0, 0, \"unknown\");\n}\nfunction formatTrace(trace: LocationTrace, message: string, sources: Record<string, string>): string {\n    const src = sources[trace.file];\n    var lineInfo = \"\";\n    if (src) {\n        const lines = src.split(\"\\n\");\n        const relevantLine = lines[trace.line] || \"\";\n        const lineNumberString = trace.line + 1 + \"\";\n        lineInfo = `\\n${lineNumberString} | ${relevantLine}\\n${\" \".repeat(lineNumberString.length)} | ${\" \".repeat(trace.col)}^`;\n    }\n    return `${trace.file}:${trace.line + 1}:${trace.col + 1}: ${message}${lineInfo}${trace.source ? \"\\n\" + formatTrace(trace.source[1], trace.source[0], sources) : \"\"}`;\n}\n\nexport class ErrorNote {\n    constructor(public message: string, public location: LocationTrace) { }\n}\n\nexport class SydError extends Error {\n    constructor(message: string, public trace: LocationTrace = LocationTrace.nowhere, public notes: ErrorNote[] = []) {\n        super(message);\n    }\n    displayOn(sources: Record<string, string>): string {\n        return formatTrace(this.trace, \"error: \" + this.message, sources) + this.notes.map(note => \"\\n\" + formatTrace(note.location, note.message, sources)).join(\"\") + \"\\n\";\n    }\n}\n\nexport class ParseError extends SydError { }\n\nexport class RuntimeError extends SydError { }\n\nexport class CompileError extends SydError { }\n", "// export const mapObject = <T, U>(obj: Record<string, T>, func: (value: T, key: string) => U): Record<string, U> =>\n//     Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, func(value, key)]));\n\nconst typeOf = (x: any) => typeof x;\nexport const is = (t: string, func: (x: any) => any = typeOf) => (x: any) => func(x) === t;\nexport const isNumber = is(\"number\") as (x: any) => x is number;\n// export const isUndefined = is(\"undefined\") as (x: any) => x is undefined;\n// export const isString = is(\"string\") as (x: any) => x is string;\n// export const isNull = (x: any): x is null => x === null;\n// export const isEmpty = (x: any[]): x is [] => x.length === 0;\n// type Predicate<T, U extends T> = (x: T) => x is U;\n// type AssertedType<F> = F extends (x: any) => x is infer U ? U : never;\n// type UnionOfPredicates<T, Fns extends readonly ((x: T) => x is any)[]> = AssertedType<Fns[number]>;\n// export const any = <T, const Fns extends readonly Predicate<T, any>[]>(x: T, ...funcs: Fns): x is UnionOfPredicates<T, Fns> => funcs.some(f => f(x));\nexport const isArray = Array.isArray;\n// export const isObject = is(\"object\") as (x: any) => x is Record<string, any>;\n\n// export const isConstant = (x: any): x is null | undefined | number | string => any(x, isNull, isUndefined, isNumber) || (isString(x) && !(isRef(x) || isNodeName(x) || isInputRef(x)));\n// export const isNode = (x: any): x is NodeTree =>\n//     any(x, isString, isNumber, isUndefined, isNull)\n//         ? false\n//         : isArray(x) && isString(x[0])\n//             ? (isNamedNode(x) ? isNode(getNodeContents(x)) : true)\n//             : (isArray(x[0]) && !isEmpty(x[0]) && isString(x[0][0]));\n\n// const isTypeString = <T extends string>(starter: T) => (x: any): x is `${T}${string}` =>\n//     isString(x) && x.startsWith(starter);\n// export const isRef = isTypeString(\"@\");\n// export const isNodeName = isTypeString(\"=\");\n// export const isInputRef = isTypeString(\">\");\n// export const isNamedNode = (x: any): x is [NodeName, ...any[]] => isArray(x) && isNodeName(x[0]);\n// export const getNodeName = (x: any): NodeName | undefined => isNamedNode(x) ? x[0] : undefined;\n// export const getNodeContents = (x: any): any[] => isNamedNode(x) ? x.slice(1) : x;\n\nexport const str = JSON.stringify;\n\n// const gensymCounters: Record<string, number> = {};\n// export function gensym<T extends string>(prefix: T): `${T}${number}` {\n//     gensymCounters[prefix] = (gensymCounters[prefix] || 0) + 1;\n//     return `${prefix}${gensymCounters[prefix]}` as const;\n// }\n\nexport function isinstance<C>(obj: any, cls: abstract new (...args: any[]) => C): obj is C {\n    return obj instanceof cls;\n}\n\nconst idMap = new WeakMap<Object, number>();\nvar idCounter = 0;\nexport const id = (obj: any): number => {\n    if (!idMap.has(obj)) idMap.set(obj, idCounter++);\n    return idMap.get(obj)!\n}\n", "export const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const min = Math.min;\nexport const max = Math.max;\nexport const clamp = (x: number, y: number, z: number) => max(min(x, z), y);\nexport const sin = Math.sin;\nexport const cos = Math.cos;\nexport const sgn = Math.sign;\nexport const abs = Math.abs;\nexport const tan = (x: number) => clamp(Math.tan(x), -1, 1);\nexport const saw = (x: number) => 1 - (2 * x / TAU % 2 + 2) % 2;\nexport const tri = (x: number) => 1 - 4 * abs(Math.round(x / TAU) - x / TAU);\nexport const noise3 = (x: number) => sin(x ** 3);\nexport const noise5 = (x: number) => sin(x ** 5);\n\n// From https://stackoverflow.com/a/27205341/23626926\nexport const matMul = (a: number[][], b: number[][]) => {\n    var aNumRows = a.length, aNumCols = a[0]!.length, bNumCols = b[0]!.length, m = [] as number[][];\n    for (var r = 0; r < aNumRows; r++) {\n        m[r] = [] as number[];\n        for (var c = 0; c < bNumCols; c++) {\n            m[r]![c] = 0;\n            for (var i = 0; i < aNumCols; i++) {\n                m[r]![c]! += a[r]![i]! * b[i]![c]!;\n            }\n        }\n    }\n    return m;\n};\n", "import { matMul } from \"../math\";\nimport { str } from \"../utils\";\nimport { ParseError } from \"./errors\";\nimport type { Token } from \"./tokenizer\";\n\n/** constant used to note that an operator is not valid in this context (unary or binary) */\nexport const INVALID = -1;\n\nclass Operator {\n    cb: ((this: unknown, a: any, b: any) => any) | null = null;\n    cu: ((this: unknown, a: any) => any) | null = null;\n    constructor(\n        public b: number,\n        public u: number = INVALID,\n        public r: boolean = false) { }\n    code(b: this[\"cb\"], u: this[\"cu\"] = null) {\n        this.cb = b;\n        this.cu = u;\n        return this;\n    }\n}\n\nconst op: (...args: ConstructorParameters<typeof Operator>) => Operator = (b, u, r) => new Operator(b, u, r);\n\nexport const OPERATORS: Record<string, Operator> = {\n    // attribute sigil\n    \"#!\": op(INVALID, -Infinity),\n    // symbol name\n    \".\": op(INVALID, -Infinity),\n    // interpolate and bitwise AND\n    \"&\": op(6, 0).code((a, b) => a & b),\n    // length or as 0-ary pipeline placeholder (that is handled specially)\n    \"#\": op(INVALID, 0).code(null, a => a.length),\n    // boolean NOT\n    \"!\": op(INVALID, 0).code(null, a => !a),\n    // power\n    \"**\": op(1, INVALID, true).code((a, b) => a ** b),\n    // multiply or splat operator\n    \"*\": op(3, -Infinity).code((a, b) => a * b),\n    // divide & modulo\n    \"/\": op(3).code((a, b) => a / b),\n    \"%\": op(3).code((a, b) => a % b),\n    // matrix multiply\n    // or decorator to mark param or declaration as lazy/macro\n    \"@\": op(3, -Infinity).code(matMul as any),\n    // add\n    \"+\": op(4).code((a, b) => a + b),\n    // subtract, negate\n    \"-\": op(4, 2).code((a, b) => a - b, a => -a),\n    // boolean OR / AND\n    \"||\": op(5).code((a, b) => a || b),\n    \"&&\": op(5).code((a, b) => a && b),\n    // bitwise OR / XOR\n    \"|\": op(6).code((a, b) => a | b),\n    \"^\": op(6).code((a, b) => a ^ b),\n    // comparison\n    \"==\": op(7).code((a, b) => a == b),\n    \">=\": op(7).code((a, b) => a >= b),\n    \">\": op(7).code((a, b) => a > b),\n    \"<=\": op(7).code((a, b) => a <= b),\n    \"<\": op(7).code((a, b) => a < b),\n    \"!=\": op(7).code((a, b) => a != b),\n    // pipe\n    \"|>\": op(8),\n    // conditional in 2 parts (treated as binary and postprocessed for simplicity)\n    // colon is also used for keyword arguments\n    \":\": op(9),\n    \"?\": op(10),\n    // assignment operator (no overloads and handles specially, just here so it can be parsed in the right spot)\n    \"=\": op(11),\n    // mapping operator (for inside lists)\n    \"=>\": op(12),\n    // define operator (handled specially)\n    \":-\": op(12),\n    // statement separator\n    \",\": op(13).code((_, b) => b),\n    \";\": op(13),\n};\n\nexport const OP_REGEX = new RegExp(`^(${Object.keys(OPERATORS).sort((a, b) => b.length - a.length).map(e => e.replaceAll(/([()[\\]{}*+?|^$\\\\.])/g, \"\\\\$1\")).join(\"|\")})`);\n\nexport function getPrecedence(token: string, unary: boolean): number {\n    return OPERATORS[token]![unary ? \"u\" : \"b\"] ?? INVALID;\n}\n\nexport function getPrecedenceAndCheckValidity(token: Token, isUnary: boolean): number {\n    const keyOperator = token.a ? \"=\" : token.t;\n    const realOperator = token.t + (token.a ? \"=\" : \"\")\n    const mePrecedence = getPrecedence(keyOperator, isUnary);\n    if (mePrecedence === INVALID) {\n        throw new ParseError(`${str(realOperator)} is not valid as a ${[\"binary\", \"unary\"][+isUnary]} operator`, token.s);\n    }\n    return mePrecedence;\n}\n\nexport function isRightAssociative(token: string): boolean {\n    return OPERATORS[token]!.r;\n}\n", "import { AutomatedValueMethod } from \"../runtime/automation\";\n\nexport enum Opcode {\n    /** next is the constant */\n    PUSH_CONSTANT,\n    PUSH_INPUT_SAMPLES,\n    PUSH_PITCH,\n    PUSH_EXPRESSION,\n    PUSH_GATE,\n    MARK_STILL_ALIVE,\n    DROP_TOP,\n    PUSH_FRESH_EMPTY_LIST,\n    APPEND_TO_LIST,\n    EXTEND_TO_LIST,\n    /** next is opcode */\n    DO_BINARY_OP,\n    /** next is opcode */\n    DO_UNARY_OP,\n    /** next is register no. */\n    GET_REGISTER,\n    /** next is register no. */\n    TAP_REGISTER,\n    CONDITIONAL_SELECT,\n    /** doubles the sample into a [sample, sample] left right pair */\n    STEREO_DOUBLE_WIDEN,\n    /** next 2 is node no, argc */\n    APPLY_NODE,\n    /** next 3 is node no A and B, argc */\n    APPLY_DOUBLE_NODE_STEREO,\n    /** next is input number, returns 0 if doesn't exist */\n    GET_MOD,\n}\n\nexport type Program = (Opcode | number | string)[];\n\nexport interface CompileState {\n    p: Program;\n    r: string[];\n    nn: string[];\n    tosStereo: boolean;\n    mods: [name: string, initial: number, mode: AutomatedValueMethod][]\n}\n\nexport function allocRegister(name: string, state: CompileState): number {\n    const i = state.r.indexOf(name);\n    if (i === -1) return state.r.push(name) - 1;\n    return i;\n}\nexport function allocNode(name: string, state: CompileState): number {\n    return state.nn.push(name) - 1;\n}\n\nexport function allocMod(name: string, state: CompileState, initial: number, mode: AutomatedValueMethod): number {\n    return state.mods.push([name, initial, mode]) - 1;\n}\n"],
  "mappings": "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",
  "names": []
}
