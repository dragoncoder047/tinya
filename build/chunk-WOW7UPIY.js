import{A as J,a as c,n as R,o as r,p as M,q as I,s as g,t as P,u as F,v as z,w as ee,x as Y,y as oe,z as q}from"./chunk-P5FSJCFO.js";async function H(t,o,i,a,p){let N=[],T={};for(var w,d=0;d<a.length;d++){let u=a[d];var S=d;if(r(u,n.KeywordArgument)){if(T[u.name])throw new P(`argument ${R(u.name)} already provided`,u.loc,[new I("note: first occurrance was here:",T[u.name].edgemost(!0).loc),...n.stackToNotes(t.callstack)]);if(w||(w=u),S=p[1].findIndex(b=>b[0]===u.name),S===-1)throw new P(`no such keyword argument ${R(u.name)} on node ${p[0]}`,u.loc,n.stackToNotes(t.callstack))}else{if(w)throw new P("positional argument can't come after keyword argument",u.loc,[new I("note: first keyword argument was here:",w.loc),...n.stackToNotes(t.callstack)]);if(d>=p[1].length)throw new P("too many arguments to "+p[0],u.edgemost(!0).loc,n.stackToNotes(t.callstack))}let f=p[1][S];T[f[0]]=u;let y=f[1],E=p[3][S]??null,x=c(async b=>{if(r(b,n.Call))return b;if(r(b,n.Symbol)){var C=E?.[b.value];if((C??void 0)===void 0)throw new P(E?`unknown symbol name ${R(b.value)} for parameter`:"symbol constant not valid here",b.loc,E?[new I("note: valid options are: "+Object.keys(E).join(", "),b.loc)]:[]);return r(C,n.Value)||(C=new n.Value(b.loc,C)),C}return b.pipe(x)},"walkAndReplaceSymbols");var m=await x(u);if(r(u,n.DefaultPlaceholder)){if((y??null)===null)throw new P(`missing value for argument ${f[0]}`,u.loc,n.stackToNotes(t.callstack));m=new n.Value(u.loc,y)}else{if(r(u,n.SplatValue))throw new P("splats are only valid in a list",u.loc,n.stackToNotes(t.callstack));o&&(m=await m.eval(t))}N[S]=m}for(var d=0;d<p[1].length;d++)if(N[d]===void 0){let f=p[1][d],y=f[1];if((y??null)===null)throw new P(`missing value for argument ${f[0]}`,i,n.stackToNotes(t.callstack));N[d]=new n.Value(i,y)}return N}c(H,"processArgsInCall");function te(t,o,i,a){let p=[t,[],0,[],null],N=[];var T=!1;let w=c(async(m,u)=>{if(T||await d(u),u.callstack.length>u.recursionLimit)throw new P("too much recursion",u.callstack.at(-1).loc,n.stackToNotes(u.callstack));let f=await H(u,!1,u.callstack.at(-1).loc,m,p),y={...u,env:Object.create(u.globalEnv)};for(var E=0;E<p[1].length;E++){let b=f[E];y.env[p[1][E][0]]=N[E]?await b.eval(u):b}let x=await a.eval(y);return o?x.eval(u):x},"f");return w.body=a,w;async function d(m){await S(m),T=!0;for(var u=0;u<i.length;u++){var f=i[u];if(r(f,n.Name))p[1].push([f.name,null]),p[3].push(void 0),N.push(!0);else if(r(f,n.ParameterDescriptor)){var y=f.defaultValue;r(y,n.DefaultPlaceholder)&&(y=null),p[1].push([f.name,y]),p[3].push(await f.enumOptions.toJS(m)),N.push(!f.lazy)}else throw new P("unreachable",f.loc,n.stackToNotes(m.callstack))}}c(d,"build");async function S(m){}c(S,"validate")}c(te,"makeCodeMacroExpander");var n;(Te=>{class t{constructor(A){this.loc=A}static{c(this,"Node")}}Te.Node=t;class o extends t{static{c(this,"NotCodeNode")}compile(A){throw new F("how did we get here ?!?",this.loc)}}Te.NotCodeNode=o;class i extends o{static{c(this,"Leaf")}edgemost(){return this}async pipe(){return this}async eval(A){return this}}Te.Leaf=i;class a extends o{constructor(e,s,l=null){super(e);this.attributes=s;this.value=l}static{c(this,"AnnotatedValue")}async pipe(e){return new a(this.loc,await V(this.attributes,e),this.value?await e(this.value):null)}edgemost(e){return e?this.attributes.length>0?this.attributes[0].edgemost(e):this:this.value??this}async eval(e){var s=this.value;for(var l of this.attributes){var h=null,v;if(r(l,d)||r(l,w)){v=l.name;let O=e.annotators[v];if(!O)throw new P("unknown annotation "+R(v),l.loc,_(e.callstack));r(l,d)&&(h=l.args),s=await O(s,h,e)}else throw new P("illegal annotation",l.loc,_(e.callstack))}return s}}Te.AnnotatedValue=a;class p extends i{constructor(e,s){super(e);this.value=s}static{c(this,"Value")}async eval(e){return r(this.value,t)?this.value:this}compile(e){return e.p.push(0,this.value),e.tosStereo=!1,e}}Te.Value=p;class N extends i{constructor(e,s){super(e);this.value=s}static{c(this,"Symbol")}async eval(e){return this}}Te.Symbol=N;class T extends t{constructor(e,s,l){super(e);this.target=s;this.value=l}static{c(this,"Assignment")}edgemost(e){return e?this.target.edgemost(e):this.value.edgemost(e)}async pipe(e){return new T(this.loc,await e(this.target),await e(this.value))}async eval(e){if(!r(this.target,w))throw new P("cannot assign to this",this.target.loc);let s=this.target.name,l=Object.hasOwn(e.env,s)?e.env:Object.hasOwn(e.globalEnv,s)?e.globalEnv:e.env;return l[s]=await this.value.eval(e)}compile(e,s){return this.value.compile(e,s),e.p.push(13,q(this.target.name,e)),e}}Te.Assignment=T;class w extends i{constructor(e,s){super(e);this.name=s}static{c(this,"Name")}async eval(e){let s=e.env[this.name];if(!s)throw new P("undefined: "+this.name,this.loc,_(e.callstack));return s}compile(e){return e.p.push(12,q(this.name,e)),e}}Te.Name=w;class d extends t{constructor(e,s,l){super(e);this.name=s;this.args=l}static{c(this,"Call")}edgemost(e){return e?this:this.args.at(-1)?.edgemost(e)??this}async pipe(e){return new d(this.loc,this.name,await V(this.args,e))}async eval(e){let s=e.functions.find(v=>v[0]===this.name);if(s){let[v,O,G]=s,k={...e,callstack:e.callstack.concat(this)};return G(this.args,k)}let l=e.nodes.find(v=>v[0]===this.name);if(!l)throw new P("undefined node or function "+this.name,this.loc,_(e.callstack));var h;return l[2]===2&&(h=new S(this.loc,this.args)).isImmediate()?new p(this.loc,l[4](null)(null,h.toImmediate())):new d(this.loc,l[0],await H(e,!0,this.loc,this.args,l))}compile(e,s){var l;let h=s.find(k=>k[0]===this.name);if(!h)throw new F(`cannot find node ${this.name} (should be unreachable!!)`,this.loc);let v=[],O=e.p;for(l=0;l<this.args.length;l++)e.p=[],this.args[l].compile(e,s),v.push([e.p,e.tosStereo?1:0]);e.p=O;let G=[16,J(this.name,e)];if(e.tosStereo=h[2]===1,h[1].every(k=>k[2]!==1)&&v.some(k=>k[1]===1)){for(l=0;l<h[1].length;l++)v[l][1]!==1&&v[l][0].push(15);e.tosStereo=!0,G[0]=17,G.push(J(this.name,e))}else{for(l=0;l<h[1].length;l++){let k=h[1][l][2]??0,Q=v[l][1];if(k!==1&&Q===1)throw new F("cannot implicitly convert stereo output to mono",this.args[l].loc);k===1&&Q!==1&&v[l][0].push(15)}e.tosStereo=h[2]===1}for(l=0;l<this.args.length;l++)e.p.push(...v[l][0]);return e.p.push(...G),e}}Te.Call=d;class S extends t{constructor(e,s){super(e);this.values=s}static{c(this,"List")}edgemost(e){return this.values.length>0?e?this.values[0].edgemost(e):this.values.at(-1).edgemost(e):this}async pipe(e){return new S(this.loc,await V(this.values,e))}async eval(e){let s=[];for(var l of this.values){let h=await l.eval(e);r(h,B)&&r(h.value,S)?s.push(...h.value.values):s.push(h)}return new S(this.loc,s)}hasSplats(){return this.values.some(e=>r(e,B))}isImmediate(){return this.values.every(e=>r(e,p)||r(e,S)&&e.isImmediate())}toImmediate(){if(this.isImmediate())return this.values.map(e=>r(e,p)?e.value:e.toImmediate())}static fromImmediate(e,s){return Array.isArray(s)?new S(e,s.map(l=>S.fromImmediate(e,l))):new p(e,s)}compile(e,s){if(this.isImmediate()){let h=this.toImmediate();e.p.push(0,h)}else{e.p.push(7);for(var l of this.values)r(l,B)?(l.value.compile(e,s),e.p.push(9)):(l.compile(e,s),e.p.push(8))}return e.tosStereo=this.values.length===2,e}}Te.List=S;class m extends o{constructor(e,s,l,h,v){super(e);this.name=s;this.outMacro=l;this.parameters=h;this.body=v}static{c(this,"Definition")}edgemost(e){return e?this.parameters.length>0?this.parameters[0].edgemost(e):this:this.body.edgemost(e)}async pipe(e){return new m(this.loc,this.name,this.outMacro,await V(this.parameters,e),await e(this.body))}async eval(e){return e.functions.push([this.name,this.parameters.length,te(this.name,this.outMacro,this.parameters,this.body)]),new p(this.loc,void 0)}}Te.Definition=m;class u extends o{constructor(e,s,l,h,v){super(e);this.name=s;this.enumOptions=l;this.defaultValue=h;this.lazy=v}static{c(this,"ParameterDescriptor")}edgemost(e){return e?this:this.defaultValue.edgemost(e)}async pipe(e){return new u(this.loc,this.name,await e(this.enumOptions),await e(this.defaultValue),this.lazy)}async eval(e){throw new P("cannot evaluate",this.loc,_(e.callstack))}}Te.ParameterDescriptor=u;class f extends o{constructor(e,s){super(e);this.result=s}static{c(this,"Template")}edgemost(e){return this.result.edgemost(e)}async pipe(e){return new f(this.loc,await e(this.result))}async eval(e){let s=c(async h=>{let v=await h.pipe(s);return v.loc=new M(h.loc.line,h.loc.col,h.loc.file,["note: expanded from template:",this.loc]),v},"replaceTrace"),l=c(async(h,v)=>{if(r(h,f))return h.pipe(O=>l(O,v+1));if(r(h,K)){if(v<=1)return s(await h.value.eval(e));{let O=await h.pipe(G=>l(G,v-1));return r(O,K)&&r(O.value,p)?O.value:O}}return h.pipe(O=>l(O,v))},"recur");return l(await s(this.result),1)}}Te.Template=f;class y extends t{constructor(e,s,l,h,v=!1,O){super(e);this.op=s;this.left=l;this.right=h;this.noLift=v;this.assign=O}static{c(this,"BinaryOp")}edgemost(e){return this[e?"left":"right"].edgemost(e)}async pipe(e){return new y(this.loc,this.op,await e(this.left),await e(this.right),this.noLift,this.assign)}async eval(e){return this._applied(await this.left.eval(e),await this.right.eval(e))}_applied(e,s){var l,h=!0,v,O;return r(e,p)?v=e.value:r(e,S)&&e.isImmediate()?v=e.toImmediate():h=!1,r(s,p)?O=s.value:r(s,S)&&s.isImmediate()?O=s.toImmediate():h=!1,(l=z[this.op]?.cb)&&h?S.fromImmediate(this.loc,l(v,O)):r(e,N)&&r(s,N)&&/^[!=]=$/.test(this.op)?S.fromImmediate(this.loc,l(e.value,O.value)):new y(this.loc,this.op,e,s)}compile(e,s){return this.left.compile(e,s),this.right.compile(e,s),e.p.push(10,this.op),e}}Te.BinaryOp=y;class E extends t{constructor(e,s,l){super(e);this.op=s;this.value=l}static{c(this,"UnaryOp")}edgemost(e){return e?this:this.value.edgemost(e)}async pipe(e){return new E(this.loc,this.op,await e(this.value))}async eval(e){return this._applied(await this.value.eval(e))}_applied(e){var s,l=!0,h;return r(e,p)?h=e.value:r(e,S)&&e.isImmediate()?h=e.toImmediate():l=!1,l&&(s=z[this.op]?.cu)?S.fromImmediate(this.loc,s(h)):new E(this.loc,this.op,e)}compile(e,s){return this.value.compile(e,s),e.p.push(11,this.op),e}}Te.UnaryOp=E;class x extends i{static{c(this,"DefaultPlaceholder")}async eval(A){throw new P("cannot evaluate",this.loc,_(A.callstack))}}Te.DefaultPlaceholder=x;class b extends o{constructor(e,s,l){super(e);this.name=s;this.arg=l}static{c(this,"KeywordArgument")}edgemost(e){return e?this:this.arg.edgemost(e)}async pipe(e){return new b(this.loc,this.name,await e(this.arg))}async eval(e){return new b(this.loc,this.name,await this.arg.eval(e))}}Te.KeywordArgument=b;class C extends o{constructor(e,s){super(e);this.mapping=s}static{c(this,"Mapping")}edgemost(e){return this.mapping.length>0?e?this.mapping[0].key.edgemost(e):this.mapping.at(-1).val.edgemost(e):this}async pipe(e){return new C(this.loc,await V(this.mapping,async({key:s,val:l})=>({key:await e(s),val:await e(l)})))}async eval(e){return new C(this.loc,await Promise.all(this.mapping.map(async({key:s,val:l})=>({key:await s.eval(e),val:await l.eval(e)}))))}async toJS(e){let s={};for(var{key:l,val:h}of this.mapping){if(!r(l,N))throw new Error("unreachable");s[l.value]=await h.eval(e)}return s}}Te.Mapping=C;class j extends t{constructor(e,s,l,h){super(e);this.cond=s;this.caseTrue=l;this.caseFalse=h}static{c(this,"Conditional")}edgemost(e){return(e?this.cond:this.caseFalse).edgemost(e)}async pipe(e){return new j(this.loc,await e(this.cond),await e(this.caseTrue),await e(this.caseFalse))}async eval(e){let s=await this.cond.eval(e);return r(s,p)?(s.value?this.caseTrue:this.caseFalse).eval(e):new j(this.loc,s,await this.caseTrue.eval(e),await this.caseFalse.eval(e))}compile(e,s){return this.caseFalse.compile(e,s),this.caseTrue.compile(e,s),this.cond.compile(e,s),e.p.push(14),e}}Te.Conditional=j;class K extends o{constructor(e,s){super(e);this.value=s}static{c(this,"InterpolatedValue")}edgemost(e){return this.value.edgemost(e)}async pipe(e){return new K(this.loc,await e(this.value))}async eval(e){throw new P("too many &'s",this.loc,_(e.callstack))}}Te.InterpolatedValue=K;class B extends o{constructor(e,s){super(e);this.value=s}static{c(this,"SplatValue")}edgemost(e){return this.value.edgemost(e)}async pipe(e){return new B(this.loc,await e(this.value))}async eval(e){return new B(this.loc,await this.value.eval(e))}}Te.SplatValue=B;class we extends i{static{c(this,"PipePlaceholder")}async eval(A){throw new P("not valid outside of a pipe expression",this.loc,_(A.callstack))}}Te.PipePlaceholder=we;class Z extends t{constructor(e,s){super(e);this.body=s}static{c(this,"Block")}edgemost(e){return this.body.length>0?e?this.body[0].edgemost(e):this.body.at(-1).edgemost(e):this}async pipe(e){return new Z(this.loc,await V(this.body,e))}async eval(e){var s=new p(this.loc,void 0);for(var l of this.body)r(l,x)?s=new p(l.loc,void 0):s=await l.eval(e);return s}compile(e,s){for(var l of this.body)l.compile(e,s),e.p.push(6);return e.p.pop(),e}}Te.Block=Z;async function V(L,A){return await Promise.all(L.map(A))}c(V,"asyncNodePipe");function _(L){let A=[];for(var e of L)A.push(new I(`note: while evaluating function ${R(e.name)}`,e.loc));return A.reverse()}Te.stackToNotes=_,c(_,"stackToNotes")})(n||={});var D=class{constructor(o,i,a,p){this.t=o;this.s=i;this.k=a;this.a=p}static{c(this,"Token")}};var ue=[[[0],/^\/\/[^\n]*/],[[0,1],/^\/\*/,,1],[[1],/^\*\//,,4],[[1],/^((?!(\*\/)|(\/\*)).)+/],[[0],/^"/,5,2],[[2],/^"/,6,4],[[2],/^\\[abefnrtvz'"\\]/,8],[[2],/^\\(x[0-9a-f]{2}|u[0-9a-f]{4}|u\{[0-9a-f]+\})/i,8],[[2],/^\\./,9],[[2],/^[^\\"]+/,7],[[0],/^'/,5,3],[[3],/^'/,6,4],[[3],/^\\'/,8],[[3],/^\\./,7],[[3],/^[^\\']+/,7],[[0],/^-?(\.\d+|\d+\.?\d*)(e[+-]?\d+)?/i,1],[[0],ee,3],[[0],/^[()[\]{}]/,2],[[0],/^\w+/,0],[[0,1],/^[\s\n]+/]];function ne(t,o){var i=0,a=0;let p=[],N=[0];e:for(;t.length>0;){for(var[T,w,d,S]of ue){if(T.every(u=>N.at(-1)!==u))continue;let m=w.exec(t);if(m){let u=m[0];d!==void 0&&p.push(new D(u,new M(i,a,o),d));let f=u.split(`
`);f.length>1?(a=f.at(-1).length,i+=f.length-1):a+=u.length,t=t.slice(u.length),S!==void 0&&(S===4?N.pop():N.push(S));continue e}}throw new g(`unexpected ${R(t[0])}`,new M(i,a,o))}return p}c(ne,"tokenize");function ie(t,o=!1){var i;de(t),fe(t),me(t);let a=t.find(m=>r(m,D));for(;t.length>1;){var p=1/0,N=-1,T=1/0,w=-1,d=!1;let m=t.findLastIndex(u=>r(u,n.Node));for(i=0;i<t.length;i++){let u=t[i];if(r(u,n.Node))d=!0;else{if(i>m)throw new g("expected a value after operator",u.s);if(d){let f=Y(u,!1);(p>f||p===f&&oe(u.t))&&(p=f,N=i)}else{if(!r(t[i+1],n.Node))continue;let f=Y(u,!0),y=t[i+2];if(y&&Y(y,!1)<f)continue;T>f&&(T=f,w=i)}d=!1}}if(w>=0){let[u,f]=t.splice(w,2);t.splice(w,0,new n.UnaryOp(u.s,u.t,f))}else if(N>=0){let[u,f,y]=t.splice(N-1,3),E=new n.BinaryOp(f.s,f.t,u,y,!1,f.a);t.splice(N-1,0,E)}else throw new g("unknown error in expression parsing",a?.s)}let S=t[0];return o&&r(S,n.BinaryOp)&&(S.noLift=!0),S}c(ie,"treeifyExpression");function de(t){for(var o=[],i=0;i<t.length;i++){let a=t[i];if(r(a,D))if(a.t==="#!"){let p=t.splice(i,2)[1];if(!(r(p,n.Name)||r(p,n.Call)))throw new g("expected attribute after '#!'",a.s);o.push(p),i--}else o.length>0&&(t.splice(i,0,new n.AnnotatedValue(a.s,o,null)),o=[]);else o.length>0&&(t[i]=new n.AnnotatedValue(a.loc,o,a),o=[])}o.length>0&&t.push(new n.AnnotatedValue(o.at(-1).loc,o,null))}c(de,"attributesHack");function fe(t){for(var o=0;o<t.length;o++){let i=t[o-1],a=t[o],p=t[o+1];r(a,D)&&a.t==="#"&&!(r(i,n.Node)||r(p,n.Node))&&(t[o]=new n.PipePlaceholder(a.s))}}c(fe,"pipePlaceholdersHack");function me(t){for(var o=-1;o<t.length;o++){let i=t[o],a=t[o+1];if(re(i)&&re(a))t.splice(o+1,0,new n.DefaultPlaceholder(a?.s??i?.s??M.nowhere));else if(X(i)&&X(a)&&i.k===3&&a.k===3&&a.t==="=")t.splice(o,2,new D(i.t,i.s,i.k,a.s));else if(r(i,n.Node)&&r(a,n.Node))throw new g("expected operator before value",a.edgemost(!1).loc)}}c(me,"commaAndAssignHack");function re(t){return!t||X(t)&&/^[,:;]$/.test(t.t)}c(re,"commaIsh");function X(t){return r(t,D)}c(X,"tokenLike");function $(t,o=!1){return r(t,n.BinaryOp)&&/^[,;]$/.test(t.op)&&(o||!t.noLift)?[...$(t.left),...$(t.right)]:[t]}c($,"liftCommas");function he(t){return({a:"a",b:"\b",e:"e",f:"\f",n:`
`,r:"\r",t:"	",v:"\v",z:"\0","'":"'",'"':'"',"\\":"\\",x:!1,u:!1}[t.toLowerCase()[0]]??t)||String.fromCodePoint(parseInt(/[0-9a-f]+/i.exec(t)[0],16))}c(he,"unescape");function ae(t){var o=0;let i=c((T,w)=>{if(T&&o>=t.length){if(w)throw new g(`${R(w.t)} was never closed`,w.s);let d=t.at(-1);throw new g("unexpected EOF",d?.s)}return t[o++]},"nextToken"),a=c(T=>{var w="";e:for(;;){let d=i(!0,T);switch(d.k){case 6:break e;case 7:w+=d.t;break;case 8:w+=he(d.t.slice(1));break;case 9:throw new g("illegal escape sequence",d.s)}}return new n.Value(T.s,w)},"parseString"),p=c((T,w)=>{let d=i(T,w);if(d!==void 0){switch(d.k){case 1:return new n.Value(d.s,parseFloat(d.t));case 5:return a(d);case 0:let S=i(!1);return S&&S.t==="("?new n.Call(d.s,d.t,$(N(")",S),!0)):(o--,new n.Name(d.s,d.t));case 2:switch(d.t){case"{":return new n.Template(d.s,N("}",d));case"[":return new n.List(d.s,$(N("]",d),!0));case"(":return N(")",d,!0);case")":case"]":case"}":throw new g(w?`expected ${R({"(":")","[":"]","{":"}"}[w.t])}`:"stray close paren",d.s,w?[new I("note: to match this "+R(w.t),w.s)]:[])}case 3:if(!T&&/^[,;)]$/.test(d.t)){o--;return}}throw new g(`unexpected ${{0:"name",3:"operator"}[d.t]??R(d.t)}`,d.s)}},"parseThing"),N=c((T,w,d=!1)=>{let S=[];for(;;){var m=i(!!T,w);if(!T&&m===void 0||m.t===T)break;switch(m.k){case 3:S.push(m);break;default:o--;let u=p(!1,w);u!==void 0&&S.push(u)}}return ie(S,d)},"parseExpression");return N(!1)}c(ae,"parseTokens");function W(t){return r(t,n.BinaryOp)&&t.op==="|>"}c(W,"isPipe");async function se(t){var o=0;let i=c(async a=>(r(a,n.PipePlaceholder)&&o++,W(a)?await a.left.pipe(i):await a.pipe(i),a),"count");return await i(t),o}c(se,"countPlaceholdersIn");async function U(t,o){return r(t,n.PipePlaceholder)?o:W(t)?await t.pipe(async i=>i===t.left?i:await U(i,o)):await t.pipe(async i=>await U(i,o))}c(U,"replacePlaceholdersWith");var Ne=[c(async function t(o){if(!r(o,n.UnaryOp)||o.op!==".")return o.pipe(t);if(!r(o.value,n.Name))throw new g('unexpected "."',o.loc);return new n.Symbol(o.value.loc,o.value.name)},"expandSymbols"),c(async function t(o){return o=await o.pipe(t),r(o,n.UnaryOp)&&o.op==="&"&&(o=new n.InterpolatedValue(o.loc,o.value)),o},"expandInterpolations"),c(async function t(o){if(o=await o.pipe(t),!r(o,n.List))return o;let i=o.values,a=i.findIndex(T=>r(T,n.BinaryOp)&&T.op==="=>");if(a<0){let T=i.find(w=>r(w,n.BinaryOp)&&w.op===":");if(T)throw new g('mappings use "=>", not ":"',T.loc);return o}let p=[];for(var N=0;N<i.length;N++){let T=i[N];if(!r(T,n.BinaryOp)||T.op!=="=>")throw new g(r(T,n.DefaultPlaceholder)?"illegal trailing comma in mapping":'expected "=>" after key value',T.edgemost(!1).loc,N<a?[new I('hint: the "=>" first used here makes this a mapping, not a list',i[a].loc)]:[]);p.push({key:T.left,val:T.right})}return new n.Mapping(o.edgemost(!0).loc,p)},"expandMapping"),c(async function t(o){return!r(o,n.BinaryOp)||o.op!==","&&o.op!==";"?o.pipe(t):new n.Block(o.edgemost(!0).loc,await Promise.all($(o,!0).map(t)))},"commasToBlocks"),c(async function t(o){if(o=await o.pipe(t),r(o,n.Call))for(;r(o.args.at(-1),n.DefaultPlaceholder);)o.args.pop();return o},"trimDefaultSentinelsInCallExpression"),c(async function t(o){if(o=await o.pipe(t),r(o,n.Block))for(var i=0;i<o.body.length-1;i++)r(o.body[i],n.DefaultPlaceholder)&&(o.body.splice(i,1),i--);return o},"trimDefaultSentinelsInBlock"),c(async function t(o,i=!1){if(!r(o,n.BinaryOp)||o.op!==":-")return o.pipe(t);var a=i?o.left:await o.left.pipe(t);let p=i?o.right:await o.right.pipe(t);var N=!1;if(r(a,n.UnaryOp)&&a.op==="@"&&(a=a.value,N=!0),!r(a,n.Call)){if(r(a,n.AnnotatedValue)&&a.value!==null)return o.left=a.value,new n.AnnotatedValue(a.loc,a.attributes,await t(o,!0));throw new g("illegal header",a.edgemost(!0).loc,[new I("note: definition operator is here",o.loc)])}let T=a.args;var w;let d=[];for(var S=0;S<T.length;S++){var m=T[S],u=!1;if(r(m,n.UnaryOp)&&m.op==="@"&&(m=m.value,u=!0),r(m,n.Name)){if(w)throw new g("required parameter follows optional parameter",m.loc,[new I("note: first optional parameter is here",w.loc)]);d.push(u?new n.ParameterDescriptor(m.loc,m.name,new n.Mapping(m.loc,[]),new n.DefaultPlaceholder(m.loc),!0):m);continue}if(!r(m,n.BinaryOp)||m.op!==":"&&m.op!=="=")throw new g("illegal parameter",m.edgemost(!0).loc);var f=m.left,y,E;switch(m.op){case":":if(E=void 0,!r(m.right,n.Mapping))throw new g("expected a mapping",m.right.loc);y=m.right;for(var{key:x}of y.mapping)if(!r(x,n.Symbol))throw new g("expected a symbol here",x.edgemost(!1).loc,[new I("note: while defining enum options for parameter",f.loc),...r(x,n.Name)?[new I(`hint: put a "." before the ${R(x.name)} to make it a static symbol instead of a variable`,x.loc)]:[]]);break;case"=":if(y=new n.Mapping(m.loc,[]),r(f,n.BinaryOp)&&f.op===":"){if(!r(f.right,n.Mapping))throw new g("expected a mapping",f.right.loc);y=f.right,f=f.left}E=m.right;break;default:throw"unreachable"}if(E===void 0?E=new n.DefaultPlaceholder(f.loc):w||(w=f),r(f,n.UnaryOp)&&f.op==="@"&&(m=f.value,u=!0),!r(f,n.Name))throw new g("illegal parameter name for optional parameter",f.edgemost(!1).loc);d.push(new n.ParameterDescriptor(f.loc,f.name,y,E,u))}return new n.Definition(a.loc,a.name,N,d,p)},"expandDefinitions"),c(async function t(o){if(!r(o,n.BinaryOp)||o.op!=="="&&!o.assign)return o.pipe(t);let i=await o.left.pipe(t);var a=await o.right.pipe(t);return o.assign&&(a=new n.BinaryOp(o.loc,o.op,i,a)),new n.Assignment(i.loc,i,a)},"expandAssignments"),c(async function t(o){if(!r(o,n.BinaryOp)||o.op!=="?")return o.pipe(t);let i=await o.left.pipe(t),a=await o.right.pipe(t);if(!r(a,n.BinaryOp)||a.op!==":")throw new g('expected ":" after expression',(r(a,n.BinaryOp)?a:a.edgemost(!1)).loc,[new I('note: "?" is here:',o.loc)]);return new n.Conditional(o.loc,i,a.left,a.right)},"expandTernaryOperators"),c(async function t(o,i=null){if(!r(o,n.BinaryOp)||o.op!==":")return o.pipe(N=>t(N,o));let a=await o.left.pipe(N=>t(N)),p=await o.right.pipe(N=>t(N));if(!r(a,n.Name))throw r(i,n.Call)?new g('expected name before ":"',a.edgemost(!1).loc):new g('unexpected ":"',o.loc);if(!r(i,n.Call)&&!r(i,n.Definition))throw new g("named parameter not directly inside a callsite",a.loc);return new n.KeywordArgument(a.loc,a.name,p)},"createKeywordArguments"),c(async function t(o){if(!r(o,n.List))return o.pipe(t);let i=await Promise.all(o.values.map(t));if(i.length===1&&r(i[0],n.DefaultPlaceholder))return new n.List(o.loc,[]);for(var a=0;a<i.length;a++){let p=i[a];if(r(p,n.DefaultPlaceholder))throw new g(a+1===i.length?"illegal trailing comma in list":"empty elements not allowed in list",p.loc,[new I("note: list starts here",o.loc)])}return new n.List(o.loc,i)},"fixAndValidateListDefaultSentinels"),c(async function t(o){return!r(o,n.UnaryOp)||o.op!=="*"?o.pipe(t):new n.SplatValue(o.loc,await o.value.pipe(t))},"transformUnarySplatOperators"),c(async function t(o){if(o=await o.pipe(t),!W(o))return o;let i=new n.Name(o.loc,["_pipe",o.loc.file.replace(/[^a-z]/ig,""),o.loc.line,o.loc.col].join("_")),a=o.left,p=o.right,N=await se(p);if(N===0)throw new g("missing '#' placeholder in pipe expression",p.loc,[new I("note: required by this pipe operator",o.loc)]);return N>1&&!r(a,n.Value)?new n.Block(o.loc,[new n.Assignment(o.loc,i,a),await U(p,i)]):U(p,a)},"expandPipeOperators")];async function le(t){for(var o of Ne)t=await o(t);return t}c(le,"transformAST");function Ro(t,o){return le(ae(ne(t,o)))}c(Ro,"parse");export{n as a,Ro as b};
//# sourceMappingURL=chunk-WOW7UPIY.js.map
